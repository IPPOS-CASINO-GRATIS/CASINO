<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Poker</title>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YN9CKJS2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J1YN9CKJS2');
</script>
<meta name="description" content="Gioca a Poker Texas Hold'em 1 contro 1 con grafica migliorata e animazioni. Sfida un amico o mettiti alla prova contro il Bot, con salvataggio online del saldo." />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap" rel="stylesheet">
<meta name="google-adsense-account" content="ca-pub-9456850571765688">
<style>
  /* --- CSS Invariato (uguale alla versione precedente) --- */
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap');
  :root {
    --bg-color: #1e5631; --text-color: #ffffff; --card-bg: white; --card-text-black: black; --card-text-red: red; --button-bg: #e0e0e0; --button-text: #333333; --button-hover-bg: #d0d0d0; --button-disabled-opacity: 0.5; --highlight-color: #ffeb3b; --border-color: rgba(255, 255, 255, 0.2); --panel-bg: rgba(0, 0, 0, 0.3); --accent-color: #4fc3f7; --dealer-hidden-card-bg: #8b4513; --font-main: 'Nunito', sans-serif; --result-bg-color: rgba(0, 0, 0, 0.75); --result-text-color: #ffffff; --result-win-glow: rgba(76, 175, 80, 0.8); --result-lose-glow: rgba(244, 67, 54, 0.8); --result-push-glow: rgba(255, 152, 0, 0.8);
   }
  body[data-theme="dark"] {
    --bg-color: #1f1f1f; --text-color: #dcdcdc; --card-bg: #383838; --card-text-black: #dcdcdc; --card-text-red: #ff9a8f; --button-bg: #4a4a4a; --button-text: #dcdcdc; --button-hover-bg: #5a5a5a; --highlight-color: #ffd700; --border-color: rgba(255, 255, 255, 0.15); --panel-bg: rgba(255, 255, 255, 0.1); --accent-color: #4fc3f7; --dealer-hidden-card-bg: #252525; background-image: radial-gradient(circle at top center, hsl(0, 0%, 18%) 0%, var(--bg-color) 70%); background-attachment: fixed;
   }
  body {
    font-family: var(--font-main); text-align: center; background-color: var(--bg-color); color: var(--text-color); padding-top: 15px; margin: 0; transition: background-color 0.3s, color 0.3s, background-image 0.3s; background-image: none; min-height: 100vh; display: flex; flex-direction: column; align-items: center;
   }
  .game-container {
    max-width: 1100px; width: 95%; margin: 0 auto; padding: 20px; position: relative; overflow-x: hidden; flex-grow: 1; display: flex; flex-direction: column;
   }
   #game-mode-selection {
     margin: auto;
     text-align: center;
     background-color: var(--panel-bg);
     padding: 30px 40px;
     border-radius: 15px;
     border: 1px solid var(--border-color);
     max-width: 500px;
     box-shadow: 0 4px 10px rgba(0,0,0,0.3);
   }
   #game-mode-selection h2{
       margin-top: 0;
       margin-bottom: 25px;
       color: var(--accent-color);
       font-size: 1.8em;
   }
   #game-mode-selection button {
       margin: 10px;
       min-width: 200px;
       font-size: 1.1em;
       padding: 12px 20px;
   }
  #poker-table {
      display: flex; flex-direction: column; align-items: center; justify-content: space-between; border: 2px solid var(--border-color); border-radius: 150px / 80px; padding: 30px; margin: 20px auto; background-color: rgba(0,0,0,0.1); min-height: 450px; width: 100%; box-sizing: border-box;
   }
  .player-info-area {
      border: 1px solid var(--border-color); border-radius: 10px; padding: 15px; margin-bottom: 15px; background-color: var(--panel-bg); width: 80%; max-width: 400px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); position: relative; } .player-info-area h2 { margin-top: 0; margin-bottom: 10px; font-size: 1.3em; color: var(--accent-color); } .player-info-area p { margin: 5px 0; font-size: 0.95em; } .player-balance span, .player-bet span { font-weight: bold; color: var(--highlight-color); } .player-status span { font-style: italic;
   }
  .dealer-button {
      position: absolute; top: 10px; right: 10px; background-color: white; color: black; border-radius: 50%; width: 30px; height: 30px; line-height: 30px; text-align: center; font-weight: bold; font-size: 1em; border: 1px solid black; box-shadow: 0 1px 3px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; } #dealer-button-p1 { right: 10px; left: auto; } #dealer-button-p2 { right: 10px; left: auto;
   }
  #community-area {
      text-align: center; padding: 15px; margin: 10px 0; width: 90%; max-width: 500px; } #community-area h2 { font-size: 1.2em; margin-bottom: 10px; } #pot-display { font-size: 1.3em; font-weight: bold; margin-top: 15px; } #pot-display span { color: var(--highlight-color); } #game-phase-display{ font-size: 1em; margin-top: 8px; color: var(--text-color); }
   #turn-indicator {
       font-size: 1.1em;
       margin-top: 8px;
       padding: 5px 10px;
       border-radius: 5px;
       transition: background-color 0.3s, transform 0.3s, color 0.3s;
       min-height: 1.5em;
   }
   #turn-indicator span { font-weight: bold; color: var(--accent-color); }
   #turn-indicator.player2-turn {
       background-color: var(--highlight-color);
       color: black;
       transform: scale(1.05);
   }
   #turn-indicator.player2-turn span {
       color: black;
       font-weight: bold;
   }
   .cards {
    margin: 10px auto; display: flex; justify-content: center; min-height: 110px; gap: 8px; flex-wrap: wrap; perspective: 1000px;
   }
  .card.entering {
      opacity: 0;
      transform: translateY(20px) rotateY(180deg);
  }
  .card {
    display: inline-block; border: 1px solid var(--border-color); border-radius: 6px; background: var(--card-bg); width: 60px; height: 90px; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3); margin: 3px; position: relative; transform-style: preserve-3d;
    transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1), opacity 0.5s ease-out;
    opacity: 1;
    transform: rotateY(180deg);
  }
  .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transform-style: preserve-3d; } .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: 6px; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 4px; box-sizing: border-box; } .card-front { background-color: var(--card-bg); background-image: linear-gradient(to bottom, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.05) 100%); color: var(--card-text-black); font-size: 20px; font-weight: bold; transform: rotateY(0deg); border: 1px solid rgba(0,0,0,0.1); } .card-back { background-color: var(--dealer-hidden-card-bg); color: var(--text-color); transform: rotateY(180deg); background-image: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%), linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.1) 75%), linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.1) 75%); background-size: 15px 15px; }
  .card.flipped { transform: rotateY(0deg); opacity: 1; }
  .card.hidden { transform: rotateY(180deg); opacity: 1; }
  .card-front.red { color: var(--card-text-red); } .card-front.black { color: var(--card-text-black); } .card .suit { font-size: 14px; font-weight: normal; line-height: 1;
   }
   #betting-actions {
       margin-top: 20px; width: 100%; display: flex; flex-direction: column; align-items: center;
   }
  #buttons, #betting-buttons, #utility-controls div {
    margin-top: 10px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; align-items: center; } #utility-controls { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 10px; padding: 15px; margin: 20px auto; max-width: 500px; } #utility-controls h3 { width: 100%; text-align: center; margin-top: 0; margin-bottom: 15px; color: var(--accent-color); font-size: 1.2em; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); } #utility-controls div { margin-bottom: 8px; } #utility-controls label { margin-right: 10px; font-weight: normal; } #utility-controls span#game-mode-display { font-weight: bold; color: var(--highlight-color);
   }
  button, .toggle-switch label {
    padding: 10px 18px; font-size: 14px; font-weight: bold; font-family: var(--font-main); margin: 5px; cursor: pointer; border: none; border-radius: 6px; background-color: var(--button-bg); color: var(--button-text); transition: background-color 0.2s ease, opacity 0.3s ease, transform 0.15s ease, box-shadow 0.2s ease; user-select: none; -webkit-user-select: none; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); letter-spacing: 0.5px; } #buttons button { min-width: 80px; } button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-2px); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); } button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); } button:disabled { opacity: var(--button-disabled-opacity); cursor: not-allowed; box-shadow: none; transform: none;
   }
   #betting-area {
    margin-bottom: 15px; display: flex; flex-direction: column; align-items: center; gap: 10px; background-color: var(--panel-bg); padding: 15px; border-radius: 10px; width: 90%; max-width: 600px; } #betting-area h3 { margin-top: 0; margin-bottom: 10px; color: var(--accent-color);} #bet-input-area { display: flex; align-items: center; gap: 10px; margin-top: 10px; flex-wrap: wrap; justify-content: center; } #bet-input-area label { margin-right: 5px; } #bet-input-area input[type="number"] { width: 80px; padding: 8px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--card-bg); color: var(--card-text-black); text-align: right; font-size: 1em; } body[data-theme="dark"] #bet-input-area input[type="number"] { color: var(--text-color); background-color: var(--button-bg); } #bet-input-area input[type=number]::-webkit-inner-spin-button, #bet-input-area input[type=number]::-webkit-outer-spin-button { opacity: 1;
   }
  #clickable-chips {
      display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 10px; } .chip-button { width: 45px; height: 45px; cursor: pointer; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); transition: transform 0.1s ease-out, opacity 0.3s ease, box-shadow 0.2s ease, border-color 0.2s ease; box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0,0,0,0.2); user-select: none; -webkit-user-select: none; background-color: transparent; display: flex; justify-content: center; align-items: center; overflow: hidden; padding: 0; } .chip-button img { display: block; width: 100%; height: 100%; border-radius: 50%; } .chip-button:hover:not([disabled]) { transform: scale(1.05); border-color: white; box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4), 0 0 8px 2px var(--highlight-color); } .chip-button:active:not([disabled]) { transform: scale(0.98); box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5); } .chip-button[disabled] { opacity: 0.4; cursor: not-allowed; transform: none; border-color: rgba(255, 255, 255, 0.3); box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.4);
   }
  #action-amount-display {
    font-size: 1.1em; font-weight: bold; color: var(--highlight-color); min-height: 1.3em;
   }
  #result {
    opacity: 0; visibility: hidden; transform: translate(-50%, -50%) scale(0.8); transition: opacity 0.4s ease-out, visibility 0.4s ease-out, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: fixed; top: 50%; left: 50%; z-index: 100; background-color: var(--result-bg-color); color: var(--result-text-color); padding: 20px 35px; border-radius: 12px; font-size: 1.8em; font-weight: bold; text-align: center; white-space: pre-line; min-width: 280px; max-width: 80%; box-shadow: 0 0 15px 4px rgba(0, 0, 0, 0.4); } #result.result-show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); } #result.result-win { box-shadow: 0 0 20px 8px var(--result-win-glow); } #result.result-lose { box-shadow: 0 0 20px 8px var(--result-lose-glow); } #result.result-push { box-shadow: 0 0 20px 8px var(--result-push-glow);
   }
   .toggle-switch {
     position: relative; display: inline-block; width: 50px; height: 24px; vertical-align: middle; } .toggle-switch input { opacity: 0; width: 0; height: 0; } .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 24px; } .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; } input:checked + .slider { background-color: var(--accent-color); } input:focus + .slider { box-shadow: 0 0 2px var(--accent-color); } input:checked + .slider:before { transform: translateX(26px);
   }
  /* --- Media Queries (Invariate) --- */
  @media (max-width: 768px) {
      #poker-table { padding: 20px; border-radius: 100px / 50px; min-height: 400px;} .player-info-area { width: 90%; padding: 12px;} .card { width: 55px; height: 82px; border-radius: 5px;} .card-front { font-size: 18px; } .card .suit { font-size: 13px; } button, .toggle-switch label { font-size: 13px; padding: 9px 14px;} #result { font-size: 1.5em; padding: 18px 25px; } .chip-button { width: 40px; height: 40px; border-width: 2px; } #betting-area { width: 95%; } #game-mode-selection button { min-width: 180px; font-size: 1em; }
   }
   @media (max-width: 480px) {
       body { padding-top: 10px; } .game-container { padding: 10px; width: 100%;} #poker-table { padding: 15px 10px; border-radius: 80px / 40px; min-height: auto;} .player-info-area { width: 95%; padding: 10px;} .player-info-area h2 { font-size: 1.1em; } .player-info-area p { font-size: 0.9em; } .cards { min-height: 70px; gap: 4px;} .card { width: 45px; height: 65px; border-radius: 4px; margin: 2px;} .card-front { font-size: 14px; } .card .suit { font-size: 10px; } #buttons, #betting-buttons, #utility-controls div { margin-top: 8px; gap: 5px;} button, .toggle-switch label { font-size: 11px; padding: 7px 9px; margin: 3px;} #buttons button { min-width: 60px; } #result { font-size: 1.1em; padding: 12px 15px; min-width: 200px;} #utility-controls { padding: 10px; margin: 15px auto;} .chip-button { width: 35px; height: 35px;} #action-amount-display { font-size: 1em; } #bet-input-area input[type="number"] { width: 60px; padding: 6px; font-size: 0.9em;} #betting-area { padding: 10px; } .dealer-button { width: 24px; height: 24px; line-height: 24px; font-size: 0.8em; top: 5px; right: 5px;} #pot-display { font-size: 1.1em; } #game-mode-selection { padding: 20px; } #game-mode-selection h2 { font-size: 1.5em; } #game-mode-selection button { min-width: 150px; font-size: 1em; padding: 10px 15px; } #turn-indicator { font-size: 1em; }
   }

</style>
</head>
<body data-theme="light">
<div class="game-container">

<button id="change-game-button" style="position: absolute; top: 15px; left: 15px; z-index: 10;" onclick="changeGame()">Cambia Gioco</button>


    <div id="game-mode-selection">
        <h2>Poker 1v1</h2>
        <p style="margin-bottom: 25px; font-size: 1.1em;">Scegli la modalità di gioco:</p>
        <div>
            <button id="pvp-button" onclick="selectGameMode('PVP')">Giocatore vs Giocatore</button>
        </div>
        <div>
            <button id="pvb-button" onclick="selectGameMode('PVB')">Giocatore vs Bot</button>
        </div>
    </div>

    <div id="game-area" style="display: none;">

        <div id="utility-controls">
             <h3>Utilità</h3>
             <div><label for="theme-toggle">Tema Scuro</label><label class="toggle-switch"><input type="checkbox" id="theme-toggle"><span class="slider"></span></label></div>
             <div><label>Modalità:</label> <span id="game-mode-display">N/D</span></div>
             <div><button onclick="showRules()">Regole Base</button><button id="quit-game-button" onclick="quitGame()">Abbandona</button></div>
             </div>

        <div id="poker-table">
             <div id="player2-info" class="player-info-area">
                 <h2 id="player2-name">Giocatore 2</h2>
                 <p class="player-balance">Saldo: $<span id="player2-balance">1000</span></p>
                 <div class="player-cards">
                     <div id="player2-cards" class="cards" aria-label="Carte del Giocatore 2"></div>
                 </div>
                 <p class="player-status">Stato: <span id="player2-status">-</span></p>
                 <p class="player-bet">Puntata: $<span id="player2-bet">0</span></p>
                 <div class="dealer-button" id="dealer-button-p2" style="display: none;">D</div>
             </div>

            <div id="community-area">
                <h2>Carte Comuni</h2>
                <div id="community-cards" class="cards" aria-label="Carte comuni sul tavolo"></div>
                <p id="pot-display">Piatto Totale: $<span id="pot-amount">0</span></p>
                <p id="game-phase-display">Fase: <span id="game-phase">-</span></p>
                <p id="turn-indicator">Turno di: <span id="current-player-turn">-</span></p>
            </div>

            <div id="player1-info" class="player-info-area">
                <h2>Giocatore 1</h2>
                <p class="player-balance">Saldo: $<span id="player1-balance">1000</span></p>
                <div class="player-cards">
                    <div id="player1-cards" class="cards" aria-label="Carte del Giocatore 1"></div>
                </div>
                <p class="player-status">Stato: <span id="player1-status">-</span></p>
                <p class="player-bet">Puntata: $<span id="player1-bet">0</span></p>
                <div class="dealer-button" id="dealer-button-p1" style="display: none;">D</div>
            </div>
        </div>

        <div id="betting-actions">
             <div id="betting-area" style="display: none;">
                  <h3>La tua Azione</h3>
                  <div id="clickable-chips" style="margin-bottom: 10px;">
                       <img src="data:image/svg+xml;charset=utf-8,%3Csvg width='50' height='50' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='48' fill='%23FFFFFF' stroke='%23000000' stroke-width='2'/%3E%3Ctext x='50' y='55' font-family='sans-serif' font-size='40' font-weight='bold' fill='%23000000' text-anchor='middle' dominant-baseline='middle'%3E10%3C/text%3E%3C/svg%3E" alt="Fiche da $10" class="chip-button" data-value="10" draggable="false">
                       <img src="data:image/svg+xml;charset=utf-8,%3Csvg width='50' height='50' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='48' fill='%23FF0000' stroke='%23000000' stroke-width='2'/%3E%3Ctext x='50' y='55' font-family='sans-serif' font-size='40' font-weight='bold' fill='%23FFFFFF' text-anchor='middle' dominant-baseline='middle'%3E50%3C/text%3E%3C/svg%3E" alt="Fiche da $50" class="chip-button" data-value="50" draggable="false">
                       <img src="data:image/svg+xml;charset=utf-8,%3Csvg width='50' height='50' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='48' fill='%23000000' stroke='%23FFFFFF' stroke-width='2'/%3E%3Ctext x='50' y='55' font-family='sans-serif' font-size='35' font-weight='bold' fill='%23FFFFFF' text-anchor='middle' dominant-baseline='middle'%3E100%3C/text%3E%3C/svg%3E" alt="Fiche da $100" class="chip-button" data-value="100" draggable="false">
                       <img src="data:image/svg+xml;charset=utf-8,%3Csvg width='50' height='50' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='50' cy='50' r='48' fill='%23800080' stroke='%23FFFFFF' stroke-width='2'/%3E%3Ctext x='50' y='55' font-family='sans-serif' font-size='35' font-weight='bold' fill='%23FFFFFF' text-anchor='middle' dominant-baseline='middle'%3E500%3C/text%3E%3C/svg%3E" alt="Fiche da $500" class="chip-button" data-value="500" draggable="false">
                  </div>
                  <div id="betting-buttons">
                       <button id="clear-bet-button" onclick="clearActionAmount()" disabled>Azzera</button>
                       <button id="pot-bet-button" onclick="setBetAmount('pot')" disabled>Piatto</button>
                       <button id="all-in-button" onclick="setBetAmount('allin')" disabled>All-in</button>
                  </div>
                  <div id="bet-input-area" style="display: none;"> <label for="bet-amount">Importo Totale:</label>
                     <input type="number" id="bet-amount" min="1" step="1">
                     <button id="confirm-bet-button" onclick="submitBetRaise()">Conferma</button>
                     <button id="cancel-bet-button" onclick="cancelBetRaiseInput()">Annulla</button> </div>
                 <p id="action-amount-display" style="font-weight: bold; margin-top: 10px;">Importo Azione: $0</p>
             </div>
            <div id="buttons">
                 <button id="fold-button" onclick="playerAction('fold')" disabled>Fold</button>
                 <button id="check-button" onclick="playerAction('check')" disabled>Check</button>
                 <button id="call-button" onclick="playerAction('call')" disabled>Call $<span id="call-amount">0</span></button>
                 <button id="bet-button" onclick="playerAction('bet')" disabled>Bet</button>
                 <button id="raise-button" onclick="playerAction('raise')" disabled>Raise</button>
            </div>
             <button id="next-hand-button" onclick="startNewHand()" style="display: none; margin-top: 15px;">Prossima Mano</button>
        </div>

        <div id="result" aria-live="polite"></div>
    </div>
</div>

<script type="module">
// MODIFIED: Path to js/firebase-logic.js
import { auth, onAuthStateChanged, updateSaldoInFirestore, getSaldoFromFirestore } from "./js/firebase-logic.js";

// --- INIZIO CODICE JAVASCRIPT (Con Correzione Integrata v7 + Firebase Integration) ---

// --- Constants and Global Variables ---
const suits = ['♥', '♦', '♣', '♠'];
const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
const rankMap = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14 };
const invRankMap = { 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'T', 11: 'J', 12: 'Q', 13: 'K', 14: 'A' };
const themeStorageKey = 'pokerTheme';
const balanceStorageKeyP1 = 'pokerBalanceP1'; // Used as fallback or if user not logged in
const balanceStorageKeyP2 = 'pokerBalanceP2';
const smallBlindAmt = 10;
const bigBlindAmt = 20;
const initialBalance = 1000; // Default initial balance if nothing else is found

let deck = [];
let communityCards = [];
let players = [
    { id: 1, name: "Giocatore 1", balance: initialBalance, hand: [], currentBet: 0, status: 'active', isBot: false, isDealer: false, elementPrefix: 'player1', hasActedThisRound: false },
    { id: 2, name: "Giocatore 2", balance: initialBalance, hand: [], currentBet: 0, status: 'active', isBot: false, isDealer: false, elementPrefix: 'player2', hasActedThisRound: false }
];
let pot = 0;
let currentPlayerIndex = 0;
let dealerIndex = 0;
let currentPhase = 'pre-deal';
let currentBetLevel = 0;
let lastRaiserIndex = -1;
let handOver = true;
let gameMode = null;
let actionAmount = 0;
let communityCardAnimationTimeout = null;
let resultTimeoutId = null;
let currentUID = null; // To store the UID of the logged-in user

// --- DOM Elements ---
const gameModeSelectionDiv = document.getElementById('game-mode-selection');
const gameAreaDiv = document.getElementById('game-area');
const themeToggle = document.getElementById('theme-toggle');
const resultElement = document.getElementById('result');
const potAmountSpan = document.getElementById('pot-amount');
const communityCardsContainer = document.getElementById('community-cards');
const gamePhaseSpan = document.getElementById('game-phase');
const turnIndicator = document.getElementById('turn-indicator');
const turnIndicatorSpan = document.getElementById('current-player-turn');
const foldButton = document.getElementById('fold-button');
const checkButton = document.getElementById('check-button');
const callButton = document.getElementById('call-button');
const betButton = document.getElementById('bet-button');
const raiseButton = document.getElementById('raise-button');
const nextHandButton = document.getElementById('next-hand-button');
const callAmountSpan = document.getElementById('call-amount');
const bettingAreaDiv = document.getElementById('betting-area');
const betInputAreaDiv = document.getElementById('bet-input-area');
const betAmountInput = document.getElementById('bet-amount');
const confirmBetButton = document.getElementById('confirm-bet-button');
const clickableChipsContainer = document.getElementById('clickable-chips');
const clearBetButton = document.getElementById('clear-bet-button');
const potBetButton = document.getElementById('pot-bet-button');
const allInButton = document.getElementById('all-in-button');
const actionAmountDisplay = document.getElementById('action-amount-display');
// const userDisplayElement = document.getElementById('user-display'); // Optional: For showing auth status

// --- Firebase Auth State Change Listener ---
onAuthStateChanged(auth, async (user) => {
    if (user) {
        currentUID = user.uid;
        console.log("User signed in:", user.email, "UID:", currentUID);
        // if (userDisplayElement) userDisplayElement.textContent = `Logged in as: ${user.email}`;

        if (gameMode && players[0]) { // If a game mode is already selected and player object exists
            console.log("Auth state changed: User logged in. Refreshing P1 balance for current game mode.");
            try {
                const firestoreBalanceP1 = await getSaldoFromFirestore(currentUID);
                players[0].balance = firestoreBalanceP1; // Firestore is the source of truth
                players[0].balance = Math.max(0, players[0].balance); // Ensure non-negative
                console.log(`P1 balance updated from Firestore: $${players[0].balance}`);
                // Optionally save to localStorage as well if it's part of your strategy for offline/backup
                localStorage.setItem(balanceStorageKeyP1, players[0].balance.toString());
            } catch (error) {
                console.error("Error refreshing P1 balance from Firestore on auth change, falling back to localStorage/initial:", error);
                const savedBalanceP1 = localStorage.getItem(balanceStorageKeyP1);
                players[0].balance = (savedBalanceP1 !== null && !isNaN(parseInt(savedBalanceP1))) ? parseInt(savedBalanceP1) : initialBalance;
                players[0].balance = Math.max(0, players[0].balance);
            }
            updatePlayersUI(); // Refresh UI with new balance
        } else {
            console.log("User logged in. Balance will be loaded from Firestore when a game mode is selected.");
        }
    } else {
        currentUID = null;
        console.log("User signed out.");
        // if (userDisplayElement) userDisplayElement.textContent = 'Not logged in.';

        if (gameMode && players[0]) { // If a game was in progress with a logged-in user
            console.log("Auth state changed: User logged out. Reverting P1 balance to localStorage/initial.");
            const savedBalanceP1 = localStorage.getItem(balanceStorageKeyP1); // Get local fallback
            players[0].balance = (savedBalanceP1 !== null && !isNaN(parseInt(savedBalanceP1))) ? parseInt(savedBalanceP1) : initialBalance;
            players[0].balance = Math.max(0, players[0].balance);
            updatePlayersUI(); // Refresh UI
        }
    }
});

// --- Persistence & Setup ---
async function saveGameState() { // Now async due to Firebase
    try {
        localStorage.setItem(themeStorageKey, document.body.dataset.theme || 'light');
        if (gameMode && players[0] && players[1]) {
            // Player 1 Balance
            if (currentUID && players[0]) { // If user logged in, save P1's balance to Firestore
                try {
                    await updateSaldoInFirestore(currentUID, players[0].balance);
                    console.log(`Saved P1 balance to Firestore for user ${currentUID}: $${players[0].balance}`);
                    localStorage.setItem(balanceStorageKeyP1, players[0].balance.toString()); // Also save to localStorage as backup/for offline
                } catch (error) {
                    console.error("Error saving P1 balance to Firestore, saving to localStorage only:", error);
                    localStorage.setItem(balanceStorageKeyP1, players[0].balance.toString());
                }
            } else if (players[0]) { // No user logged in, save P1's balance to localStorage
                localStorage.setItem(balanceStorageKeyP1, players[0].balance.toString());
            }

            // Player 2's balance always saved to localStorage
            if (players[1]) {
                localStorage.setItem(balanceStorageKeyP2, players[1].balance.toString());
            }
        }
    } catch (e) {
        console.error("Error in saveGameState:", e);
    }
}

function loadGameState() { // Primarily for theme, balance loading is in selectGameMode
    try {
        const savedTheme = localStorage.getItem(themeStorageKey) || 'light';
        document.body.dataset.theme = savedTheme;
        if (themeToggle) {
            themeToggle.checked = (savedTheme === 'dark');
        }
    } catch (e) {
        console.error("Error in loadGameState (theme):", e);
    }
}

function createCard(suit, rank) { return { suit, rank, id: rank + suit, faceUp: false }; }
function createDeck() { deck = []; for (const suit of suits) { for (const rank of ranks) { deck.push(createCard(suit, rank)); } } }
function shuffleDeck() { for (let i = deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck[i], deck[j]] = [deck[j], deck[i]]; } }
function dealCard(targetHand = null, makeVisible = false) { if (deck.length === 0) { console.error("Mazzo finito!"); return null; } const card = deck.pop(); card.faceUp = makeVisible; if (targetHand) { targetHand.push(card); } return card; }

// --- displayCard (Gestisce la creazione e l'animazione iniziale della carta nel DOM) ---
function displayCard(card, container, hidden = false, isNew = false) {
    const cardElement = document.createElement('div');
    cardElement.classList.add('card');
    cardElement.dataset.cardId = card.id;

    cardElement.classList.add(hidden ? 'hidden' : 'flipped');
    if (isNew) {
        cardElement.classList.add('entering');
    }

    const cardInner = document.createElement('div');
    cardInner.classList.add('card-inner');
    const cardFront = document.createElement('div');
    cardFront.classList.add('card-face', 'card-front');
    const rankSpan = document.createElement('span');
    rankSpan.textContent = (card.rank === 'T') ? '10' : card.rank;
    const suitSpan = document.createElement('span');
    suitSpan.classList.add('suit');
    suitSpan.textContent = card.suit;
    if (['♥', '♦'].includes(card.suit)) cardFront.classList.add('red'); else cardFront.classList.add('black');
    cardFront.appendChild(rankSpan); cardFront.appendChild(suitSpan);
    const cardBack = document.createElement('div');
    cardBack.classList.add('card-face', 'card-back');
    cardInner.appendChild(cardFront); cardInner.appendChild(cardBack);
    cardElement.appendChild(cardInner);

    container.appendChild(cardElement);

    if (isNew) {
        void cardElement.offsetWidth;
        setTimeout(() => {
            if(document.contains(cardElement)) {
                cardElement.classList.remove('entering');
                if (!hidden) {
                    cardElement.classList.remove('hidden');
                    cardElement.classList.add('flipped');
                }
            }
        }, 50);
    }
}


// --- Game Flow & Setup ---
async function selectGameMode(mode) { // Now async due to Firebase
    console.log(`DEBUG: selectGameMode chiamata con mode = ${mode}`);
    console.log(`Selezionata modalità: ${mode}`);
    if(resultElement) resultElement.classList.remove('result-show', 'result-win', 'result-lose', 'result-push');
    clearTimeout(resultTimeoutId);

    players.forEach(p => { p.hand = []; p.currentBet = 0; p.status = 'active'; p.hasActedThisRound = false; p.isDealer = false; });
    communityCards = []; pot = 0; currentPhase = 'pre-deal'; handOver = true; currentPlayerIndex = 0; lastRaiserIndex = -1; actionAmount = 0;

    gameMode = mode;
    players[1].isBot = (mode === 'PVB');
    players[1].name = (mode === 'PVB') ? "Bot" : "Giocatore 2";

    // Balance Loading Logic
    if (currentUID && players[0]) { // User is logged in, try to load P1 balance from Firestore
        try {
            const firestoreBalanceP1 = await getSaldoFromFirestore(currentUID);
            players[0].balance = firestoreBalanceP1; // Firestore is source of truth
            console.log(`Logged in user ${currentUID}. Loaded P1 balance from Firestore: $${players[0].balance}`);
        } catch (error) {
            console.error("Error loading P1 balance from Firestore in selectGameMode, falling back to localStorage/initial:", error);
            const savedBalanceP1 = localStorage.getItem(balanceStorageKeyP1);
            players[0].balance = (savedBalanceP1 !== null && !isNaN(parseInt(savedBalanceP1))) ? parseInt(savedBalanceP1) : initialBalance;
        }
    } else if (players[0]) { // No user logged in, use localStorage or initialBalance for Player 1
        const savedBalanceP1 = localStorage.getItem(balanceStorageKeyP1);
        players[0].balance = (savedBalanceP1 !== null && !isNaN(parseInt(savedBalanceP1))) ? parseInt(savedBalanceP1) : initialBalance;
        console.log("No user logged in. Loaded P1 balance from localStorage/initial.");
    }

    // Player 2 always uses localStorage or initialBalance
    if (players[1]) {
        const savedBalanceP2 = localStorage.getItem(balanceStorageKeyP2);
        players[1].balance = (savedBalanceP2 !== null && !isNaN(parseInt(savedBalanceP2))) ? parseInt(savedBalanceP2) : initialBalance;
    }

    if (players[0]) players[0].balance = Math.max(0, players[0].balance); // Ensure non-negative
    if (players[1]) players[1].balance = Math.max(0, players[1].balance);

    console.log(`Balances after loading: P1=$${players[0]?.balance}, P2=$${players[1]?.balance}`);

    const gameModeDisplayEl = document.getElementById('game-mode-display');
    if (gameModeDisplayEl) { gameModeDisplayEl.textContent = mode; }
    else { console.error("ERRORE: Elemento #game-mode-display non trovato!"); return; }

    const player2NameEl = document.getElementById('player2-name');
    if (player2NameEl) { player2NameEl.textContent = players[1].name; }
    else { console.error("ERRORE: Elemento #player2-name non trovato!"); return; }

    if (gameModeSelectionDiv) { gameModeSelectionDiv.style.display = 'none'; }
    else { console.error("ERRORE CRITICO: gameModeSelectionDiv è null!"); return; }
    if (gameAreaDiv) { gameAreaDiv.style.display = 'block'; }
    else { console.error("ERRORE CRITICO: gameAreaDiv è null!"); return; }

    if(nextHandButton) { nextHandButton.style.display = 'none'; nextHandButton.disabled = true; }

    const existingStartButton = document.querySelector('button[data-start-button="true"]');
    if (existingStartButton) existingStartButton.remove();

    resetTableVisuals();
    updatePlayersUI();

    if(players[0].balance > 0 && players[1].balance > 0) {
        const startFirstHandButton = document.createElement('button');
        startFirstHandButton.textContent = "Inizia Partita";
        startFirstHandButton.dataset.startButton = "true";
        startFirstHandButton.onclick = () => { startNewHand(); startFirstHandButton.remove(); };
        startFirstHandButton.style.marginTop = '15px';
        const buttonsDiv = document.getElementById('buttons');
        if (buttonsDiv && buttonsDiv.parentNode) {
            buttonsDiv.parentNode.insertBefore(startFirstHandButton, buttonsDiv.nextSibling);
        } else { console.error("ERRORE: #buttons non trovato per startFirstHandButton!"); }
    } else {
        const loserName = players[0].balance <= 0 ? players[0].name : players[1].name;
        const winnerName = players[0].balance > 0 ? players[0].name : players[1].name;
        showResult(`${loserName} è senza soldi! ${winnerName} vince.\nClicca 'Nuova Partita' per resettare.`, 'win');
        if(nextHandButton) {
            nextHandButton.textContent = "Nuova Partita";
            nextHandButton.style.display = 'inline-block';
            nextHandButton.disabled = false;
            nextHandButton.onclick = async () => { // Make async for saveGameState
                console.log("Reset saldi e inizio nuova partita...");
                // For logged-out users or P2, reset localStorage
                localStorage.removeItem(balanceStorageKeyP1); // P1 might get overwritten by Firestore if logged in
                localStorage.removeItem(balanceStorageKeyP2);

                players[0].balance = initialBalance;
                players[1].balance = initialBalance;

                // If user is logged in, new initial balance should also be reflected in Firestore
                if (currentUID && players[0]) {
                    try {
                        await updateSaldoInFirestore(currentUID, initialBalance);
                        console.log(`P1 initial balance ($${initialBalance}) saved to Firestore for reset.`);
                    } catch (error) {
                        console.error("Error saving initial balance to Firestore during reset:", error);
                    }
                }
                await saveGameState(); // Save the reset state (will handle localStorage and Firestore)
                nextHandButton.textContent = "Prossima Mano";
                nextHandButton.onclick = startNewHand;
                await selectGameMode(gameMode); // Re-select to reload balances correctly
            };
        }
    }

    disableActionButtons();
    if(bettingAreaDiv) bettingAreaDiv.style.display = 'none';
    await saveGameState(); // Save initial game state (balances)
}

async function quitGame() { // Now async
    console.log("Uscita dalla partita...");
    await saveGameState(); // Save before quitting
    gameMode = null; handOver = true;
    clearTimeout(resultTimeoutId);
    clearTimeout(communityCardAnimationTimeout);

    console.log("Pulizia dati partita...");
    players.forEach(p => { p.hand = []; p.currentBet = 0; p.status = 'active'; });
    communityCards = []; pot = 0; currentPhase = 'pre-deal'; currentPlayerIndex = 0; actionAmount = 0;

    resetTableVisuals();

    if(resultElement) resultElement.classList.remove('result-show', 'result-win', 'result-lose', 'result-push');
    if (gameAreaDiv) gameAreaDiv.style.display = 'none';
    if (gameModeSelectionDiv) gameModeSelectionDiv.style.display = 'block';
    if (nextHandButton) nextHandButton.style.display = 'none';

    const existingStartButton = document.querySelector('button[data-start-button="true"]');
    if (existingStartButton) existingStartButton.remove();

    console.log("Partita terminata e UI resettata.");
}

function resetTableVisuals() {
     console.log("Resetting table visuals...");
     if (communityCardsContainer) communityCardsContainer.innerHTML = ''; else console.error("Elemento community-cards non trovato");
     const p1Cards = document.getElementById('player1-cards');
     const p2Cards = document.getElementById('player2-cards');
     if (p1Cards) p1Cards.innerHTML = ''; else console.error("Elemento player1-cards non trovato");
     if (p2Cards) p2Cards.innerHTML = ''; else console.error("Elemento player2-cards non trovato");
     if (potAmountSpan) potAmountSpan.textContent = '0'; else console.error("Elemento pot-amount non trovato");
     if (gamePhaseSpan) gamePhaseSpan.textContent = '-'; else console.error("Elemento game-phase non trovato");
     if (turnIndicatorSpan) turnIndicatorSpan.textContent = '-'; else console.error("Elemento current-player-turn non trovato");
     if (turnIndicator) {
         turnIndicator.classList.remove('player2-turn');
         if (turnIndicator.firstChild) turnIndicator.firstChild.textContent = 'Turno di: ';
     } else { console.error("Elemento turn-indicator non trovato"); }

     players.forEach(p => {
         const prefix = p.elementPrefix;
         const betEl = document.getElementById(`${prefix}-bet`);
         const statusEl = document.getElementById(`${prefix}-status`);
         const dealerButtonEl = document.getElementById(`dealer-button-p${p.id}`);
         if (statusEl) statusEl.textContent = '-'; else console.warn(`Elemento ${prefix}-status non trovato`);
         if (betEl) betEl.textContent = '0'; else console.warn(`Elemento ${prefix}-bet non trovato`);
         if (dealerButtonEl) dealerButtonEl.style.display = 'none'; else console.warn(`Elemento dealer-button-p${p.id} non trovato`);
     });

     if (resultElement) resultElement.classList.remove('result-show', 'result-win', 'result-lose', 'result-push'); else console.error("Elemento result non trovato");
     if (betInputAreaDiv) betInputAreaDiv.style.display = 'none'; else console.error("Elemento bet-input-area non trovato");
     if (bettingAreaDiv) bettingAreaDiv.style.display = 'none'; else console.error("Elemento betting-area non trovato");
     const buttonsDiv = document.getElementById('buttons');
     if (buttonsDiv) buttonsDiv.style.display = 'flex'; else console.error("Elemento buttons non trovato");
     clearActionAmount();
     console.log("Table visuals reset complete.");
 }

async function startNewHand() { // Now async
    console.log("--- startNewHand ---");
    clearTimeout(resultTimeoutId);
    clearTimeout(communityCardAnimationTimeout);

    // Ensure balances are loaded/up-to-date, especially if startNewHand can be called independently
    // This might be redundant if selectGameMode always precedes, but good for robustness.
    if (currentUID && players[0]) {
        try {
            const firestoreBalanceP1 = await getSaldoFromFirestore(currentUID);
            players[0].balance = firestoreBalanceP1;
            players[0].balance = Math.max(0, players[0].balance);
        } catch (error) { /* Use existing players[0].balance if Firestore fetch fails */
             console.warn("startNewHand: Could not refresh P1 balance from Firestore", error);
        }
    }
    // P2 balance is managed by localStorage or session
    if (players[1]) {
        const savedBalanceP2 = localStorage.getItem(balanceStorageKeyP2);
         if (savedBalanceP2 !== null && !isNaN(parseInt(savedBalanceP2))) {
            players[1].balance = parseInt(savedBalanceP2);
            players[1].balance = Math.max(0, players[1].balance);
        } // else it keeps its current balance or initial if first hand.
    }


    if (players[0].balance <= 0 || players[1].balance <= 0) {
        const winnerName = players[0].balance > 0 ? players[0].name : players[1].name;
        const loserName = players[0].balance <= 0 ? players[0].name : players[1].name;
        showResult(`${loserName} è senza soldi! ${winnerName} vince!\nClicca 'Nuova Partita' per ricominciare.`, 'win');
        if(nextHandButton) {
            nextHandButton.textContent = "Nuova Partita";
            nextHandButton.style.display = 'inline-block';
            nextHandButton.disabled = false;
            nextHandButton.onclick = async () => { // Make async
                console.log("Reset saldi e inizio nuova partita...");
                localStorage.removeItem(balanceStorageKeyP1);
                localStorage.removeItem(balanceStorageKeyP2);
                players[0].balance = initialBalance;
                players[1].balance = initialBalance;

                if (currentUID && players[0]) { // Also update Firestore for P1
                    try {
                        await updateSaldoInFirestore(currentUID, initialBalance);
                         console.log(`P1 initial balance ($${initialBalance}) saved to Firestore for reset.`);
                    } catch (error) {
                        console.error("Error saving initial balance to Firestore during reset:", error);
                    }
                }
                await saveGameState(); // Save the reset state
                nextHandButton.textContent = "Prossima Mano";
                nextHandButton.onclick = startNewHand; // This should re-trigger async startNewHand
                await selectGameMode(gameMode); // Reload game mode to ensure proper setup
            };
        }
        handOver = true;
        return;
    }

    handOver = false;
    if(resultElement) resultElement.classList.remove('result-show', 'result-win', 'result-lose', 'result-push');
    if(nextHandButton) { nextHandButton.style.display = 'none'; nextHandButton.disabled = true; }

    players.forEach(p => {
        p.hand = [];
        p.currentBet = 0;
        p.status = p.balance > 0 ? 'active' : 'out';
        p.hasActedThisRound = false;
        p.evaluatedHand = null;
    });

    if (players.filter(p => p.status === 'active').length < 2) {
        console.error("Meno di due giocatori attivi all'inizio della mano.");
        handOver = true;
        await quitGame(); return;
    }

    communityCards = []; pot = 0; currentBetLevel = 0; actionAmount = 0;

    dealerIndex = (dealerIndex + 1) % players.length;
    players.forEach((p, index) => p.isDealer = (index === dealerIndex));
    let sbIndex = dealerIndex;
    let bbIndex = (dealerIndex + 1) % players.length;

    currentPlayerIndex = sbIndex; // Preflop, SB (dealer in 1v1) acts first
    if (players.length === 2 && currentPhase === 'preflop') { // Specific for 2 players heads-up
        // Dealer is SB and acts first. BB is second.
        // Post-flop, player to the left of dealer (BB) acts first.
        // This is handled by firstToActIndex in progressToNextPhase for post-flop.
    }


    lastRaiserIndex = bbIndex; // BB is effectively the last "raiser" due to blind

    createDeck(); shuffleDeck();

    function postBlind(playerIndex, amount) {
        const player = players[playerIndex];
        if (!player || player.status !== 'active') return 0;
        const blindAmount = Math.min(amount, player.balance);
        player.balance -= blindAmount;
        player.currentBet = blindAmount;
        pot += blindAmount;
        if (player.balance === 0) { player.status = 'all-in'; console.log(`${player.name} posta blind $${blindAmount} ALL-IN!`); }
        else { console.log(`${player.name} posta blind $${blindAmount}`); }
        return blindAmount;
    }

    const actualSB = postBlind(sbIndex, smallBlindAmt);
    const actualBB = postBlind(bbIndex, bigBlindAmt);
    currentBetLevel = Math.max(actualBB, bigBlindAmt); // Current bet to match is the big blind

    players.forEach(p => {
        if (p.status === 'active' || p.status === 'all-in') { // Only deal to players not 'out'
            dealCard(p.hand, false); dealCard(p.hand, false);
        }
    });

    currentPhase = 'preflop';
    resetTableVisuals(); updatePlayersUI(); updateCommunityAreaUI(); updateUI();

    console.log(`Dealer: ${players[dealerIndex].name}. SB: ${players[sbIndex].name}, BB: ${players[bbIndex].name}. Turno iniziale di: ${players[currentPlayerIndex].name} (Index: ${currentPlayerIndex})`);

    const startingPlayer = players[currentPlayerIndex];
    // If starting player went all-in posting blind, or only opponent is all-in
    if (startingPlayer.status !== 'active') {
        console.log(`Giocatore iniziale ${startingPlayer.name} non attivo (status: ${startingPlayer.status}). Giro potrebbe avanzare o terminare.`);
         const otherPlayer = players[(currentPlayerIndex + 1) % players.length];
         if (otherPlayer.status === 'all-in' && startingPlayer.status === 'all-in') {
             console.log("Entrambi i giocatori all-in dopo i blinds. Si avanza subito alle carte comuni.");
             // No betting round, proceed to deal all community cards then showdown
             setTimeout(() => progressToNextPhase(), 800); // progress will handle all-in reveals
         } else if (startingPlayer.status === 'all-in' && otherPlayer.status === 'active') {
             console.log(`${startingPlayer.name} all-in con blind. Turno a ${otherPlayer.name}.`);
             // endTurn will eventually pass to otherPlayer if not already their turn via updateUI
         } else if (otherPlayer.status === 'all-in' && startingPlayer.status === 'active') {
             console.log(`${otherPlayer.name} all-in con blind. Turno a ${startingPlayer.name}.`);
         }
         // UpdateUI will be called, and if current player is bot it will act, or enable human buttons.
         // If current player is all-in, endTurn logic will handle it.
    }
    await saveGameState();
}

// --- Azioni Giocatore Umano ---
function playerAction(action) {
    const player = players[currentPlayerIndex];
    // Ensure it's a human player's turn
    if (handOver || !player || player.status !== 'active' || (gameMode === 'PVB' && player.isBot)) {
        console.warn(`playerAction (${action}) bloccata: handOver=${handOver}, playerID=${player?.id}, isBot=${player?.isBot}, status=${player?.status}, gameMode=${gameMode}`);
        return;
    }
     // PVP specific check: ensure correct human player is acting (not strictly necessary if UI is well-managed)
     // if (gameMode === 'PVP' && player.id !== (currentPlayerIndex + 1) ) { console.warn("PVP wrong player"); return; }


    console.log(`Azione UMANA: ${player.name} (${currentPlayerIndex}) sceglie ${action}`);

    // Set hasActedThisRound. For bet/raise, it's set in submitBetRaise upon successful validation.
    if (action === 'fold' || action === 'check' || action === 'call') {
         player.hasActedThisRound = true;
         cancelBetRaiseInput(); // Close input area if open
    } else {
        // For 'bet' or 'raise', hasActedThisRound is set in submitBetRaise after validation
        player.hasActedThisRound = false;
    }


    switch (action) {
        case 'fold':
            player.status = 'folded'; endTurn(); break;
        case 'check':
            if (player.currentBet < currentBetLevel) {
                 alert(`Non puoi Check, devi Call $${currentBetLevel - player.currentBet} o Raise.`);
                 player.hasActedThisRound = false; // Reset because action was invalid
                 return;
            }
            console.log(`${player.name} fa Check`); endTurn(); break;
        case 'call':
            const amountToCall = Math.min(currentBetLevel - player.currentBet, player.balance);
            if (amountToCall <= 0) { // This implies currentBet >= currentBetLevel
                 if (player.currentBet >= currentBetLevel) { // Effectively a check if bets are already matched
                    console.log(`${player.name} fa Check (Call $0)`); endTurn();
                 } else { // Should not happen if logic is right: amountToCall is 0 but currentBet < currentBetLevel
                    console.warn(`Call $0 ma currentBet (${player.currentBet}) < currentBetLevel (${currentBetLevel})? Controllare logica. `);
                    player.hasActedThisRound = false; // Reset as action might be invalid or misinterpreted
                 }
                return;
            }
            player.balance -= amountToCall; player.currentBet += amountToCall; pot += amountToCall;
            console.log(`${player.name} chiama $${amountToCall}`);
            if (player.balance === 0) { player.status = 'all-in'; console.log(`${player.name} è All-in!`); }
            endTurn(); break;
        case 'bet':
            if(currentBetLevel > 0) {
                alert("C'è già una puntata. Usa 'Raise' o 'Call'.");
                player.hasActedThisRound = false; return;
            }
            showBetRaiseInput('bet'); break;
        case 'raise':
             if(currentBetLevel === 0) {
                 alert("Non ci sono puntate da rilanciare. Usa 'Bet'.");
                 player.hasActedThisRound = false; return;
             }
            showBetRaiseInput('raise'); break;
        default:
            console.error("Azione non riconosciuta:", action); player.hasActedThisRound = false;
    }
 }

// --- Gestione Input Bet/Raise ---
function showBetRaiseInput(actionType) {
    const player = players[currentPlayerIndex];
    if (!player || player.status !== 'active') { console.warn("Giocatore non valido o non attivo per bet/raise."); return; }
    if (player.balance <= 0 && actionType !== 'allin_implicit') { // Allow showing input if only all-in is possible
         // (allin_implicit is not a real type, just for thought process)
        alert("Non hai saldo per puntare o rilanciare."); return;
    }


    const minBetRaiseTotal = calculateMinBetRaise(); // Min total amount player's bet needs to be
    const maxBetRaiseTotal = player.balance + player.currentBet; // All-in

    // If the only valid action is to go all-in (min raise/bet IS all-in)
    if (minBetRaiseTotal >= maxBetRaiseTotal && player.balance > 0) {
        console.log("L'unica opzione valida è andare All-in. Procedo con All-in.");
        setBetAmount('allin'); // This sets actionAmount
        submitBetRaise(); // This will use actionAmount
        return;
    }
    // If player has 0 balance, they cannot initiate a bet/raise.
    // (This check is partly covered above, but more specific here)
    if (player.balance === 0 && (actionType === 'bet' || actionType === 'raise')) {
        alert("Non hai saldo per puntare o rilanciare.");
        return;
    }


    clearActionAmount(); // Reset actionAmount and input field
    betAmountInput.min = minBetRaiseTotal;
    betAmountInput.max = maxBetRaiseTotal;
    betAmountInput.placeholder = minBetRaiseTotal; // Suggest min valid total amount
    betAmountInput.value = ''; // Clear previous manual input

    confirmBetButton.textContent = actionType === 'bet' ? 'Punta' : 'Rilancia';
    confirmBetButton.dataset.actionType = actionType; // Store action type for submitBetRaise

    if(document.getElementById('buttons')) document.getElementById('buttons').style.display = 'none';
    if(bettingAreaDiv) bettingAreaDiv.style.display = 'flex';
    if(betInputAreaDiv) betInputAreaDiv.style.display = 'flex'; // Ensure this is visible

    updateActionAmountButtons(); // Update state of chip buttons, confirm button etc.
}
function cancelBetRaiseInput() {
    if(betInputAreaDiv) betInputAreaDiv.style.display = 'none';
    if(bettingAreaDiv) bettingAreaDiv.style.display = 'none';
    if(document.getElementById('buttons')) document.getElementById('buttons').style.display = 'flex';
    clearActionAmount();
    updateActionButtons(); // Re-enable/show base action buttons
}
function submitBetRaise() {
    const player = players[currentPlayerIndex];
    if (!player) return;

    let totalBetAmountFromInput = parseInt(betAmountInput.value);
    let totalBetAmountToUse;

    if (!isNaN(totalBetAmountFromInput) && totalBetAmountFromInput > 0) {
        totalBetAmountToUse = totalBetAmountFromInput;
        console.log("Usando valore da input manuale:", totalBetAmountToUse);
    } else if (actionAmount > 0) {
        totalBetAmountToUse = actionAmount; // Use amount from chip clicks if input is invalid/empty
        console.log("Usando valore da fiches:", totalBetAmountToUse);
    } else {
        alert("Inserisci un importo valido o usa le fiches."); return;
    }


    const actionType = confirmBetButton.dataset.actionType; // 'bet' or 'raise'
    const minValidTotalAmount = calculateMinBetRaise(); // Min total this bet/raise must be
    const maxValidTotalAmount = player.balance + player.currentBet; // Player's all-in amount

    console.log(`SubmitBetRaise: Tentativo=${totalBetAmountToUse}, ActionType=${actionType}, MinTotal=${minValidTotalAmount}, MaxTotal=${maxValidTotalAmount}, CurrentBetLevel=${currentBetLevel}`);


    if (isNaN(totalBetAmountToUse) || totalBetAmountToUse <= 0) {
        alert("L'importo deve essere un numero positivo."); return;
    }
    if (totalBetAmountToUse > maxValidTotalAmount) {
        alert(`Non puoi puntare più di quanto hai! Max: $${maxValidTotalAmount}`); return;
    }
    if (totalBetAmountToUse < minValidTotalAmount && totalBetAmountToUse < maxValidTotalAmount) {
         // Allow all-in for less than minValidTotalAmount if that's all they have
        alert(`Importo troppo basso. Minimo: $${minValidTotalAmount} (o all-in per $${maxValidTotalAmount}).`); return;
    }


    if (actionType === 'bet') {
        if (currentBetLevel > 0) { alert("Errore: Azione 'bet' non permessa se c'è già una puntata."); return; }
        // For a 'bet', totalBetAmountToUse is the new currentBetLevel
    } else if (actionType === 'raise') {
        if (currentBetLevel === 0) { alert("Errore: Azione 'raise' non permessa se non ci sono puntate da rilanciare."); return; }
        if (totalBetAmountToUse <= currentBetLevel) {
            alert(`Per rilanciare, l'importo totale ($${totalBetAmountToUse}) deve superare la puntata attuale ($${currentBetLevel}). Minimo rilancio totale: $${minValidTotalAmount}.`); return;
        }
        // For a 'raise', totalBetAmountToUse is the new currentBetLevel
    }


    const amountToAdd = totalBetAmountToUse - player.currentBet;
    if (amountToAdd < 0) { console.error("Errore critico: amountToAdd negativo.", {totalBetAmountToUse, currentBet: player.currentBet}); return; }

    // If player is essentially calling with the bet/raise interface
    if (amountToAdd === 0 && totalBetAmountToUse === currentBetLevel && currentBetLevel > 0) {
        alert("L'importo inserito corrisponde al Call. Per favore, usa il bottone 'Call'.");
        return;
    }


    player.balance -= amountToAdd;
    player.currentBet = totalBetAmountToUse; // This is the total amount player has in front of them for this round
    pot += amountToAdd;
    currentBetLevel = player.currentBet; // The new level to be matched
    lastRaiserIndex = currentPlayerIndex; // This player made the last aggressive action
    player.hasActedThisRound = true; // Action successfully submitted

     if (player.balance === 0) { player.status = 'all-in'; console.log(`${player.name} è All-in!`); }
     console.log(`${player.name} ${actionType} a $${player.currentBet} (aggiungendo $${amountToAdd}). Nuovo CurrentBetLevel: $${currentBetLevel}`);

     cancelBetRaiseInput(); // Close input area, reset amounts
     endTurn();
 }

// --- Gestione Fiches e Bottoni Area Betting ---
document.addEventListener('DOMContentLoaded', () => {
    const chipButtons = document.querySelectorAll('#clickable-chips .chip-button');
    chipButtons.forEach(button => {
        button.addEventListener('click', () => { if (!button.disabled) addChipValueToAction(button.dataset.value); });
    });

    // Add listener for the cancel button in bet input area
    const cancelBetBtn = document.getElementById('cancel-bet-button');
    if (cancelBetBtn) {
        cancelBetBtn.addEventListener('click', cancelBetRaiseInput);
    } else {
        console.warn("Cancel bet button not found for event listener setup.");
    }
});
function addChipValueToAction(value) {
    const player = players[currentPlayerIndex];
    if(!player || player.status !== 'active') return;
    const numericValue = parseInt(value);
    if (isNaN(numericValue)) return;

    let currentInputValue = parseInt(betAmountInput.value);
    let baseAmount = 0;
    if (!isNaN(currentInputValue) && currentInputValue > 0) { // If input field has a value, add to it
        baseAmount = currentInputValue;
    } else { // Else, add to current chip total (actionAmount)
        baseAmount = actionAmount;
    }

    let newAmount = baseAmount + numericValue;
    const maxBetRaiseTotal = player.balance + player.currentBet;
    if (newAmount > maxBetRaiseTotal) newAmount = maxBetRaiseTotal;

    actionAmount = newAmount; // Update internal chip total for reference
    if(betAmountInput) betAmountInput.value = actionAmount; // Update input field with new total
    updateActionAmountButtons();
}
function clearActionAmount() {
    actionAmount = 0;
    if(betAmountInput) betAmountInput.value = ''; // Clear input field as well
    updateActionAmountButtons();
}
function setBetAmount(type) {
    const player = players[currentPlayerIndex];
    if (!player || player.status !== 'active') return;

    const minBetRaiseTotal = calculateMinBetRaise(); // Min total amount player's bet needs to be
    let targetAmount = minBetRaiseTotal; // Default to min
    const maxBetRaiseTotal = player.balance + player.currentBet; // All-in

    switch (type) {
        case 'pot':
            const amountNeededToCall = Math.max(0, currentBetLevel - player.currentBet);
            // Pot size for raise calculation: current pot + all bets on table (including your call)
            // Pot size = current pot + (currentBetLevel - p1.currentBet) + (currentBetLevel - p2.currentBet IF p2 also has bet out)
            // Simplified for 2 players: pot + amountNeededToCall (from current player) + currentBetLevel (opponent's part of current level)
            // No, more standard: A pot-sized raise is your call PLUS the amount of the pot after your call.
            // 1. Amount to call: `amountNeededToCall`
            // 2. Size of pot after you call: `pot + amountNeededToCall`
            // 3. Your raise amount (on top of call): `pot + amountNeededToCall`
            // 4. Total bet: `player.currentBet + amountNeededToCall + (pot + amountNeededToCall)`
            // This simplifies to: `player.currentBet + pot + 2 * amountNeededToCall`.
            // Or, if `currentBetLevel` is 0 (first to bet): `player.currentBet (0) + pot + 0` => so bet `pot`.
            targetAmount = player.currentBet + amountNeededToCall + (pot + amountNeededToCall);
            break;
        case 'allin':
            targetAmount = maxBetRaiseTotal;
            break;
    }
    // Ensure target amount is within valid min/max bounds
    targetAmount = Math.max(minBetRaiseTotal, Math.min(targetAmount, maxBetRaiseTotal));
    actionAmount = Math.floor(targetAmount);
    if(betAmountInput) betAmountInput.value = actionAmount; // Update input field
    console.log(`SetBetAmount (${type}): actionAmount = ${actionAmount}`);
    updateActionAmountButtons();
}
function updateActionAmountButtons() {
    if(!actionAmountDisplay || !bettingAreaDiv || !clickableChipsContainer || !clearBetButton || !potBetButton || !allInButton || !confirmBetButton || !betAmountInput) { console.warn("Elementi area betting non trovati per updateActionAmountButtons"); return; }

    // Get value from input field if it's a valid number, otherwise use actionAmount (from chips)
    let currentInputFieldValue = parseInt(betAmountInput.value);
    let displayedAmount = (!isNaN(currentInputFieldValue) && currentInputFieldValue > 0) ? currentInputFieldValue : actionAmount;
    actionAmountDisplay.textContent = `Importo Azione: $${displayedAmount}`;


    const bettingVisible = bettingAreaDiv.style.display === 'flex';
    const player = players[currentPlayerIndex];

    if (!bettingVisible || !player || player.status !== 'active') {
        clickableChipsContainer.querySelectorAll('.chip-button').forEach(b => b.disabled = true);
        clearBetButton.disabled = true; potBetButton.disabled = true; allInButton.disabled = true; confirmBetButton.disabled = true; betAmountInput.disabled = true;
        return;
    }

    const minValidTotalBet = calculateMinBetRaise();
    const maxPossibleTotalBet = player.balance + player.currentBet; // All-in

    // Enable/disable chip buttons
    clickableChipsContainer.querySelectorAll('.chip-button').forEach(b => {
        const chipVal = parseInt(b.dataset.value);
        // Disable if adding this chip to current input/actionAmount would exceed all-in
        b.disabled = (displayedAmount + chipVal > maxPossibleTotalBet && displayedAmount < maxPossibleTotalBet);
    });

    clearBetButton.disabled = (displayedAmount === 0);
    allInButton.disabled = (displayedAmount === maxPossibleTotalBet || player.balance === 0);


    const amountToCallForPotCalc = Math.max(0, currentBetLevel - player.currentBet);
    const potRaiseTarget = player.currentBet + amountToCallForPotCalc + (pot + amountToCallForPotCalc);
    const potBetIsInvalid = potRaiseTarget < minValidTotalBet || potRaiseTarget > maxPossibleTotalBet || player.balance === 0;
    const potBetIsRedundant = displayedAmount >= potRaiseTarget && potRaiseTarget > 0;
    potBetButton.disabled = potBetIsInvalid || potBetIsRedundant;


    betAmountInput.disabled = false;
    betAmountInput.min = minValidTotalBet; // These are for validation, not for disabling
    betAmountInput.max = maxPossibleTotalBet;
    betAmountInput.placeholder = minValidTotalBet;


    let finalAmountForValidation = displayedAmount; // Use combined value from input/chips

    let isValidRaise = (confirmBetButton.dataset.actionType === 'raise' && finalAmountForValidation > currentBetLevel);
    let isValidBet = (confirmBetButton.dataset.actionType === 'bet' && currentBetLevel === 0 && finalAmountForValidation >= minValidTotalBet);

    // Confirm button is enabled if:
    // 1. The final amount is at least the minimum valid bet/raise total
    // 2. The final amount is not more than what the player can go all-in for
    // 3. It's a valid 'bet' action OR a valid 'raise' action
    confirmBetButton.disabled = !(
        finalAmountForValidation >= minValidTotalBet &&
        finalAmountForValidation <= maxPossibleTotalBet &&
        (isValidBet || isValidRaise)
    );
 }

// --- Turn Management & Phase Progression ---
async function endTurn() { // now async
    console.log(`--- endTurn: Inizio per ${players[currentPlayerIndex]?.name} (${currentPlayerIndex}), Azione completata? ${players[currentPlayerIndex]?.hasActedThisRound}, CurrentBet: ${players[currentPlayerIndex]?.currentBet}, BetLevel: ${currentBetLevel} ---`);
    updatePlayersUI(); updateCommunityAreaUI();
    await saveGameState();

    const nonFoldedPlayers = players.filter(p => p.status !== 'folded');
    if (nonFoldedPlayers.length <= 1 && currentPhase !== 'pre-deal' && currentPhase !== 'showdown' && currentPhase !== 'hand-over') { // Allow showdown to proceed if already in that phase
        console.log(">> endTurn: Mano finita - Fold/Eliminazione. Chiamo endHand.");
        setTimeout(() => endHand(false), 600); // false for no showdown (winner by default)
        return;
    }

    let bettingRoundOver = false;
    const pAll = players.filter(p => p.status === 'active' || p.status === 'all-in'); // Players still in the hand

    if (pAll.length < 2 && nonFoldedPlayers.length > 1) { // e.g. P1 active, P2 all-in. P1 bets, P2 can't act.
         bettingRoundOver = true; // Or if P1 checks, round also over.
         console.log(">> endTurn: Meno di due giocatori possono agire attivamente. Giro finito.");
    } else if (pAll.every(p => p.status === 'all-in') && pAll.length > 1) {
        bettingRoundOver = true;
        console.log(">> endTurn: Tutti i giocatori rimanenti sono all-in. Giro finito.");
    } else {
        const activePlayers = players.filter(p => p.status === 'active');
        if (activePlayers.length === 0 && nonFoldedPlayers.length > 1) { // All non-folded are all-in
             bettingRoundOver = true; console.log(">> endTurn: Nessun giocatore attivo, tutti i non-foldati sono all-in. Giro finito.");
        } else if (activePlayers.length === 1) { // One player active, other(s) all-in or folded
            const singleActivePlayer = activePlayers[0];
            // If this single active player has acted OR if their current bet matches the level (e.g. they called an all-in)
            if (singleActivePlayer.hasActedThisRound || singleActivePlayer.currentBet === currentBetLevel) {
                bettingRoundOver = true;
                console.log(`>> endTurn: Solo ${singleActivePlayer.name} attivo e ha agito o pareggiato. Giro finito.`);
            } else {
                 console.log(`>> endTurn: Solo ${singleActivePlayer.name} attivo, ma deve ancora agire. Turno rimane su di lui/lei.`);
                 // currentPlayerIndex should already be this player. updateUI will handle.
            }
        } else if (activePlayers.length >= 2) { // Both players are active (standard betting)
            // Round is over if all active players have acted AND their current bets are equal.
            // Or if (simplified for 2 players): current player acted, and bets are equal.
            const p1 = players[0]; const p2 = players[1]; // Assuming always 2 players for this part of logic
            const betsEqual = p1.currentBet === p2.currentBet;

            // In heads-up preflop, BB (player who posted BB) can still act if SB (player who posted SB) just calls.
            // currentPlayerIndex is the player who just acted.
            const justActedPlayer = players[currentPlayerIndex];
            const otherPlayer = players[(currentPlayerIndex + 1) % 2];

            if (betsEqual) {
                if (currentPhase === 'preflop' &&
                    ((justActedPlayer.isDealer && !otherPlayer.hasActedThisRound && otherPlayer.currentBet === bigBlindAmt) || // SB (dealer) just called, BB (other) option
                    (!justActedPlayer.isDealer && !otherPlayer.hasActedThisRound && otherPlayer.currentBet === bigBlindAmt && otherPlayer.isDealer)) // BB just called (completed SB), SB (dealer) option
                   ) {
                    // This logic is tricky for BB option. A simpler way for 2 players:
                    // If preflop, and current player is BB, and they haven't acted since SB completed/raised.
                    // Let's use lastRaiserIndex. If bets are equal, and the player whose turn it *would* be
                    // is not the lastRaiserIndex (or if no raise, the BB), the round is over.
                    // More simply: if bets are equal and both players have had a chance to voluntarily act at this bet level.
                    if (justActedPlayer.hasActedThisRound && otherPlayer.hasActedThisRound && justActedPlayer.currentBet === otherPlayer.currentBet) {
                        bettingRoundOver = true;
                        console.log(">> endTurn: Bets equal e entrambi i giocatori attivi hanno agito. Giro finito.");
                    } else if (currentPhase === 'preflop' && justActedPlayer.currentBet === bigBlindAmt && otherPlayer.currentBet === bigBlindAmt &&
                               ( (players[dealerIndex].id === justActedPlayer.id && !players[(dealerIndex+1)%2].hasActedThisRound ) || // Dealer (SB) called, BB option
                                 (players[(dealerIndex+1)%2].id === justActedPlayer.id && !players[dealerIndex].hasActedThisRound && players[dealerIndex].status==='active') // BB completed, SB (if active) option again
                               )
                              ) {
                        bettingRoundOver = false; // BB/SB option scenario
                        console.log(">> endTurn: Preflop, opzione per il Big Blind (o Small Blind se BB completa). Giro continua.");
                    } else if (justActedPlayer.hasActedThisRound && otherPlayer.status !== 'active') { // other player is all-in/folded
                        bettingRoundOver = true; console.log(">> endTurn: Giocatore ha agito, altro non attivo. Giro finito.");
                    }
                    else if (justActedPlayer.hasActedThisRound && otherPlayer.hasActedThisRound) { // Both acted and bets are equal.
                        bettingRoundOver = true; console.log(">> endTurn: Entrambi agito e bets equal. Giro finito.");
                    }
                     else {
                        // Bets are equal, but not everyone has acted on this equality yet.
                        // e.g. P1 bets, P2 calls. P2 (justActedPlayer) has acted. P1 has not acted since P2's call.
                        // This shouldn't be the case if currentPlayerIndex is always the one who *just* acted.
                        // This implies that if bets are equal, and the current player just acted to make them equal, the round is over.
                        // Exception is BB option preflop.
                         bettingRoundOver = true; // Default to true if bets are equal and current player acted
                         if (currentPhase === 'preflop' && players[bbIndex].id === otherPlayer.id && !otherPlayer.hasActedThisRound && currentBetLevel === bigBlindAmt) {
                             bettingRoundOver = false; // BB option
                             console.log(">> endTurn: Preflop, BB ha l'opzione. Giro continua.");
                         } else {
                            console.log(">> endTurn: Bets equal, giocatore ha agito. Giro finito (assumendo no opzione BB speciale).");
                         }

                    }
                } else { // Bets not equal
                    bettingRoundOver = false;
                    console.log(`>> endTurn: Bets NON equal ($${p1.currentBet} vs $${p2.currentBet}). Giro continua.`);
                }
            } else { // Should only be one active player, or both all-in.
                 // This case should be covered by activePlayers.length checks.
                 bettingRoundOver = true;
                 console.log(">> endTurn: Caso non standard con giocatori attivi. Giro finito per sicurezza.");
            }
        }
    }


    if (bettingRoundOver) {
        console.log(">> endTurn: *** BETTING ROUND OVER *** Avanzando...");
        // Reset currentBet for all players for the next round (pot has been updated)
        // Keep hasActedThisRound as is, it's reset at start of new betting round in progressToNextPhase
        players.forEach(p => {
            p.currentBet = 0; // Bets are "in the pot" conceptually
            // p.hasActedThisRound = false; // This is done in progressToNextPhase
        });
        currentBetLevel = 0; // Reset for the new betting round
        lastRaiserIndex = -1; // Reset for new round
        //currentPlayerIndex = dealerIndex; // Post-flop, SB/dealer acts first (or left of dealer) - this is set in progressToNextPhase
        setTimeout(progressToNextPhase, 800);
    } else {
        // Determine next player
        let nextPlayerIndex = (currentPlayerIndex + 1) % players.length;
        let loopGuard = 0;
        // Find next player who is 'active' (can still bet/fold etc.)
        while(players[nextPlayerIndex].status !== 'active' && loopGuard < players.length * 2) {
             console.log(`Skipping player ${players[nextPlayerIndex].name} (Index ${nextPlayerIndex}, Status: ${players[nextPlayerIndex].status}) in endTurn`);
             nextPlayerIndex = (nextPlayerIndex + 1) % players.length; loopGuard++;
             if (loopGuard >= players.length * 2) {
                 console.error("! Loop infinito in endTurn cercando nextPlayerIndex. Fine mano forzata.");
                 endHand(true); // true for showdown if possible
                 return;
             }
        }

        // If no active player found (e.g. one active, one all-in, active player just acted)
        // This should have been caught by bettingRoundOver logic.
         if(players[nextPlayerIndex].status !== 'active') {
             console.warn("!!! endTurn: Nessun giocatore 'active' trovato per il prossimo turno, ma bettingRoundOver era false. Forzatura fine giro.");
             // This implies the round should be over.
             players.forEach(p => {p.currentBet = 0;}); currentBetLevel = 0; lastRaiserIndex = -1;
             setTimeout(progressToNextPhase, 800);
             return;
         }

        currentPlayerIndex = nextPlayerIndex;
        console.log(`>> endTurn: Turno passa a: ${players[currentPlayerIndex].name} (Index: ${currentPlayerIndex})`);
        updateUI(); // Update UI for the next player (will trigger bot or enable human buttons)
    }
    console.log("--- endTurn: Fine ---");
}

function progressToNextPhase() {
    console.log(`--- progressToNextPhase: Inizio (da ${currentPhase}) ---`);
    clearTimeout(communityCardAnimationTimeout);

    players.forEach(p => {
        if (p.status === 'active') p.hasActedThisRound = false; // Reset for the new betting round
        // Bets are already conceptually in pot, UI for player currentBet reset by endTurn.
        const betEl = document.getElementById(`${p.elementPrefix}-bet`);
        if (betEl) betEl.textContent = '0'; // Visual reset of player's bet for the round
    });
    lastRaiserIndex = -1; // Reset for the new round

    const nonFoldedPlayers = players.filter(p => p.status !== 'folded');
    const activeAndCanBetPlayers = players.filter(p => p.status === 'active'); // Players who can still make decisions

    if (nonFoldedPlayers.length <= 1) {
        console.log(">> progressToNextPhase: Meno di 2 non foldati. Fine mano.");
        setTimeout(() => endHand(false), 500); // Winner by default
        return;
    }

    // If only one player can bet (others are all-in or folded), or no one can bet (all remaining are all-in)
    if (activeAndCanBetPlayers.length <= 1 && nonFoldedPlayers.length > 1) {
         console.log(">> progressToNextPhase: Max 1 giocatore può ancora puntare (o nessuno se tutti all-in). Avanza direttamente girando le carte.");
          const cardsToDealCount = 5 - communityCards.length;
          if (cardsToDealCount > 0) {
              console.log(`Dealing ${cardsToDealCount} community cards immediately.`);
              dealCommunityCard(cardsToDealCount, true); // true for revealImmediately, will lead to showdown
          } else { // All cards already dealt
              console.log("Carte comuni già distribuite. Showdown forzato.");
              currentPhase = 'showdown';
              updateCommunityAreaUI();
              setTimeout(() => endHand(true), 1000); // Proceed to showdown
          }
          return;
     }


    // Determine who acts first post-flop (player to the left of dealer, which is BB in 2-player)
    // In 2-player, dealer (SB) acts first pre-flop. Non-dealer (BB) acts first post-flop.
    let firstToActIdx;
    if (players.length === 2) {
        firstToActIdx = (dealerIndex + 1) % 2; // Player to the left of the dealer
    } else { // More complex for >2 players, but this game is 1v1
        firstToActIdx = (dealerIndex + 1) % players.length;
    }

    // Ensure first to act is active, otherwise find next active player
    let loopCheck = 0;
    while (players[firstToActIdx].status !== 'active' && loopCheck < players.length * 2) {
        firstToActIdx = (firstToActIdx + 1) % players.length;
        loopCheck++;
        if (loopCheck >= players.length * 2) {
            console.error("! Loop infinito in progressToNextPhase cercando firstToActIdx. Fine mano.");
            endHand(nonFoldedPlayers.length > 1); return;
        }
    }
    // If after loop, still no active player (should be caught by activeAndCanBetPlayers check above)
    if (players[firstToActIdx].status !== 'active') {
        console.error("! Nessun giocatore attivo trovato per iniziare il giro post-flop! (Questo non dovrebbe accadere). Fine mano.");
        endHand(nonFoldedPlayers.length > 1); return;
    }
    currentPlayerIndex = firstToActIdx;


    let nextPhaseStr = ''; let cardsToDealThisPhase = 0;
    switch (currentPhase) {
        case 'preflop': nextPhaseStr = 'flop'; cardsToDealThisPhase = 3; break;
        case 'flop':    nextPhaseStr = 'turn'; cardsToDealThisPhase = 1; break;
        case 'turn':    nextPhaseStr = 'river'; cardsToDealThisPhase = 1; break;
        case 'river':
            nextPhaseStr = 'showdown';
            console.log(">> progressToNextPhase: Fine puntate River. Showdown imminente.");
            currentPhase = 'showdown'; // Set phase before calling endHand
            updateCommunityAreaUI();
            setTimeout(() => endHand(true), 500); // true for showdown
            return;
         default:
            console.error("Fase sconosciuta in progressToNextPhase:", currentPhase);
            handOver = true; updateUI(); return;
    }

    if (cardsToDealThisPhase > 0) {
        currentPhase = nextPhaseStr;
        console.log(`>> progressToNextPhase: Nuova Fase ${currentPhase}. Dealing ${cardsToDealThisPhase} carte. Turno di: ${players[currentPlayerIndex].name}`);
        updateCommunityAreaUI(); // Update phase display in UI
        dealCommunityCard(cardsToDealThisPhase); // This will eventually call activateNextTurn
    }
    // If cardsToDealThisPhase is 0 but nextPhaseStr is 'showdown', it's handled by 'river' case.

    console.log(`--- progressToNextPhase: Fine (transizione a ${currentPhase}) ---`);
}

function dealCommunityCard(count, revealImmediately = false) {
    console.log(`--- dealCommunityCard: Dealing ${count} cards ${revealImmediately ? '(reveal immediately)' : ''} ---`);
    clearTimeout(communityCardAnimationTimeout);
    let delayBetweenCards = revealImmediately ? 50 : 400; // Animation delay for each card flip
    let totalRevealDelayAccumulator = 0; // Used to stagger card reveals

    function scheduleCardReveal(cardData, cardElement, isLastCardInGroup) {
        const currentCardIndividualDelay = totalRevealDelayAccumulator;
        totalRevealDelayAccumulator += delayBetweenCards; // Increment for the *next* card

        communityCardAnimationTimeout = setTimeout(() => {
            if (cardElement && document.body.contains(cardElement)) {
                console.log(`Revealing ${cardData.id} (community) after ${currentCardIndividualDelay}ms delay.`);
                cardData.faceUp = true;
                cardElement.classList.remove('hidden');
                cardElement.classList.add('flipped');
            } else {
                console.warn(`Card element ${cardData.id} non trovato o rimosso dal DOM in scheduleCardReveal.`);
            }

            if (isLastCardInGroup) {
                console.log("Ultima carta del gruppo di community cards rivelata.");
                if (!revealImmediately) {
                    setTimeout(activateNextTurn, 300);
                } else {
                    console.log("Rivelazione immediata completata, procedendo allo showdown.");
                    currentPhase = 'showdown';
                    updateCommunityAreaUI();
                    setTimeout(() => endHand(true), 1000);
                }
            }
        }, currentCardIndividualDelay);
    }

     const burnBeforeTurnOrRiver = (currentPhase === 'turn' || currentPhase === 'river') && count === 1;
     if (burnBeforeTurnOrRiver && deck.length > 0) {
         const burnedCard = deck.pop();
         console.log(`Bruciata 1 carta prima del ${currentPhase}: ${burnedCard ? burnedCard.id : 'N/D'}`);
     }


    for (let i = 0; i < count; i++) {
        if (deck.length > 0 && communityCards.length < 5) {
            const card = dealCard(null, false); // Deal face down initially
            if (card) {
                communityCards.push(card);
                displayCard(card, communityCardsContainer, true, true); // hidden = true, isNew = true

                const addedCardElements = communityCardsContainer.querySelectorAll(`.card[data-card-id='${card.id}']`);
                const addedCardElement = addedCardElements[addedCardElements.length - 1]; // Get the last one added

                if (addedCardElement) {
                    scheduleCardReveal(card, addedCardElement, i === count - 1);
                } else {
                    console.error(`Elemento carta ${card.id} non trovato nel DOM dopo displayCard!`);
                    if (i === count - 1) { // If error on last card, try to recover flow
                        console.error("Errore critico con l'ultima carta comune, tentativo di recupero.");
                        if (!revealImmediately) setTimeout(activateNextTurn, 300);
                        else setTimeout(() => { currentPhase = 'showdown'; updateCommunityAreaUI(); endHand(true); }, 500);
                    }
                }
            }
        } else {
             console.warn("Mazzo finito o limite carte comuni (5) raggiunto durante dealCommunityCard.");
             if (i === count - 1 || count === 0) { // If this was supposed to be the last card or no cards to deal
                 console.log("Attivazione del prossimo step (mazzo finito/limite/nessuna carta da girare).");
                 if (!revealImmediately) setTimeout(activateNextTurn, 300);
                 else setTimeout(() => { currentPhase = 'showdown'; updateCommunityAreaUI(); endHand(true); }, 500);
             }
             break;
        }
    }
    if (count <= 0 && !revealImmediately) { // Should not happen if progressToNextPhase logic is correct
        console.log("Nessuna carta comune da distribuire, attivazione del prossimo turno/fase.");
        setTimeout(activateNextTurn, 100);
    }
    console.log(`--- dealCommunityCard: Fine programmazione rivelazioni ---`);
}

function activateNextTurn() {
     console.log("--- activateNextTurn ---");
     if (handOver) { console.log("activateNextTurn: Mano già finita, non attivare turno."); return; }

     const activePlayerForTurn = players[currentPlayerIndex];
     // If current player is not 'active' (e.g. all-in, folded), endTurn should be called to find next active or end round
     if (!activePlayerForTurn || activePlayerForTurn.status !== 'active') {
          console.warn(`activateNextTurn: Giocatore corrente ${currentPlayerIndex+1} (${activePlayerForTurn?.name}) non è 'active' (status: ${activePlayerForTurn?.status}). Chiamo endTurn.`);
          endTurn();
          return;
     }

     const nonAllInActivePlayers = players.filter(p => p.status === 'active');
     if (nonAllInActivePlayers.length <= 1 && players.filter(p => p.status !== 'folded').length > 1) {
          console.log("activateNextTurn: Max 1 giocatore può puntare (altri all-in). Avanza alla prossima fase/showdown.");
          players.forEach(p => {p.currentBet = 0; if(p.status === 'active') p.hasActedThisRound = false;});
          currentBetLevel = 0; lastRaiserIndex = -1;
          progressToNextPhase(); // This will deal remaining cards immediately if needed
          return;
     }
     console.log(`Attivazione turno per ${activePlayerForTurn.name} (Index: ${currentPlayerIndex})`);
     updateUI(); // This will enable buttons for human or trigger bot
}

// --- Fine Mano e Showdown ---
let winnerInfoGlobal = { winners: [], winningHand: null, message: "" };
async function endHand(showdown) { // now async
     if (handOver && resultElement && resultElement.classList.contains('result-show')) { console.warn("endHand chiamata ma mano già finita e risultato mostrato."); return; }
     console.log(`--- Fine Mano (Richiesto Showdown: ${showdown}) ---`);
     clearTimeout(resultTimeoutId);
     clearTimeout(communityCardAnimationTimeout);
     handOver = true; disableActionButtons();
     if(bettingAreaDiv) bettingAreaDiv.style.display = 'none';

     const nonFoldedPlayers = players.filter(p => p.status !== 'folded');
     winnerInfoGlobal = { winners: [], winningHand: null, message: "" };

     // Determine if an actual showdown (comparison of hands) should occur
     const performActualShowdown = showdown && nonFoldedPlayers.length > 1;

     if (performActualShowdown) {
          currentPhase = 'showdown'; // Set phase for UI
          console.log("Showdown! Valutazione mani...");
          nonFoldedPlayers.forEach(p => { // Reveal cards of players in showdown
              if (p.hand && p.hand.length > 0) p.hand.forEach(card => card.faceUp = true);
          });
          updatePlayersUI(); // Show player cards immediately
          updateCommunityAreaUI(); // Update phase display
          setTimeout(async () => {
               winnerInfoGlobal = determineWinner(nonFoldedPlayers);
               await finalizeHandResults(winnerInfoGlobal, true); // true for wasShowdown
          }, 1600); // Delay for players to see cards before result
     } else if (nonFoldedPlayers.length === 1) { // Winner by default (others folded)
          currentPhase = 'hand-over';
          const winner = nonFoldedPlayers[0];
          winnerInfoGlobal.winners = [winner];
          winnerInfoGlobal.message = `${winner.name} vince (avversario/i foldato/i)`;
          console.log(winnerInfoGlobal.message);
          if (winner.hand && winner.hand.length > 0) { // Reveal winner's cards
            winner.hand.forEach(card => card.faceUp = true);
          }
          updatePlayersUI();
          updateCommunityAreaUI();
          await finalizeHandResults(winnerInfoGlobal, false); // false for wasShowdown
     } else { // No non-folded players or other edge case (e.g., error, or game ended before cards dealt fully)
          currentPhase = 'hand-over';
          if (pot > 0 && nonFoldedPlayers.length === 0){ // Pot exists but no one to claim it (e.g. simultaneous folds, error)
            console.warn("Situazione anomala: Piatto presente ma nessun giocatore non-foldato. Il piatto resta? (Non gestito, push implicito).");
            winnerInfoGlobal.message = "Push (Nessun vincitore valido).";
          } else if (nonFoldedPlayers.length === 0) {
             winnerInfoGlobal.message = "Mano conclusa senza vincitori (tutti foldati?).";
          } else { // Should be caught by other conditions, but as a fallback
             winnerInfoGlobal.message = "Mano conclusa.";
             console.log("Mano conclusa, situazione non standard per vincitore.");
          }
          updateCommunityAreaUI();
          await finalizeHandResults(winnerInfoGlobal, false);
     }
 }

async function finalizeHandResults(winnerInfo, wasShowdown) { // now async
    let finalMessage = winnerInfo.message || "";
    let outcomeType = 'push'; // Default for P1

    if (winnerInfo.winners && winnerInfo.winners.length > 0) {
        const validWinnersToAwardPot = winnerInfo.winners.filter(w => w.status !== 'folded');
        if (validWinnersToAwardPot.length > 0) {
            const potPerWinner = Math.floor(pot / validWinnersToAwardPot.length);
            const remainder = pot % validWinnersToAwardPot.length;
            console.log(`Distribuendo piatto $${pot} tra ${validWinnersToAwardPot.length} vincitori.`);

            validWinnersToAwardPot.forEach((winner, index) => {
                const amountWon = potPerWinner + (index === 0 ? remainder : 0);
                winner.balance += amountWon;
                console.log(`${winner.name} vince $${amountWon} -> Saldo: $${winner.balance}`);
            });

            const winnerNames = validWinnersToAwardPot.map(w => w.name).join(' e ');
            if (pot > 0) { // If there was a pot to win
                finalMessage = `${winnerNames} vince${validWinnersToAwardPot.length > 1 ? 'no' : ''} il piatto di $${pot}.`;
            } else if (validWinnersToAwardPot.length > 0 && !finalMessage) { // Pot was 0, but still a winner by default
                 finalMessage = `${winnerNames} vince.`;
            }


            const p1WasWinner = validWinnersToAwardPot.some(w => w.id === 1);
            const p2WasWinner = validWinnersToAwardPot.some(w => w.id === 2);

            if (p1WasWinner && !p2WasWinner) outcomeType = 'win';
            else if (!p1WasWinner && p2WasWinner) outcomeType = 'lose';
            else if (p1WasWinner && p2WasWinner) outcomeType = 'push'; // Both won (split pot)
            else outcomeType = 'push'; // Neither P1 nor P2 won but others did (not applicable in 1v1) or other push


            if (wasShowdown && winnerInfo.winningHand && winnerInfo.winningHand.rank >= 0) {
                finalMessage += `\nCon: ${winnerInfo.winningHand.description}`;
            } else if (!wasShowdown && p1WasWinner && validWinnersToAwardPot.length === 1 && validWinnersToAwardPot[0].id === 1) {
                 const player1 = players.find(p=>p.id===1);
                 if (player1 && player1.hand.length >= 2 && player1.status !== 'folded') {
                      const player1Eval = evaluateHand(player1.hand, communityCards);
                      if (player1Eval && player1Eval.rank >= 0) {
                           finalMessage += `\nLa tua mano: ${player1Eval.description}`;
                      }
                 }
            }
        } else {
            if (!finalMessage) finalMessage = "Nessun vincitore valido per il piatto. Push.";
            console.warn("Nessun vincitore non foldato trovato per l'assegnazione del piatto.");
            outcomeType = 'push';
        }
    } else {
        if (!finalMessage) finalMessage = "Nessun vincitore. Push.";
        console.warn("Nessun vincitore determinato. Il piatto (se esistente) non viene assegnato.");
        outcomeType = 'push';
    }
    pot = 0;
    showResult(finalMessage, outcomeType);
    updatePlayersUI(); updateCommunityAreaUI();
    await saveGameState(); // Save final balances
 }

// --- Hand Evaluation (simplified, focused on 5-card hands) ---
function getRankDisplayString(rankValue) {
    if (rankValue === undefined || rankValue === null) return '?';
    const display = invRankMap[rankValue];
    return display === 'T' ? '10' : display;
}

function evaluateHand(playerCards, currentCommunityCards) {
    if (!playerCards || playerCards.length < 2) return { rank: -1, description: "Mano Incompleta (Giocatore)", cards: [], value: -1 };
    const allCardsInput = [...playerCards, ...(currentCommunityCards || [])];
    if (allCardsInput.length < 2) return { rank: -1, description: "Mano Incompleta (Totale)", cards: [], value: -1 };

    let bestHandDetails = { rank: -1, value: -1, description: "Carta Alta (default)", cards: [] };

    // Generate all 5-card combinations from allCardsInput (if >= 5 cards)
    // If less than 5 cards total, evaluate that single combination
    const cardCombinations = allCardsInput.length >= 5 ? getCombinations(allCardsInput, 5) : [allCardsInput];

    if (cardCombinations.length === 0 && allCardsInput.length > 0) { // Should only happen if getCombinations fails or k > arr.length
        cardCombinations.push(allCardsInput.slice(0,5)); // Fallback: use first 5 or fewer
    }
     if (cardCombinations.length === 0 && allCardsInput.length === 0) {
        return { rank: -1, description: "Nessuna carta", cards: [], value: -1 };
    }


    cardCombinations.forEach(fiveCardCombo => {
        if (fiveCardCombo.length === 0) return;

        const numericRanks = fiveCardCombo.map(c => rankMap[c.rank]).sort((a, b) => b - a); // Sort high to low
        const suitsInCombo = fiveCardCombo.map(c => c.suit);

        const rankCounts = {};
        numericRanks.forEach(r => rankCounts[r] = (rankCounts[r] || 0) + 1);
        const countsOfRanks = Object.values(rankCounts).sort((a, b) => b - a); // e.g., [3,1,1] for trips

        // Flush Check (only if 5 cards)
        let isFlush = false;
        if (fiveCardCombo.length === 5) {
            isFlush = new Set(suitsInCombo).size === 1;
        }

        // Straight Check (only if 5 cards)
        let isStraight = false;
        let straightHighCard = 0;
        if (fiveCardCombo.length === 5) {
            const uniqueSortedRanksAsc = [...new Set(numericRanks)].sort((a, b) => a - b); // Ace (14) is high
            if (uniqueSortedRanksAsc.length >= 5) { // Need 5 distinct ranks for a straight
                for (let i = uniqueSortedRanksAsc.length - 1; i >= 4; i--) {
                    if (uniqueSortedRanksAsc[i] - uniqueSortedRanksAsc[i - 4] === 4) {
                        isStraight = true; straightHighCard = uniqueSortedRanksAsc[i]; break;
                    }
                }
            }
            // A-2-3-4-5 (Wheel) check: Ace (14), 5, 4, 3, 2
            if (!isStraight && uniqueSortedRanksAsc.includes(14) && uniqueSortedRanksAsc.includes(2) && uniqueSortedRanksAsc.includes(3) && uniqueSortedRanksAsc.includes(4) && uniqueSortedRanksAsc.includes(5)) {
                isStraight = true; straightHighCard = 5; // Ace is low (5-high straight)
            }
        }

        let currentRankVal = 0;
        let currentDescriptionStr = "";
        let significantCardRanks = []; // For tie-breaking, ordered by importance

        if (isStraight && isFlush) { // Straight Flush / Royal Flush
            currentRankVal = 8;
            currentDescriptionStr = (straightHighCard === 14) ? "Scala Reale" : `Scala Colore (Alta ${getRankDisplayString(straightHighCard)})`;
            significantCardRanks = [straightHighCard];
        } else if (countsOfRanks[0] === 4) { // Four of a Kind
            currentRankVal = 7;
            const fourRank = parseInt(Object.keys(rankCounts).find(k => rankCounts[k] === 4));
            const kicker = numericRanks.find(r => r !== fourRank) || 0;
            currentDescriptionStr = `Poker di ${getRankDisplayString(fourRank)}`;
            significantCardRanks = [fourRank, kicker];
        } else if (countsOfRanks[0] === 3 && countsOfRanks[1] >= 2) { // Full House
            currentRankVal = 6;
            const threeRank = parseInt(Object.keys(rankCounts).find(k => rankCounts[k] === 3));
            const pairRank = parseInt(Object.keys(rankCounts).find(k => rankCounts[k] >= 2 && parseInt(k) !== threeRank));
            currentDescriptionStr = `Full House (${getRankDisplayString(threeRank)} su ${getRankDisplayString(pairRank)})`;
            significantCardRanks = [threeRank, pairRank];
        } else if (isFlush) { // Flush
            currentRankVal = 5;
            currentDescriptionStr = `Colore (Alta ${getRankDisplayString(numericRanks[0])})`;
            significantCardRanks = numericRanks.slice(0, 5); // Top 5 cards of the flush
        } else if (isStraight) { // Straight
            currentRankVal = 4;
            currentDescriptionStr = `Scala (Alta ${getRankDisplayString(straightHighCard)})`;
            significantCardRanks = [straightHighCard];
        } else if (countsOfRanks[0] === 3) { // Three of a Kind
            currentRankVal = 3;
            const threeRank = parseInt(Object.keys(rankCounts).find(k => rankCounts[k] === 3));
            const kickers = numericRanks.filter(r => r !== threeRank).slice(0, 2);
            currentDescriptionStr = `Tris di ${getRankDisplayString(threeRank)}`;
            significantCardRanks = [threeRank, ...kickers, 0, 0].slice(0,3); // Ensure 3 ranks for tie-break
        } else if (countsOfRanks[0] === 2 && countsOfRanks[1] >= 2) { // Two Pair
            currentRankVal = 2;
            const pairRanks = Object.keys(rankCounts).filter(k => rankCounts[k] >= 2).map(r => parseInt(r)).sort((a,b)=>b-a);
            const kicker = numericRanks.find(r => r !== pairRanks[0] && r !== pairRanks[1]) || 0;
            currentDescriptionStr = `Doppia Coppia (${getRankDisplayString(pairRanks[0])} e ${getRankDisplayString(pairRanks[1])})`;
            significantCardRanks = [pairRanks[0], pairRanks[1], kicker];
        } else if (countsOfRanks[0] === 2) { // One Pair
            currentRankVal = 1;
            const pairRank = parseInt(Object.keys(rankCounts).find(k => rankCounts[k] === 2));
            const kickers = numericRanks.filter(r => r !== pairRank).slice(0, 3);
            currentDescriptionStr = `Coppia di ${getRankDisplayString(pairRank)}`;
            significantCardRanks = [pairRank, ...kickers, 0, 0, 0].slice(0,4);  // Ensure 4 ranks for tie-break
        } else { // High Card
            currentRankVal = 0;
            if (numericRanks.length > 0) {
                currentDescriptionStr = `Carta Alta (${getRankDisplayString(numericRanks[0])})`;
                significantCardRanks = numericRanks.slice(0, Math.min(5, numericRanks.length));
            } else { // Should not happen if fiveCardCombo has cards
                currentDescriptionStr = "Nessuna mano valida";
                significantCardRanks = [0,0,0,0,0];
            }
        }

        // Calculate numerical hand value for comparison
        let calculatedValue = currentRankVal;
        for (let i = 0; i < 5; i++) { // Max 5 kickers for tie-breaking value
            calculatedValue = calculatedValue * 15 + (significantCardRanks[i] || 0);
        }

        if (calculatedValue > bestHandDetails.value) {
            bestHandDetails.rank = currentRankVal;
            bestHandDetails.value = calculatedValue;
            bestHandDetails.description = currentDescriptionStr;
            bestHandDetails.cards = fiveCardCombo; // The 5 cards forming this hand
        }
    });
    return bestHandDetails;
}

function getCombinations(arr, k) {
    if (k < 0 || k > arr.length) return [];
    if (k === 0) return [[]];
    if (arr.length === k) return [arr];
    if (k === 1) return arr.map(item => [item]);

    let combinations = [];
    for (let i = 0; i <= arr.length - k; i++) {
        let firstElement = arr[i];
        let smallerArray = arr.slice(i + 1);
        let subCombinations = getCombinations(smallerArray, k - 1);
        for (let subCombo of subCombinations) {
            combinations.push([firstElement].concat(subCombo));
        }
    }
    return combinations;
}

function determineWinner(playersInShowdown) {
    let bestEval = { rank: -1, value: -1, description: "N/D", cards:[] };
    let currentWinners = []; // Can be multiple in case of a tie

    console.log("--- Valutazione Mani Showdown ---");
    playersInShowdown.forEach(player => {
        if (player.status === 'folded') {
            player.evaluatedHand = { rank: -1, description: "Foldato", value: -1, cards: [] };
            console.log(`${player.name}: Foldato (non dovrebbe essere in showdown).`);
            return;
        }
        player.evaluatedHand = evaluateHand(player.hand, communityCards); // evaluateHand now returns {rank, value, description, cards}
        console.log(`${player.name} (${player.hand.map(c=>c.id).join(',')}) Community: (${communityCards.map(c=>c.id).join(',')}) -> ${player.evaluatedHand.description} (Val: ${player.evaluatedHand.value.toFixed(0)})`);

        if (player.evaluatedHand.value > bestEval.value) {
            bestEval = player.evaluatedHand;
            currentWinners = [player]; // New best hand, so new winner list
            console.log(`   -> Nuova mano migliore: ${bestEval.description} da ${player.name}`);
        } else if (player.evaluatedHand.value === bestEval.value && player.evaluatedHand.rank >= 0) {
            // Tie in hand value, add player to current winners
             if (!currentWinners.some(w => w.id === player.id)) { // Avoid duplicates
                currentWinners.push(player);
                console.log(`   -> Pareggio con ${player.name} (${player.evaluatedHand.description})`);
            }
        }
    });
    console.log("---------------------------------");
    return { winners: currentWinners, winningHand: bestEval, message: "" };
}


// --- Bot Logic (V6 - Refined from V5) ---
function handleBotTurn() {
    console.log("--- handleBotTurn (V6 Logic): Inizio ---");
    try {
        const bot = players[currentPlayerIndex];
        // Robust initial checks
        if (handOver || !bot || !bot.isBot || bot.status !== 'active' || currentPlayerIndex !== bot.id - 1) {
            console.log(`handleBotTurn: Skip. handOver=${handOver}, botValid=${!!bot}, isBot=${bot?.isBot}, status=${bot?.status}, isCurrentTurn=${currentPlayerIndex === bot?.id - 1}`);
            if (!handOver && bot && bot.id === currentPlayerIndex + 1 && bot.status !== 'active') {
                console.log("handleBotTurn: Bot non attivo (e.g. all-in), chiamando endTurn per gestire il flusso.");
                endTurn(); // Let endTurn progress if bot is all-in etc.
            }
            return;
        }

        console.log(`handleBotTurn: Esecuzione per ${bot.name}. Fase: ${currentPhase}`);
        const opponent = players[(currentPlayerIndex + 1) % players.length];
        const amountToCall = Math.max(0, currentBetLevel - bot.currentBet);
        let action = 'fold'; let betRaiseTotalAmount = 0;

        const botEval = evaluateHand(bot.hand, communityCards); // Full evaluation
        const aggression = 0.2 + Math.random() * 0.3; // 0.2 to 0.5

        // Preflop Strategy (Chen Formula-inspired, simplified)
        if (currentPhase === 'preflop') {
            const [card1, card2] = bot.hand;
            let score = 0;
            const r1 = rankMap[card1.rank], r2 = rankMap[card2.rank];
            const high = Math.max(r1, r2), low = Math.min(r1,r2);

            // Score for high card
            if (high === rankMap.A) score = 10; else if (high === rankMap.K) score = 8;
            else if (high === rankMap.Q) score = 7; else if (high === rankMap.J) score = 6;
            else score = high / 2; // For T and below

            if (r1 === r2) score *= 2; // Pairs are strong, double the score (min 5 for 22)
            if (card1.suit === card2.suit) score += 2; // Suited bonus
            const gap = Math.abs(r1 - r2);
            if (gap === 1 && r1 !== r2) score += 1; // Connector bonus (non-pair)
            else if (gap === 2) score -=1; else if (gap === 3) score -=2;
            else if (gap === 4) score -=4; else if (gap > 4) score -=5;

            if (gap < 2 && high < rankMap.Q && r1 !== r2) score +=1; // Bonus for low connectors/one-gappers below Q

            console.log(`Bot Preflop: ${card1.id}-${card2.id}. Score: ${score.toFixed(1)}.`);

            const raiseThreshold = 10 + aggression * 10; // Higher score needed to raise
            const callThreshold = 6 + aggression * 5;   // Medium score to call
            const playThreshold = 3;                     // Minimum to consider playing cheap

            if (amountToCall === 0) { // Can check or bet
                if (score >= callThreshold) {
                    action = 'bet';
                    let betPct = 0.33 + (score / 30) * 0.5 + aggression * 0.2; // Bet 33% to ~100% pot
                    betRaiseTotalAmount = Math.floor(Math.max(pot, bigBlindAmt) * Math.min(1, betPct) );
                } else action = 'check';
            } else { // Must call, raise, or fold
                const potOdds = amountToCall / (pot + amountToCall + bot.currentBet); // Approximate
                if (score >= raiseThreshold) {
                    action = 'raise';
                    let raisePct = 2 + (score / 20) * 2 + aggression; // Raise 2x to ~5x call amount
                    betRaiseTotalAmount = currentBetLevel + Math.floor(amountToCall * Math.max(1.5, raisePct));
                } else if (score >= callThreshold || (score >= playThreshold && potOdds < (0.3 - aggression * 0.2))) {
                    action = 'call';
                } else {
                    action = 'fold';
                }
            }
        } else { // Postflop Strategy
            console.log(`Bot Postflop Eval: ${botEval.description} (Rank ${botEval.rank}, Value ${botEval.value.toFixed(0)})`);
            const handStrength = botEval.rank + (botEval.value / Math.pow(15,6)); // Normalize value somewhat (0-8.x)

            if (amountToCall === 0) { // Can check or bet
                if (handStrength > 1.5 || (handStrength > 0.5 && Math.random() < (0.3 + aggression))) { // Pair+ or decent bluff
                    action = 'bet';
                    let betPct = 0.25 + handStrength * 0.1 + aggression * 0.3;
                    betRaiseTotalAmount = Math.floor(pot * Math.min(1.2, betPct)); // Bet 25% to 120% pot
                } else {
                    action = 'check';
                }
            } else { // Must call, raise, or fold
                const potOdds = amountToCall / (pot + amountToCall + bot.currentBet);
                if (handStrength > 3.5) { // Strong hand (Tris+)
                    action = (Math.random() < (0.6 + aggression)) ? 'raise' : 'call';
                    let raisePct = 1.5 + handStrength * 0.2 + aggression;
                    betRaiseTotalAmount = currentBetLevel + Math.floor(amountToCall * Math.max(1, raisePct));
                } else if (handStrength > 1.5) { // Decent hand (Pair, Two Pair)
                    if (potOdds < (0.4 - handStrength*0.05 - aggression * 0.1)) {
                        action = (Math.random() < (0.2 + aggression + handStrength*0.05) && handStrength > 2) ? 'raise' : 'call';
                        let raisePct = 1.2 + handStrength * 0.15 + aggression;
                        betRaiseTotalAmount = currentBetLevel + Math.floor(amountToCall * Math.max(1, raisePct));
                    } else action = 'fold';
                } else { // Weak hand (High card, maybe weak pair)
                    if (potOdds < (0.2 - aggression * 0.15) && Math.random() < (0.4 + aggression)) { // Good odds for cheap bluff catch
                        action = 'call';
                    } else if (Math.random() < aggression * 0.3) { // Occasional bluff raise
                        action = 'raise'; betRaiseTotalAmount = currentBetLevel + Math.floor(amountToCall * (1.5 + aggression*2));
                    }
                    else action = 'fold';
                }
            }
        }

        // Finalize bet/raise amount
        if (action === 'bet' || action === 'raise') {
            const minTotalValid = calculateMinBetRaise();
            const maxTotalBotCanBet = bot.balance + bot.currentBet;

            betRaiseTotalAmount = Math.max(bigBlindAmt, Math.floor(betRaiseTotalAmount)); // Ensure at least BB if not already all-in
            betRaiseTotalAmount = Math.max(minTotalValid, betRaiseTotalAmount); // Must be at least min valid raise/bet
            betRaiseTotalAmount = Math.min(maxTotalBotCanBet, betRaiseTotalAmount); // Cannot bet more than stack

            if (action === 'raise' && betRaiseTotalAmount <= currentBetLevel) { // Not a valid raise
                action = (bot.balance >= amountToCall && amountToCall > 0) ? 'call' : 'fold';
                 console.log(`Bot Invalid Raise: Adjusted to ${action}. (Attempted: ${betRaiseTotalAmount}, CurrentBetLevel: ${currentBetLevel})`);
            } else if (action === 'bet' && betRaiseTotalAmount < minTotalValid && maxTotalBotCanBet > betRaiseTotalAmount) { // Bet less than min (and not all-in for less)
                action = 'check'; // Should have been check if amountToCall was 0
                 console.log(`Bot Invalid Bet: Adjusted to ${action}. (Attempted: ${betRaiseTotalAmount}, MinValid: ${minTotalValid})`);
            }
            if(betRaiseTotalAmount >= maxTotalBotCanBet && bot.balance > 0) { console.log("Bot action is All-in."); }
        }

        console.log(`Bot (${bot.name}) Final Decision: ${action.toUpperCase()}` +
                    (action === 'bet' || action === 'raise' ? ` to $${betRaiseTotalAmount}` :
                    (action === 'call' ? ` ($${Math.min(amountToCall, bot.balance)})`: '')));

        // Execute action with delay
        setTimeout(() => {
            try {
                // Re-check state before executing, as things might change during timeout
                if (handOver || currentPlayerIndex !== bot.id - 1 || !players[currentPlayerIndex] || players[currentPlayerIndex].status !== 'active') {
                    console.log(`Azione Bot ${action} ANNULLATA (stato cambiato o non più turno del bot).`);
                    return;
                }
                console.log(`Bot ESEGUENDO: ${action.toUpperCase()}`);
                bot.hasActedThisRound = true;

                switch (action) {
                    case 'fold': bot.status = 'folded'; break;
                    case 'check':
                        if (bot.currentBet < currentBetLevel) {
                            console.warn("Bot Check invalido (timeout). Fold forzato."); bot.status = 'folded';
                        }
                        break;
                    case 'call':
                        const actualCall = Math.min(amountToCall, bot.balance);
                        if (actualCall > 0) { bot.balance -= actualCall; pot += actualCall; }
                        bot.currentBet += actualCall;
                        if (bot.balance === 0 && actualCall > 0) { bot.status = 'all-in'; console.log(`Bot All-in call $${actualCall}`); }
                        break;
                    case 'bet': case 'raise':
                        const amountAdded = betRaiseTotalAmount - bot.currentBet;
                        if (amountAdded > 0) { bot.balance -= amountAdded; pot += amountAdded; }
                        bot.currentBet = betRaiseTotalAmount;
                        if (betRaiseTotalAmount > currentBetLevel) { // Check if it's a real bet/raise
                            currentBetLevel = bot.currentBet;
                            lastRaiserIndex = currentPlayerIndex;
                        }
                        if (bot.balance === 0 && amountAdded > 0) { bot.status = 'all-in'; console.log(`Bot All-in ${action} to ${betRaiseTotalAmount}`); }
                        break;
                     default: console.error(`Azione bot sconosciuta (timeout): ${action}`); bot.status = 'folded';
                }
                endTurn();
            } catch (innerErr) {
                console.error("ERRORE esecuzione azione Bot (timeout):", innerErr);
                const botInErr = players[currentPlayerIndex];
                if (botInErr && botInErr.isBot && !handOver) {
                    console.log("Recupero: Fold forzato Bot causa errore interno."); botInErr.status = 'folded'; botInErr.hasActedThisRound = true; endTurn();
                }
            }
        }, 1000 + Math.random() * 700); // Bot "thinking" time
    } catch (outerErr) {
        console.error("ERRORE CRITICO decisione Bot:", outerErr);
        const botInErr = players[currentPlayerIndex];
        if (botInErr && botInErr.isBot && !handOver && botInErr.status === 'active') {
            console.log("Recupero: Fold forzato Bot causa errore esterno."); botInErr.status = 'folded'; botInErr.hasActedThisRound = true; endTurn();
        }
    }
    console.log("--- handleBotTurn (V6 Logic): Fine (Azione schedulata) ---");
}


// --- UI Update Functions ---
function updateUI() {
    updatePlayersUI();
    updateCommunityAreaUI();

    const currentPlayer = players[currentPlayerIndex];
    const isHandActiveAndPlayerTurn = !handOver &&
                                   currentPhase !== 'pre-deal' &&
                                   currentPhase !== 'showdown' &&
                                   currentPhase !== 'hand-over' &&
                                   currentPlayer &&
                                   currentPlayer.status === 'active';

    console.log(`updateUI: Player=${currentPlayerIndex} (${currentPlayer?.name}), Mode=${gameMode}, isHandActive&Turn=${isHandActiveAndPlayerTurn}, isBot=${currentPlayer?.isBot}, Status=${currentPlayer?.status}`);

    if (isHandActiveAndPlayerTurn) {
        if (bettingAreaDiv.style.display === 'flex') {
            console.log(">> updateUI: Betting area open, updating its buttons, base buttons disabled.");
            disableActionButtons();
            updateActionAmountButtons();
        } else {
            if (gameMode === 'PVB' && currentPlayer.isBot) {
                console.log(">> updateUI: PVB - Bot's turn. Disabling buttons, scheduling Bot action.");
                disableActionButtons();
                // setTimeout(handleBotTurn, 500 + Math.random() * 500); // Bot turn initiated by endTurn/activateNextTurn now
                 handleBotTurn(); // Call directly as it's bot's turn
            } else { // PVB Human's turn or PVP turn
                console.log(`>> updateUI: ${gameMode === 'PVB' ? "PVB - Human's turn" : `PVP - Player ${currentPlayer.id}'s turn`}. Enabling/updating base action buttons.`);
                updateActionButtons();
            }
        }
    } else {
        console.log(">> updateUI: Disabling action buttons (hand over, not turn, or inactive player).");
        disableActionButtons();
        if (bettingAreaDiv.style.display === 'flex'){
             updateActionAmountButtons();
         }
    }
}


function updatePlayersUI() {
    players.forEach(player => {
        const prefix = player.elementPrefix;
        const balanceEl = document.getElementById(`${prefix}-balance`);
        const betEl     = document.getElementById(`${prefix}-bet`);
        const statusEl  = document.getElementById(`${prefix}-status`);
        const cardsContainer = document.getElementById(`${prefix}-cards`);
        const dealerButtonEl = document.getElementById(`dealer-button-p${player.id}`);

        if (balanceEl) balanceEl.textContent = player.balance;
        if (betEl)     betEl.textContent     = player.currentBet;
        if (statusEl)  statusEl.textContent  = ({
            active:   'Attivo',
            folded:   'Foldato',
            'all-in': 'All-in',
            out:      'Eliminato'
        })[player.status] || player.status;

        if (dealerButtonEl) {
            dealerButtonEl.style.display = (player.isDealer && !handOver && currentPhase !== 'pre-deal' && currentPhase !== 'showdown' && currentPhase !== 'hand-over')
                                          ? 'flex' : 'none';
        }

        if (cardsContainer) {
            cardsContainer.innerHTML = '';
            player.hand.forEach(card => {
                let hideThisCard = true; // Default to hidden

                if (player.status === 'folded') {
                    hideThisCard = true; // Folded players' cards are always hidden
                } else if (handOver || currentPhase === 'showdown') {
                    hideThisCard = false; // At the end of the hand or showdown, reveal all non-folded players' cards
                } else {
                    // --- Active hand, not showdown ---
                    if (gameMode === 'PVB') {
                        if (player.id === 1) { // Player 1 (Human) in PVB mode
                            hideThisCard = false;
                        } else { // Player 2 (Bot) in PVB mode
                            hideThisCard = true; // Bot's cards are hidden from Human
                        }
                    } else if (gameMode === 'PVP') {
                        // In PVP, only the current player sees their cards. Opponent's cards are hidden.
                        if (player.id === players[currentPlayerIndex].id) {
                            hideThisCard = false; // It's this player's turn, show their cards
                        } else {
                            hideThisCard = true; // It's not this player's turn, hide their cards
                        }
                    }
                }
                card.faceUp = !hideThisCard; // Update the card object's state
                displayCard(card, cardsContainer, hideThisCard, false); // Pass 'hideThisCard' to displayCard
            });
        } else {
            console.error(`Contenitore carte non trovato per ${prefix}`);
        }
    });
}

function updateCommunityAreaUI() {
     if (potAmountSpan) potAmountSpan.textContent = pot; else console.error("potAmountSpan non trovato");
     let phaseText = '-';
     switch(currentPhase) {
         case 'pre-deal': phaseText = 'In Attesa'; break;
         case 'preflop': phaseText = 'Pre-Flop'; break;
         case 'flop': phaseText = 'Flop'; break;
         case 'turn': phaseText = 'Turn'; break;
         case 'river': phaseText = 'River'; break;
         case 'showdown': phaseText = 'Showdown'; break;
         case 'hand-over': phaseText = 'Mano Finita'; break;
         default: phaseText = currentPhase;
     }
     if (gamePhaseSpan) gamePhaseSpan.textContent = phaseText; else console.error("gamePhaseSpan non trovato");

     if(turnIndicator && turnIndicatorSpan) {
         const turnPlayer = players[currentPlayerIndex];
         const isGameActiveForTurn = !handOver && currentPhase !== 'pre-deal' && currentPhase !== 'showdown' && currentPhase !== 'hand-over';
         const isPlayerAbleToAct = turnPlayer && turnPlayer.status === 'active';
         const playerNameForTurn = (isGameActiveForTurn && isPlayerAbleToAct) ? turnPlayer.name : '-';

         turnIndicatorSpan.textContent = playerNameForTurn;

         const shouldHighlightP2 = isGameActiveForTurn && isPlayerAbleToAct && turnPlayer.id === 2;
         if (shouldHighlightP2) {
             turnIndicator.classList.add('player2-turn');
             if(turnIndicator.firstChild && turnIndicator.firstChild.nodeType === Node.TEXT_NODE) turnIndicator.firstChild.textContent = 'È il turno di: ';
         } else {
             turnIndicator.classList.remove('player2-turn');
             if(turnIndicator.firstChild && turnIndicator.firstChild.nodeType === Node.TEXT_NODE) turnIndicator.firstChild.textContent = 'Turno di: ';
         }
     } else {
         if(!turnIndicator) console.warn("turnIndicator non trovato");
         if(!turnIndicatorSpan) console.warn("turnIndicatorSpan non trovato");
     }
 }

function updateActionButtons() {
     const player = players[currentPlayerIndex];
     console.log(`--- updateActionButtons: Start for Player ${player?.id} (${player?.name}) Status: ${player?.status} ---`);
      if (!foldButton || !checkButton || !callButton || !betButton || !raiseButton || !callAmountSpan || !document.getElementById('buttons')) {
          console.error("Elementi bottoni azione principali non trovati!"); return;
      }
      const buttonsContainer = document.getElementById('buttons');

     if (bettingAreaDiv && bettingAreaDiv.style.display === 'flex') {
         console.log(">> updateActionButtons: Area betting visibile, nascondi/disabilita bottoni base.");
         buttonsContainer.style.display = 'none';
         disableActionButtons();
         return;
     } else {
         buttonsContainer.style.display = 'flex';
     }

     const canPlayerAct = !handOver && player && player.status === 'active';
     if (!canPlayerAct) {
         console.log(">> updateActionButtons: Il giocatore non può agire. Disabilito tutto.");
         disableActionButtons();
         // Fold button should also be disabled if player cannot act (e.g. not their turn or hand over)
         // It's enabled below only if it IS their turn and they are active.
         return;
     }
     console.log(`>> updateActionButtons: Giocatore ${player.id} (${player.name}) può agire.`);

     const amountToCall = Math.max(0, currentBetLevel - player.currentBet);
     const canCheck = amountToCall <= 0;
     const canCall = amountToCall > 0 && player.balance > 0;

     const canInitiateBet = currentBetLevel === 0 && player.balance > 0;
     const minTotalForAction = calculateMinBetRaise(); // Min total bet for a bet or raise
     const canAffordMinAction = player.balance + player.currentBet >= minTotalForAction;

     const canBet = canInitiateBet && canAffordMinAction;
     // Can raise if: there's a bet to raise, player has more balance than just the call amount, AND can afford min raise size
     const canRaise = currentBetLevel > 0 && player.balance > amountToCall && canAffordMinAction;


     console.log(`>> updateActionButtons: Bal: ${player.balance}, CurrBet: ${player.currentBet}, BetLvl: ${currentBetLevel}, AmtToCall: $${amountToCall}, MinTotalAct: $${minTotalForAction}`);
     console.log(`   CanCheck: ${canCheck}, CanCall: ${canCall}, CanBet: ${canBet}, CanRaise: ${canRaise}`);


     foldButton.disabled = false; // Always available if player can act
     checkButton.disabled = !canCheck;
     callButton.disabled = !canCall;
     betButton.disabled = !canBet;
     raiseButton.disabled = !canRaise;

     if (canCall) {
         callAmountSpan.textContent = Math.min(amountToCall, player.balance);
     } else {
         callAmountSpan.textContent = '0';
     }

     checkButton.style.display = canCheck ? 'inline-block' : 'none';
     betButton.style.display = canBet ? 'inline-block' : 'none';
     callButton.style.display = canCall ? 'inline-block' : 'none';
     raiseButton.style.display = canRaise ? 'inline-block' : 'none';
     foldButton.style.display = 'inline-block';

     console.log("--- updateActionButtons: Finish ---");
 }

function disableActionButtons() {
    if(foldButton) foldButton.disabled = true;
    if(checkButton) { checkButton.disabled = true; checkButton.style.display = 'none'; }
    if(callButton) { callButton.disabled = true; callButton.style.display = 'none'; if(callAmountSpan) callAmountSpan.textContent = '0';}
    if(betButton) { betButton.disabled = true; betButton.style.display = 'none'; }
    if(raiseButton) { raiseButton.disabled = true; raiseButton.style.display = 'none'; }
    if(foldButton) foldButton.style.display = 'inline-block'; // Keep fold button visible, but disabled
}

function calculateMinBetRaise() {
    const player = players[currentPlayerIndex];
    if (!player) return bigBlindAmt;

    const maxPlayerCanBetTotal = player.balance + player.currentBet;
    const minBetIncrement = bigBlindAmt; // Standard minimum increment

    let minTotalBet; // The minimum total amount this player's bet must be

    if (currentBetLevel > 0) { // There is a bet to call or raise
        // Min raise must be current bet + at least the minimum increment
        minTotalBet = currentBetLevel + minBetIncrement;
    } else { // No bet yet, opening bet
        minTotalBet = minBetIncrement; // Min opening bet is Big Blind
    }

    // Player cannot be forced to bet more than they have (all-in)
    // If minTotalBet is more than they can afford, their min action is all-in
    // If they can afford minTotalBet, that's their minimum.
    if (maxPlayerCanBetTotal < minTotalBet) {
        return Math.floor(maxPlayerCanBetTotal); // All-in for less
    }
    return Math.floor(minTotalBet);
}

function showResult(message, outcomeType = 'push') { // outcomeType for P1: 'win', 'lose', 'push'
     console.log(`Mostrando risultato: ${message}, Tipo (per P1): ${outcomeType}`);
     clearTimeout(communityCardAnimationTimeout);
     clearTimeout(resultTimeoutId);
     if (!resultElement) { console.error("Elemento #result non trovato!"); return; }

     resultElement.textContent = message;
     resultElement.className = 'result'; // Reset classes
     resultElement.classList.add(`result-${outcomeType}`); // Apply specific outcome style for P1
     resultElement.classList.add('result-show'); // Make it visible

     if (nextHandButton) {
         nextHandButton.style.display = 'inline-block';
         nextHandButton.disabled = false;
     } else { console.error("Elemento #next-hand-button non trovato!"); }

     disableActionButtons();
     if (bettingAreaDiv) bettingAreaDiv.style.display = 'none';


     resultTimeoutId = setTimeout(() => {
         if (resultElement) {
             resultElement.classList.remove('result-show', 'result-win', 'result-lose', 'result-push');
         }
     }, 4500); // Increased display time to 4.5 seconds
}

// --- Gestione Tema ---
async function toggleTheme() { // now async
    const currentTheme = document.body.dataset.theme;
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    document.body.dataset.theme = newTheme;
    if (themeToggle) themeToggle.checked = (newTheme === 'dark');
    await saveGameState(); // Save theme preference
}

// --- Event Listeners (attached to DOM elements directly or via window.onload) ---
// Note: onclick attributes in HTML are already linking to global functions.
// For buttons created dynamically or for better practice, use addEventListener.

// Expose functions to global scope for HTML onclick handlers to work with type="module"
window.selectGameMode = selectGameMode;
window.quitGame = quitGame;
window.showRules = showRules;
window.changeGame = changeGame;
window.playerAction = playerAction; // Expose if called from HTML, though better to use listeners
window.startNewHand = startNewHand; // For Next Hand button
window.submitBetRaise = submitBetRaise; // For confirm bet button
window.cancelBetRaiseInput = cancelBetRaiseInput; // For cancel bet button
window.clearActionAmount = clearActionAmount; // For clear bet button
window.setBetAmount = setBetAmount; // For pot/all-in buttons


window.onload = () => {
    console.log("Window loaded. Initializing UI and event listeners.");
    try {
        loadGameState(); // Load theme

        // Initial UI state
        if (gameAreaDiv) gameAreaDiv.style.display = 'none';
        if (gameModeSelectionDiv) gameModeSelectionDiv.style.display = 'block';
        if (betInputAreaDiv) betInputAreaDiv.style.display = 'none';
        if (bettingAreaDiv) bettingAreaDiv.style.display = 'none';
        if (nextHandButton) nextHandButton.style.display = 'none';

        // Event listeners for static buttons that are always present
        if (themeToggle) themeToggle.addEventListener('change', toggleTheme);
        // Player action buttons (fold, check, call, bet, raise) have onclick in HTML,
        // but their availability is managed by updateActionButtons.
        // Chip buttons already have listeners via DOMContentLoaded.

        resetTableVisuals();
        disableActionButtons();
        console.log("Initial UI state set. Firebase services initialized via module import.");
        // onAuthStateChanged listener is active from the top of the script.
    } catch (e) {
        console.error("ERRORE CRITICO window.onload:", e);
        alert("Errore caricamento pagina. Controlla console (F12).");
    }
};

function showRules() {
    alert("Regole Base Texas Hold'em (1v1 Semplificato):\n\n" +
          `1. Blinds: Il giocatore col bottone (D) paga lo Small Blind (SB, $${smallBlindAmt}), l'altro il Big Blind (BB, $${bigBlindAmt}). ` +
          "In 1v1, il Dealer è SB e agisce per primo pre-flop, ma per secondo post-flop.\n" +
          "2. Pre-Flop: Ricevi 2 carte private. Giro di puntate iniziando dal SB.\n" +
          "3. Flop: 3 carte comuni scoperte. Giro di puntate iniziando dal non-Dealer (BB).\n" + // Corrected: Post-flop, non-dealer (BB in 1v1) acts first.
          "4. Turn: 1 carta comune scoperta. Giro di puntate.\n" +
          "5. River: 1 carta comune scoperta. Ultimo giro di puntate.\n" +
          "6. Showdown: Se più giocatori rimangono dopo il River, si mostrano le carte. Vince la miglior mano di 5 carte (usando qualsiasi combinazione delle 2 private + 5 comuni).\n\n" +
          "Azioni:\n" +
          "- Fold: Abbandoni la mano.\n" +
          "- Check: Passi il turno (solo se non ci sono puntate da chiamare).\n" +
          "- Call: Pareggi la puntata attuale.\n" +
          "- Bet: Fai la prima puntata del giro (se nessuno ha ancora puntato).\n" +
          "- Raise: Aumenti la puntata attuale (se qualcuno ha già puntato).\n" +
          "- All-in: Punti tutte le tue fiches rimanenti.");
}

function changeGame() {
    console.log("Tentativo di reindirizzamento a 'index.html' (o pagina selezione giochi)");
    window.location.href = 'index.html'; // Assumes index.html is in the same directory
}

// --- FINE CODICE JAVASCRIPT ---
</script>
</body>
</html>
