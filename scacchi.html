<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gioco di Scacchi v5.0 - Completo</title>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YN9CKJS2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J1YN9CKJS2');
</script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Roboto+Mono:wght@400&display=swap" rel="stylesheet">
    <meta name="google-adsense-account" content="ca-pub-9456850571765688">
    <style>
        /* --- Variabili Colore Base (Tema Chiaro Casinò - Default) --- */
        :root {
            /* Colori Scacchiera Default (Verde Casinò) */
            --current-light-square-bg: #4caf50; /* [cite: 1] */
            --current-dark-square-bg: #2e7d32; /* [cite: 1] */
            --current-board-border-color: #fbc02d; /* [cite: 1] */

/* Stile per il bottone "Cambia Gioco" in alto a sinistra */
#change-game-button-chess {
    /* Posizionamento in alto a sinistra */
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 10;

    /* Stili presi dagli altri bottoni per coerenza */
    padding: 8px 15px;                     /* */
    border: 1px solid var(--panel-border-color); /* */
    border-radius: 4px;                    /* */
    background-color: var(--button-bg);    /* */
    color: var(--button-text-color);       /* */
    font-size: 0.95em;                     /* */
    cursor: pointer;                       /* */
    transition: background-color 0.2s ease, box-shadow 0.2s ease; /* */
    margin: 0; /* Rimuove margine extra se non necessario in posizione assoluta */
}

/* Stile Hover (come gli altri bottoni) */
#change-game-button-chess:hover {
    background-color: var(--button-hover-bg); /* */
    box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* */
}

/* Stile Disabled (se necessario, opzionale) */
#change-game-button-chess:disabled {
    cursor: not-allowed;                   /* */
    opacity: 0.6;
    background-color: #aaa;                /* */
    border-color: #999;                    /* */
    color: #555;                           /* */
}
body.theme-dark #change-game-button-chess:disabled {
     background-color: #555;                /* */
     border-color: #666;                    /* */
     color: #999;                           /* */
}


            /* Colori UI Tema Chiaro */
            --selected-square-bg: rgba(255, 235, 59, 0.7); /* [cite: 2] */
            --possible-move-dot-color: rgba(255, 255, 255, 0.4); /* [cite: 3] */
            --capture-move-dot-color: rgba(244, 67, 54, 0.6); /* [cite: 3] */
            --last-move-highlight-color: rgba(255, 193, 7, 0.5); /* [cite: 3] */
            --check-highlight-color: rgba(244, 67, 54, 0.8); /* [cite: 3] */ /* Più opaco */ /* [cite: 4] */

            --piece-shadow: drop-shadow(0 1px 2px rgba(0,0,0,0.4)); /* [cite: 4] */ /* Ombra generica pezzi */ /* [cite: 5] */

            /* Colori UI Chiaro */
            --text-color: #212121; /* [cite: 5] */
            --panel-bg: #1b5e20; /* [cite: 6] */
            --panel-border-color: #fbc02d; /* [cite: 6] */
            --tab-bg: #388e3c; /* [cite: 6] */
            --tab-active-bg: #1b5e20; /* [cite: 6] */
            --tab-hover-bg: #4caf50; /* [cite: 6] */
            --tab-border-color: #fbc02d; /* [cite: 6] */
            --button-bg: #fbc02d; /* [cite: 6] */
            --button-hover-bg: #ffca28; /* [cite: 6] */
            --button-text-color: #212121; /* [cite: 6] */
            --body-bg: #2e7d32; /* [cite: 6] */
            --neon-bg: #ffee58; /* [cite: 7] */
            --neon-glow: 0 0 8px #ffee58; /* [cite: 7] */
            --feedback-popup-bg: rgba(255, 235, 59, 0.9); /* [cite: 7] */
            --feedback-popup-text: #212121; /* [cite: 7] */
            --draw-offer-color: #0288d1; /* [cite: 7] */
            --draw-offer-bg: #e1f5fe; /* [cite: 7] */
            --modal-bg: var(--panel-bg); /* [cite: 7] */
            --modal-border-color: var(--panel-border-color); /* [cite: 8] */
            --modal-text-color: var(--text-color); /* [cite: 8] */
            --help-details-bg: rgba(0,0,0,0.1); /* [cite: 8] */
            --help-details-border: rgba(251, 192, 45, 0.5); /* [cite: 8] */

            --animation-speed: 0.25s; /* [cite: 8] */ /* Leggermente più veloce */ /* [cite: 9] */
            --board-size: 560px; /* [cite: 9] */
            --square-size: calc(var(--board-size) / 8); /* [cite: 10] */
            --piece-size: calc(var(--square-size) * 0.85); /* [cite: 10] */
        }

        /* --- Tema Scuro --- */
        body.theme-dark {
            /* Colori Scacchiera Tema Scuro */
            --current-light-square-bg: #616161; /* [cite: 10] */
            --current-dark-square-bg: #424242; /* [cite: 11] */
            --current-board-border-color: #757575; /* [cite: 11] */

            /* Colori UI Tema Scuro */
            --selected-square-bg: rgba(100, 181, 246, 0.7); /* [cite: 11] */
            --text-color: #ffffff; /* [cite: 12] */
            --panel-bg: #303030; /* [cite: 12] */
            --panel-border-color: #616161; /* [cite: 12] */
            --tab-bg: #424242; /* [cite: 12] */
            --tab-active-bg: #303030; /* [cite: 12] */
            --tab-hover-bg: #515151; /* [cite: 12] */
            --tab-border-color: #616161; /* [cite: 12] */
            --button-bg: #0288d1; /* [cite: 12] */
            --button-hover-bg: #03a9f4; /* [cite: 12] */
            --button-text-color: #ffffff; /* [cite: 12] */
            --body-bg: #212121; /* [cite: 13] */
            --neon-bg: #4fc3f7; /* [cite: 13] */
            --neon-glow: 0 0 8px #4fc3f7; /* [cite: 13] */
            --feedback-popup-bg: rgba(2, 136, 209, 0.9); /* [cite: 13] */
            --feedback-popup-text: #ffffff; /* [cite: 13] */
            --draw-offer-color: #ffeb3b; /* [cite: 13] */
            --draw-offer-bg: #424242; /* [cite: 13] */
            --modal-bg: #424242; /* [cite: 14] */
            --modal-border-color: #757575; /* [cite: 14] */
            --modal-text-color: #ffffff; /* [cite: 14] */
            --help-details-bg: rgba(255,255,255,0.08); /* [cite: 14] */
            --help-details-border: rgba(117, 117, 117, 0.5); /* [cite: 14] */
            --piece-shadow: drop-shadow(0 1px 3px rgba(0,0,0,0.6)); /* [cite: 14] */
        }

        /* --- Stili Generali --- */
        body {
            font-family: 'Roboto', sans-serif; /* [cite: 15] */
            display: flex; justify-content: center; align-items: flex-start; /* [cite: 16] */
            padding: 20px; background-color: var(--body-bg); color: var(--text-color); /* [cite: 16] */
            transition: background-color 0.3s ease, color 0.3s ease; /* [cite: 16] */
            min-height: 100vh; /* [cite: 17] */
            box-sizing: border-box; margin: 0; position: relative; overflow-x: hidden; /* [cite: 17] */
        }

        /* --- Effetto Neon Selettivo --- */
        h2, .tab-button, #status, .player-info span:first-child, #history-status,
        #feedback-popup, #setup-screen label, #setup-screen select, #stats-content p
        {
            background-color: var(--neon-bg); /* [cite: 18] */
            box-shadow: var(--neon-glow); /* [cite: 19] */
            padding: 4px 8px; border-radius: 4px; display: inline-block; /* [cite: 19] */
            color: var(--text-color); /* [cite: 19] */
            transition: background-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease; /* [cite: 20] */
            border: none; margin-bottom: 5px; /* [cite: 20] */
        }
        #setup-help-sections .help-content-wrapper p,
        #setup-help-sections .help-content-wrapper li,
        #setup-help-sections .help-content-wrapper strong,
        #setup-help-sections .help-content-wrapper em {
            background-color: var(--neon-bg); /* [cite: 21] */
            box-shadow: var(--neon-glow); /* [cite: 22] */
            padding: 2px 5px; border-radius: 3px; color: var(--text-color); /* [cite: 22] */
            margin-bottom: 8px; line-height: 1.5; /* [cite: 22] */
            transition: background-color 0.3s ease, box-shadow 0.3s ease, color 0.3s ease; /* [cite: 23] */
        }
        #setup-help-sections .help-content-wrapper li { display: list-item; /* [cite: 24] */
            margin-left: 20px;} /* [cite: 25] */
        #setup-help-sections .help-content-wrapper strong,
        #setup-help-sections .help-content-wrapper em { display: inline; /* [cite: 25] */
            margin-bottom: 0; padding: 1px 3px;} /* [cite: 26] */

        /* Rimuovi Neon selettivamente */
        #move-list li, #history-controls button, #controls-content button, #stats-content button,
        .modal-content h3, .modal-content p, .modal-content button,
        .promotion-option, #setup-screen button#start-setup-button, #settings-button,
        #theme-settings-modal label, #theme-settings-modal .slider,
        #setup-help-sections summary, #setup-help-sections h4, .timer /* Timer senza neon */ /* [cite: 26] */
        {
            background: none; box-shadow: none; padding: revert; border-radius: revert; /* [cite: 27] */
            color: inherit; /* [cite: 27] */
        }

        /* Bottoni Standard */
        #history-controls button, #controls-content button, #stats-content button,
        .modal-content button, #setup-screen button#start-setup-button, #settings-button {
            padding: 8px 15px; /* [cite: 28] */
            border: 1px solid var(--panel-border-color); border-radius: 4px; /* [cite: 29] */
            background-color: var(--button-bg); color: var(--button-text-color); /* [cite: 29] */
            font-size: 0.95em; margin: 5px; cursor: pointer; /* [cite: 29] */
            transition: background-color 0.2s ease, box-shadow 0.2s ease; /* [cite: 30] */
        }
        #history-controls button, #settings-button { margin: 0; /* [cite: 30] */
        }
        #settings-button { padding: 0; width: 40px; height: 40px; border-radius: 50%; display: flex; /* [cite: 31] */
            justify-content: center; align-items: center; } /* [cite: 32] */
        #history-controls button:hover, #controls-content button:hover, #stats-content button:hover,
        .modal-content button:hover, #setup-screen button#start-setup-button:hover, #settings-button:hover {
            background-color: var(--button-hover-bg); /* [cite: 32] */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* [cite: 33] */
        }
        #settings-button:hover { transform: rotate(90deg); /* [cite: 33] */
        }
        #history-controls button:disabled, #controls-content button:disabled,
        #stats-content button:disabled, .modal-content button:disabled {
            cursor: not-allowed; /* [cite: 34] */
            opacity: 0.6; background-color: #aaa; border-color: #999; color: #555; /* [cite: 35] */
        }
        body.theme-dark #history-controls button:disabled,
        body.theme-dark #controls-content button:disabled,
        body.theme-dark #stats-content button:disabled,
        body.theme-dark .modal-content button:disabled {
             background-color: #555; /* [cite: 35] */
             border-color: #666; color: #999; /* [cite: 36] */
        }

        /* Layout */
        #main-container { display: none; /* [cite: 36] */
            flex-wrap: wrap; justify-content: center; align-items: flex-start; gap: 20px; width: 100%; max-width: 1200px; padding: 15px; box-sizing: border-box; /* [cite: 37] */
        }
        #game-container { display: flex; flex-direction: column; align-items: center; flex-shrink: 0; /* [cite: 38] */
        }
        #chessboard-wrapper { position: relative; width: var(--board-size); height: var(--board-size); margin-bottom: 15px; /* [cite: 39] */
            box-shadow: 0 8px 24px rgba(0,0,0,0.4); border-radius: 8px; overflow: hidden; background-color: var(--current-board-border-color); padding: 6px; transition: background-color 0.3s ease; /* [cite: 40] */
        }
        #chessboard { width: 100%; height: 100%; display: grid; grid-template-columns: repeat(8, var(--square-size)); /* [cite: 41] */
            grid-template-rows: repeat(8, var(--square-size)); border: 2px solid var(--current-board-border-color); background-color: var(--current-dark-square-bg); transition: border-color 0.3s ease, background-color 0.3s ease; /* [cite: 42] */
        }
        .square { width: var(--square-size); height: var(--square-size); display: flex; justify-content: center; align-items: center; /* [cite: 43] */
            position: relative; cursor: pointer; user-select: none; transition: background-color 0.1s ease-in-out; box-sizing: border-box; /* [cite: 44] */
        }
        .square.light { background-color: var(--current-light-square-bg); /* [cite: 45] */
        }
        .square.dark { background-color: var(--current-dark-square-bg); /* [cite: 46] */
        }
        .square.selected { outline: 3px solid var(--selected-square-bg); outline-offset: -3px; z-index: 1; /* [cite: 47] */
        }
        .square.last-move-from::before, .square.last-move-to::before { content: ''; position: absolute; top: 0; left: 0; /* [cite: 48] */
            width: 100%; height: 100%; background-color: var(--last-move-highlight-color); z-index: 0; pointer-events: none; animation: fadeInHighlight 0.4s ease; /* [cite: 49] */
        }
        .square.in-check::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; /* [cite: 50] */
            height: 100%; background: radial-gradient(ellipse at center, var(--check-highlight-color) 0%, transparent 70%); z-index: 0; animation: pulse-check 1.5s infinite ease-in-out alternate; pointer-events: none; /* [cite: 51] */
        }
        @keyframes pulse-check { from { opacity: 0.6; } to { opacity: 1; /* [cite: 52] */
        } }
        .square.possible-move::after { content: ''; position: absolute; top: 50%; left: 50%; /* [cite: 53] */
            transform: translate(-50%, -50%); width: 20%; height: 20%; background-color: var(--possible-move-dot-color); border-radius: 50%; z-index: 1; pointer-events: none; animation: fadeInHighlight 0.2s ease; /* [cite: 54] */
        }
        .square.capture-move::before { content: ''; position: absolute; top: 5%; left: 5%; width: 90%; /* [cite: 55] */
            height: 90%; border: 4px solid var(--capture-move-dot-color); border-radius: 50%; box-sizing: border-box; z-index: 1; pointer-events: none; animation: fadeInHighlight 0.2s ease; /* [cite: 56] */
        }
        .square.capture-move::after { display: none; /* [cite: 57] */
        }
        @keyframes fadeInHighlight { from { opacity: 0; } to { opacity: 1; /* [cite: 58] */
        } }

        /* Pezzi */
        .piece { width: var(--piece-size); /* [cite: 59] */
            height: var(--piece-size); display: flex; justify-content: center; align-items: center; position: absolute; z-index: 2; cursor: grab; /* [cite: 60] */
            transition: transform var(--animation-speed) ease-out, opacity var(--animation-speed) ease-out; user-select: none; box-sizing: border-box; filter: var(--piece-shadow); /* [cite: 61] */
        }
        .piece:active { cursor: grabbing; /* [cite: 62] */
        }
        .piece.piece-moving { z-index: 10; /* [cite: 63] */
        }
        .piece.piece-captured { opacity: 0 !important; transform: scale(0.5) rotate(30deg) !important; pointer-events: none; /* [cite: 64] */
            z-index: 1; } /* [cite: 65] */
        .piece img { width: 100%; height: 100%; object-fit: contain; /* [cite: 65] */
            pointer-events: none; } /* [cite: 66] */

        /* Pannello Laterale */
        #controls-tabs-container { width: clamp(300px, 90vw, 450px); /* [cite: 66] */
            background-color: var(--panel-bg); border: 1px solid var(--panel-border-color); border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); overflow: hidden; /* [cite: 67] */
            transition: background-color 0.3s ease, border-color 0.3s ease; } /* [cite: 68] */
        .tabs-nav { display: flex; /* [cite: 68] */
            border-bottom: 1px solid var(--tab-border-color); background-color: var(--tab-bg); overflow-x: auto; white-space: nowrap; /* [cite: 69] */
        }
        .tabs-nav::-webkit-scrollbar { height: 4px; /* [cite: 70] */
        }
        .tabs-nav::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 2px; /* [cite: 71] */
        }
        .tab-button { padding: 10px 15px; cursor: pointer; border: none; /* [cite: 72] */
            border-right: 1px solid var(--tab-border-color); background-color: transparent; font-size: 0.9em; transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease; flex-shrink: 0; /* [cite: 73] */
            min-width: 70px; text-align: center; display: inline-block; } /* [cite: 74] */
        .tab-button:last-child { border-right: none; /* [cite: 74] */
        }
        .tab-button:hover { background-color: var(--tab-hover-bg); box-shadow: none; /* [cite: 75] */
        }
        .tab-button.active { background-color: var(--tab-active-bg); font-weight: bold; box-shadow: none; /* [cite: 76] */
        }
        .tab-content { display: none; padding: 15px; animation: fadeIn 0.3s ease-in-out; /* [cite: 77] */
        }
        .tab-content.active { display: flex; flex-direction: column; gap: 15px; /* [cite: 78] */
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); /* [cite: 79] */
        } to { opacity: 1; transform: translateY(0); } } /* [cite: 80] */

        /* Contenuto Tabs */
        #status { font-weight: bold; /* [cite: 80] */
            text-align: center; padding: 8px; border-radius: 4px; margin-bottom: 10px; border: 1px solid transparent; display: block; width: calc(100% - 18px); min-height: 1.2em; /* [cite: 81] */
            box-sizing: border-box; } /* [cite: 82] */
        #status.check { color: #a94442; background-color: #f2dede; border: 1px solid #ebccd1; /* [cite: 82] */
            box-shadow: none; } /* [cite: 83] */
        #status.game-over { color: #31708f; background-color: #d9edf7; border: 1px solid #bce8f1; /* [cite: 83] */
            box-shadow: none; } /* [cite: 84] */
        #status.draw-offer { color: var(--draw-offer-color); background-color: var(--draw-offer-bg); border-color: var(--draw-offer-color); box-shadow: none; /* [cite: 84] */
        }
        body.theme-dark #status.check { color: #ffcdd2; background-color: #b71c1c; border-color: #ef9a9a; /* [cite: 85] */
        }
        body.theme-dark #status.game-over { color: #81d4fa; background-color: #01579b; border-color: #4fc3f7; /* [cite: 86] */
        }
        body.theme-dark #status.draw-offer { color: var(--draw-offer-color); background-color: var(--draw-offer-bg); border-color: var(--draw-offer-color); /* [cite: 87] */
        }
        .player-info { display: flex; justify-content: space-between; align-items: center; padding: 5px 8px; /* [cite: 88] */
            border-radius: 4px; } /* [cite: 89] */
        .player-info span:first-child { font-weight: 500; margin-right: auto; padding-right: 10px; /* [cite: 89] */
        }
        .timer { font-size: 1.1em; font-family: 'Roboto Mono', monospace; padding: 2px 6px; /* [cite: 90] */
            border-radius: 3px; min-width: 60px; text-align: right; background-color: rgba(0,0,0,0.05); color: var(--text-color); /* [cite: 91] */
        }
        .player-info.active { background-color: rgba(0, 0, 0, 0.1); /* [cite: 92] */
        }
        .player-info.active span:first-child { font-weight: 700; /* [cite: 93] */
        }
        .player-info.active .timer { background-color: #dff0d8; color: #3c763d; /* [cite: 94] */
        }
        .player-info .timer.low-time { color: #a94442; background-color: #f2dede; /* [cite: 95] */
            animation: pulse-timer 1s infinite ease-in-out alternate; } /* [cite: 96] */
        @keyframes pulse-timer { from { opacity: 1; /* [cite: 96] */
        } to { opacity: 0.7; } } /* [cite: 97] */
        body.theme-dark .player-info { background-color: transparent;}
        body.theme-dark .timer { background-color: rgba(255,255,255,0.1); /* [cite: 97] */
        }
        body.theme-dark .player-info.active { background-color: rgba(255, 255, 255, 0.15); /* [cite: 98] */
        }
        body.theme-dark .player-info.active .timer { background-color: #4a6b4a; color: #c8e6c9; /* [cite: 99] */
        }
        body.theme-dark .player-info .timer.low-time { color: #ffcdd2; background-color: #b71c1c; /* [cite: 100] */
        }
        #move-list { list-style: none; padding: 0; margin: 0 0 10px 0; /* [cite: 101] */
            max-height: 200px; overflow-y: auto; font-size: 0.9em; border: 1px solid var(--panel-border-color); border-radius: 4px; background-color: var(--body-bg); /* [cite: 102] */
        }
        #move-list li { padding: 4px 8px; border-bottom: 1px solid var(--panel-border-color); cursor: pointer; /* [cite: 103] */
            display: flex; justify-content: space-between; background-color: transparent; color: var(--text-color); width: 100%; box-sizing: border-box; transition: background-color 0.2s ease; /* [cite: 104] */
        }
        #move-list li:hover { background-color: var(--tab-hover-bg); /* [cite: 105] */
        }
        #move-list li:last-child { border-bottom: none; /* [cite: 106] */
        }
        #move-list li .move-number { color: #777; margin-right: 8px; flex-shrink: 0; min-width: 25px; /* [cite: 107] */
            text-align: right; } /* [cite: 108] */
        body.theme-dark #move-list li .move-number { color: #aaa; /* [cite: 108] */
        }
        #move-list li .move-notation { flex-grow: 1; text-align: left; margin-right: 5px; /* [cite: 109] */
        }
        #move-list li .white-move { display: inline-block; min-width: 60px; margin-right: 5px; font-weight: 500; /* [cite: 110] */
        }
        #move-list li .black-move { display: inline-block; min-width: 60px; /* [cite: 111] */
            font-weight: 500;} /* [cite: 112] */
        #move-list li.highlighted-move { background-color: var(--selected-square-bg) !important; /* [cite: 112] */
        }
        #history-controls { display: flex; justify-content: space-between; align-items: center; gap: 5px; /* [cite: 113] */
        }
        #history-controls button { min-width: 30px; /* [cite: 114] */
            padding: 5px;} /* [cite: 115] */
        #history-status { margin: 0 5px; /* [cite: 115] */
        }
        body.theme-dark #move-list { background-color: rgba(255,255,255,0.05); /* [cite: 116] */
        }
        #controls-content button { width: 100%; /* [cite: 117] */
        }
        #stats-content p { font-size: 0.95em; text-align: center; display: block; /* [cite: 118] */
            width: 100%;} /* [cite: 119] */
        #stats-content p span { font-weight: bold; margin-left: 5px; /* [cite: 119] */
        }
        #stats-content button { margin-top: 15px; width: 100%; /* [cite: 120] */
        }

        /* Modali */
        .modal { display: none; /* [cite: 121] */
            position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.65); justify-content: center; align-items: center; opacity: 0; /* [cite: 122] */
            transition: opacity 0.3s ease; pointer-events: none; } /* [cite: 123] */
        .modal.visible { display: flex; opacity: 1; /* [cite: 123] */
            pointer-events: auto; } /* [cite: 124] */
        .modal-content { background-color: var(--modal-bg); color: var(--modal-text-color); padding: 25px; /* [cite: 124] */
            border: 1px solid var(--modal-border-color); border-radius: 8px; width: 85%; max-width: 420px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); transform: scale(0.9); /* [cite: 125] */
            transition: transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; /* [cite: 126] */
        }
        .modal.visible .modal-content { transform: scale(1); /* [cite: 127] */
        }
        .modal-content h3 { margin-top: 0; margin-bottom: 15px; display: block; width: 100%; /* [cite: 128] */
            color: var(--modal-text-color); font-size: 1.4em;} /* [cite: 129] */
        .modal-content p { margin-bottom: 20px; display: block; width: 100%; /* [cite: 129] */
            color: var(--modal-text-color); font-size: 1em; line-height: 1.4;} /* [cite: 130] */
        .modal-buttons { display: flex; justify-content: center; /* [cite: 130] */
            gap: 15px; margin-top: 20px; flex-wrap: wrap;} /* [cite: 131] */
        .modal-content button { width: auto; min-width: 100px; /* [cite: 131] */
            margin: 5px; } /* [cite: 132] */
        #promotion-choices { display: flex; justify-content: center; gap: 15px; margin-top: 15px; /* [cite: 132] */
        }
        .promotion-option { width: 50px; height: 50px; cursor: pointer; margin: 0 5px; /* [cite: 133] */
            transition: transform 0.2s ease; display: flex; justify-content: center; align-items: center; background: rgba(255,255,255,0.1); border: 2px solid transparent; border-radius: 4px; /* [cite: 134] */
        }
        .promotion-option img { max-width: 90%; max-height: 90%; filter: var(--piece-shadow); /* [cite: 135] */
        }
        .promotion-option:hover { transform: scale(1.15); border-color: var(--button-hover-bg); /* [cite: 136] */
            background: rgba(255,255,255,0.2);} /* [cite: 137] */
        #draw-offer-modal .modal-buttons button { min-width: 120px; /* [cite: 137] */
        }
        #theme-settings-modal .modal-content { max-width: 320px; text-align: left; /* [cite: 138] */
        }
        #theme-settings-modal h3 { text-align: center; /* [cite: 139] */
        }
        .theme-switch-wrapper { display: flex; align-items: center; justify-content: space-between; gap: 10px; width: 100%; /* [cite: 140] */
            margin-bottom: 25px; padding: 10px; box-sizing: border-box; background-color: rgba(0,0,0,0.1); border-radius: 6px;} /* [cite: 141] */
        .theme-switch-wrapper label:first-child { margin: 0; /* [cite: 141] */
            flex-shrink: 0; font-weight: 500; color: var(--modal-text-color); } /* [cite: 142] */
        .theme-switch { position: relative; display: inline-block; /* [cite: 142] */
            width: 50px; height: 24px; flex-shrink: 0; } /* [cite: 143] */
        .theme-switch input { opacity: 0; /* [cite: 143] */
            width: 0; height: 0; } /* [cite: 144] */
        .slider { position: absolute; cursor: pointer; top: 0; /* [cite: 144] */
            left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; /* [cite: 145] */
        }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 2px; /* [cite: 146] */
            bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; } /* [cite: 147] */
        input:checked + .slider { background-color: var(--button-bg); /* [cite: 147] */
        }
        input:checked + .slider:before { transform: translateX(26px); /* [cite: 148] */
        }
        #theme-settings-modal .modal-buttons { justify-content: flex-end; /* [cite: 149] */
        }

        /* Setup Screen */
        #setup-screen { display: flex; /* [cite: 150] */
            flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 650px; padding: 30px 40px; background-color: var(--panel-bg); border: 2px solid var(--panel-border-color); /* [cite: 151] */
            border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.3); margin: 20px auto; gap: 15px; text-align: center; /* [cite: 152] */
            transition: background-color 0.3s ease, border-color 0.3s ease; } /* [cite: 153] */
        #setup-screen h2 { font-size: 2em; /* [cite: 153] */
            margin-bottom: 20px; display: block; width: 100%; } /* [cite: 154] */
        #setup-screen div:not(#setup-help-sections):not(#setup-ai-settings) { /* Escludi anche #setup-ai-settings da questa regola generica se necessario */ /* [cite: 154] */
             width: 90%; /* [cite: 154] */
             display: flex; flex-direction: column; align-items: center; gap: 8px; /* [cite: 155] */
        }
        #setup-screen label { width: 80%; /* [cite: 155] */
            max-width: 300px; text-align: left; font-size: 1em; margin-bottom: 0; display: block; /* [cite: 156] */
        }
        #setup-screen select { padding: 10px; border: 1px solid var(--panel-border-color); border-radius: 4px; /* [cite: 157] */
            width: 80%; max-width: 300px; font-size: 1em; background-color: var(--body-bg); color: var(--text-color); /* [cite: 158] */
        }
        /* --- Regola CSS chiave: Nasconde le opzioni IA di default --- */
        #setup-screen #setup-ai-settings {
             display: none; /* [cite: 159] */ /* Nascosto inizialmente */ /* [cite: 160] */
             width: 90%; /* [cite: 160] */
             flex-direction: column; /* [cite: 160] */
             align-items: center; /* [cite: 161] */
             gap: 8px; /* [cite: 161] */
             /* Aggiungi altri stili se necessario quando è visibile */
        }
        /* ----------------------------------------------------------- */
        #setup-screen button#start-setup-button { padding: 12px 25px; /* [cite: 161] */
            font-size: 1.1em; margin-top: 25px; width: auto; } /* [cite: 162] */
        #setup-help-sections { width: 90%; margin-top: 30px; /* [cite: 162] */
            border-top: 1px solid var(--panel-border-color); padding-top: 20px; display: flex; flex-direction: column; gap: 15px; /* [cite: 163] */
        }
        #setup-help-sections details { border: 1px solid var(--help-details-border); border-radius: 6px; background-color: var(--help-details-bg); /* [cite: 164] */
            transition: background-color 0.3s ease; } /* [cite: 165] */
        #setup-help-sections summary { padding: 10px 15px; cursor: pointer; /* [cite: 165] */
            font-weight: bold; color: var(--text-color); list-style: none; position: relative; outline: none; background-color: transparent; display: block; /* [cite: 166] */
        }
        #setup-help-sections summary::before { content: '▶'; position: absolute; left: 15px; top: 50%; /* [cite: 167] */
            transform: translateY(-50%) rotate(0deg); transition: transform 0.2s ease; font-size: 0.8em; color: var(--panel-border-color); /* [cite: 168] */
        }
        #setup-help-sections details[open] summary::before { transform: translateY(-50%) rotate(90deg); /* [cite: 169] */
        }
        #setup-help-sections summary::-webkit-details-marker { display: none; /* [cite: 170] */
        }
        #setup-help-sections .help-content-wrapper { padding: 5px 20px 15px 40px; /* [cite: 171] */
        }
        #setup-help-sections h4 { color: var(--panel-border-color); margin-top: 15px; margin-bottom: 8px; /* [cite: 172] */
            border-bottom: 1px solid var(--help-details-border); padding-bottom: 3px; font-size: 1.1em; display: inline-block; width: auto; /* [cite: 173] */
        }

        /* Settings Button */
        #settings-button { position: fixed; /* [cite: 174] */
            top: 15px; right: 15px; z-index: 1001; } /* [cite: 175] */
        #settings-button svg { width: 24px; /* [cite: 175] */
            height: 24px; fill: var(--button-text-color); transition: fill 0.3s ease; } /* [cite: 176] */

        /* Feedback Popup */
        #feedback-popup { position: fixed; /* [cite: 176] */
            top: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background-color: var(--feedback-popup-bg); color: var(--feedback-popup-text); border-radius: 5px; /* [cite: 177] */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), var(--neon-glow); z-index: 1050; display: none; font-size: 0.95em; font-weight: 500; opacity: 0; /* [cite: 178] */
            transition: opacity 0.3s ease-out, top 0.3s ease-out; text-align: center; pointer-events: none; /* [cite: 179] */
        }
        #feedback-popup.visible { display: block; opacity: 1; top: 30px; /* [cite: 180] */
        }

        /* Media Queries */
        @media (max-width: 800px) {
            body { padding: 10px; /* [cite: 181] */
            }
            #main-container { flex-direction: column; align-items: center; gap: 15px; /* [cite: 182] */
            }
            #game-container { width: 100%; max-width: 95vw; /* [cite: 183] */
            }
            :root { --board-size: min(95vw, 400px); /* [cite: 184] */
            }
            #chessboard-wrapper { width: var(--board-size); height: var(--board-size); padding: 4px; /* [cite: 185] */
            }
            #controls-tabs-container { width: 95vw; max-width: 400px; /* [cite: 186] */
            }
            .tab-button { min-width: 60px; font-size: 0.85em; /* [cite: 187] */
                padding: 8px 10px; } /* [cite: 188] */
            #setup-screen { padding: 20px 15px; /* [cite: 188] */
                max-width: 95vw; } /* [cite: 189] */
            #setup-help-sections { width: 95%; /* [cite: 189] */
            }
            #settings-button { top: 10px; right: 10px; width: 36px; /* [cite: 190] */
                height: 36px; } /* [cite: 191] */
            #settings-button svg { width: 20px; /* [cite: 191] */
                height: 20px; } /* [cite: 192] */
            .modal-content { max-width: 90vw; padding: 20px; /* [cite: 192] */
            }
            #theme-settings-modal .modal-content { max-width: 90vw; /* [cite: 193] */
            }
        }
         @media (max-width: 480px) {
            :root { --board-size: min(95vw, 320px); /* [cite: 194] */
            }
            #chessboard-wrapper { width: var(--board-size); height: var(--board-size); /* [cite: 195] */
            }
            #controls-tabs-container { width: 100%; max-width: var(--board-size); /* [cite: 196] */
            }
             .tab-button { min-width: 50px; font-size: 0.8em; /* [cite: 197] */
                 padding: 6px 8px; } /* [cite: 198] */
             #setup-screen { padding: 15px 10px; /* [cite: 198] */
             }
             h2 { font-size: 1.6em; /* [cite: 199] */
             }
             #status, .player-info span:first-child, #history-status, #feedback-popup, #setup-screen label, #setup-screen select, #stats-content p, .tab-button { padding: 3px 6px; /* [cite: 200] */
                 font-size: 0.85em; } /* [cite: 201] */
             #setup-help-sections .help-content-wrapper p, #setup-help-sections .help-content-wrapper li { font-size: 0.9em; /* [cite: 201] */
                 padding: 2px 4px; } /* [cite: 202] */
             #setup-help-sections .help-content-wrapper strong, #setup-help-sections .help-content-wrapper em { padding: 1px 2px; /* [cite: 202] */
             }
             .modal-content button, #history-controls button, #setup-screen button#start-setup-button { padding: 6px 12px; /* [cite: 203] */
                 font-size: 0.9em; } /* [cite: 204] */
             .timer { font-size: 1em; /* [cite: 204] */
                 min-width: 50px;} /* [cite: 205] */
             #move-list li .white-move, #move-list li .black-move { min-width: 50px; /* [cite: 205] */
             }
        }

    </style>
</head>
<body > <button id="settings-button" title="Impostazioni Tema">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
    </button>

    <div id="setup-screen">

<button id="change-game-button-chess"
        onclick="changeGame()">Cambia Gioco</button>

        <h2>Imposta la Partita</h2>
        <div>
            <label for="setup-game-mode">Modalità:</label> <select id="setup-game-mode">
                <option value="classic" selected>Classica (1 vs 1 Locale)</option> <option value="vsAI">1 vs IA</option> <option value="rapid_10">Rapida 10 min (1 vs 1)</option> <option value="rapid_10_ai">Rapida 10 min (1 vs IA)</option> <option value="blitz_5">Blitz 5 min (1 vs 1)</option> <option value="blitz_5_ai">Blitz 5 min (1 vs IA)</option> <option value="bullet_1">Bullet 1 min (1 vs 1)</option> <option value="bullet_1_ai">Bullet 1 min (1 vs IA)</option> </select> </div>
        <div id="setup-ai-settings">
            <label for="setup-ai-difficulty">Difficoltà IA:</label>
            <select id="setup-ai-difficulty">
                <option value="easy">Facile (Casuale)</option> <option value="medium" selected>Medio (Priorità Cattura)</option> <option value="hard">Difficile (Minimax Base - Lento)</option> </select>
             <label for="setup-player-color">Gioca come:</label>
             <select id="setup-player-color">
                 <option value="white" selected>Bianco</option>
                 <option value="black">Nero</option>
                 <option value="random">Casuale</option> </select>
        </div>
        <button id="start-setup-button">Inizia a Giocare</button>

        <div id="setup-help-sections">
             <details class="help-section">
                 <summary>Guida Rapida</summary>
                 <div class="help-content-wrapper">
                     <h4>Come Iniziare</h4> <p>Scegli <strong>Modalità</strong> e <strong>Tempo</strong>. Se giochi contro l'IA, scegli <strong>Difficoltà</strong> e <strong>Colore</strong>. Premi <em>Inizia a Giocare</em>.</p> <h4>Come Muovere</h4>
                     <p>Clicca su un tuo pezzo. Le caselle valide si illuminano (<em>pallini</em> per mosse, <em>cerchi rossi</em> per catture). Clicca sulla destinazione.</p> <h4>Controlli Partita</h4>
                     <p>Usa le schede (Tabs) a lato:</p>
                     <ul>
                         <li><strong>Partita:</strong> Vedi chi tocca, timer, e stato (scacco).</li> <li><strong>Storico:</strong> Rivedi le mosse (cliccabili). Usa i bottoni ⏮⏪⏩⏭ per navigare.</li> <li><strong>Controlli:</strong> <em>Abbandona</em>, <em>Proponi Patta</em>, <em>Nuova Partita</em>.</li> <li><strong>Stats:</strong> Vedi le tue statistiche di gioco.</li>
                     </ul>
                     <p>Clicca l'icona ⚙️ in alto a destra per attivare/disattivare il <strong>Tema Scuro</strong>.</p> </div>
             </details>
             <details class="help-section">
                 <summary>Movimento Pezzi</summary>
                 <div class="help-content-wrapper"> <p><strong>Re (K):</strong> Una casella in ogni direzione. Non in caselle minacciate.</p> <p><strong>Regina (Q):</strong> Orizzontale, verticale, diagonale, quante caselle vuole. Non scavalca.</p> <p><strong>Torre (R):</strong> Orizzontale, verticale, quante caselle vuole. Non scavalca.</p> <p><strong>Alfiere (B):</strong> Diagonale, quante caselle vuole. Non scavalca. Rimane su caselle dello stesso colore.</p> <p><strong>Cavallo (N):</strong> A "L" (2+1). Può scavalcare.</p> <p><strong>Pedone (P):</strong> Avanti di 1 (o 2 alla prima mossa). Cattura solo in diagonale avanti di 1. Vedi <em>Promozione</em> e <em>En Passant</em>.</p> </div>
             </details>
              <details class="help-section">
                  <summary>Regole Speciali</summary>
                  <div class="help-content-wrapper">
                     <h4>Scacco e Scaccomatto</h4> <p><strong>Scacco:</strong> Re minacciato. Devi parare.</p> <p><strong>Scaccomatto:</strong> Re minacciato e non puoi parare. Partita persa.</p> <h4>Patta (Draw)</h4>
                      <p>Partita pari per:</p>
                      <ul>
                          <li>Accordo reciproco.</li>
                           <li>Stallo (nessuna mossa legale, non sotto scacco).</li> <li>Materiale insufficiente (es. Re vs Re).</li>
                          <li>Regola 50 mosse (senza catture/mosse pedone).</li>
                          <li>Tripla ripetizione di posizione.</li> </ul>
                      <h4>Arrocco (Castling)</h4>
                      <p>Mossa Re (2 caselle) +</p> </div> </details> </div>
    </div>

    <div id="main-container">
        <div id="game-container">
            <div id="chessboard-wrapper">
                <div id="chessboard">
                    </div>
                </div>
            <div id="feedback-popup">Messaggio di feedback</div>
        </div>

        <div id="controls-tabs-container">
            <div class="tabs-nav">
                <button class="tab-button active" data-tab="game-info-content">Partita</button>
                <button class="tab-button" data-tab="history-content">Storico</button>
                <button class="tab-button" data-tab="controls-content">Controlli</button>
                <button class="tab-button" data-tab="stats-content">Stats</button>
            </div>

            <div id="game-info-content" class="tab-content active">
                <div id="status">È il turno del Bianco</div>
                <div class="player-info" id="player-white">
                    <span>Bianco</span>
                    <span class="timer" id="timer-white">10:00</span>
                </div>
                <div class="player-info" id="player-black">
                    <span>Nero</span>
                    <span class="timer" id="timer-black">10:00</span>
                </div>
                </div>

            <div id="history-content" class="tab-content">
                <ul id="move-list">
                    </ul>
                <div id="history-controls">
                    <button id="history-start" title="Inizio">⏮</button>
                    <button id="history-prev" title="Precedente">⏪</button>
                    <span id="history-status">Partita</span>
                    <button id="history-next" title="Successiva">⏩</button>
                    <button id="history-end" title="Fine">⏭</button>
                </div>
            </div>

            <div id="controls-content" class="tab-content">
                <button id="resign-button">Abbandona</button>
                <button id="draw-button">Proponi Patta</button>
                <button id="new-game-button">Nuova Partita</button>       <button id="restart-game-button">Ricomincia Partita</button>
            </div>
             <div id="stats-content" class="tab-content">
                <p>Vittorie Bianco: <span id="stats-white-wins">0</span></p>
                <p>Vittorie Nero: <span id="stats-black-wins">0</span></p>
                <p>Patte: <span id="stats-draws">0</span></p>
                <button id="reset-stats-button">Azzera Statistiche</button>
            </div>
        </div>
    </div> <div id="promotion-modal" class="modal">
        <div class="modal-content">
            <h3>Promozione Pedone</h3>
            <p>Scegli il pezzo:</p>
            <div id="promotion-choices">
                </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h3 id="game-over-title">Partita Terminata</h3>
            <p id="game-over-message">Messaggio risultato</p>
            <div class="modal-buttons">
                <button id="game-over-new-game">Nuova Partita</button>
                <button id="game-over-rematch">Rivincita</button> <button id="game-over-close">Chiudi</button>
            </div>
        </div>
    </div>

     <div id="draw-offer-modal" class="modal">
         <div class="modal-content">
             <h3>Proposta di Patta</h3>
             <p>L'avversario ha proposto la patta. Accetti?</p>
             <div class="modal-buttons">
                 <button id="accept-draw-button">Accetta</button>
                 <button id="decline-draw-button">Rifiuta</button>
             </div>
         </div>
     </div>

    <div id="theme-settings-modal" class="modal">
        <div class="modal-content">
            <h3>Impostazioni Tema</h3>
            <div class="theme-switch-wrapper">
                <label for="theme-switch">Tema Scuro:</label>
                <label class="theme-switch">
                    <input type="checkbox" id="theme-switch">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="modal-buttons">
                <button id="theme-settings-close">Chiudi</button>
            </div>
        </div>
    </div>
<script>
    document.addEventListener('DOMContentLoaded', () => {

        console.log("Chess App Initialized v5.2 - Debugging Start/AI/Settings"); // Versione aggiornata con debug

        // --- Elementi DOM ---
        let setupScreen, mainContainer, setupGameModeSelect, setupAiSettingsDiv, setupAiDifficultySelect,
            setupPlayerColorSelect, startSetupButton, chessboard, statusDisplay, moveListEl,
            newGameButton, restartGameButton, resignButton, drawButton,
            themeSwitch,
            /* Rimosso animationsToggle se non presente in HTML */
            promotionModal, promotionChoicesDiv, gameOverModal, gameOverTitle, gameOverMessage,
            gameOverNewGameBtn, gameOverRematchBtn, gameOverCloseBtn,
            whiteTimerDisplay, blackTimerDisplay, whitePlayerInfo, blackPlayerInfo,
            statsWhiteWinsEl, statsBlackWinsEl, statsDrawsEl,
            resetStatsButton, historyStartBtn, historyPrevBtn, historyNextBtn, historyEndBtn,
            historyStatusEl, tabsContainer,
            tabButtons, tabContents, settingsButton, themeSettingsModal,
            themeSettingsCloseBtn, feedbackPopup,
            // Elementi modal patta (ID corretti)
            drawOfferModal, drawOfferMessage, drawOfferAcceptBtn, drawOfferRejectBtn;

        // --- Costanti e Stato del Gioco ---
        const PIECE_IMAGES = { // Usare immagini SVG o set consistenti è meglio per lo scaling
            'K': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wk.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bk.png' },
            'Q': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wq.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bq.png' },
            'R': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wr.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/br.png' },
            'B': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wb.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bb.png' },
            'N': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wn.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bn.png' },
            'P': { white: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/wp.png', black: 'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/bp.png' }
        };
        const pieceValues = { 'P': 1, 'N': 3, 'B': 3.1, 'R': 5, 'Q': 9, 'K': 100 }; // Leggero +B
        const INITIAL_BOARD_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
        const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const RANKS = ['8', '7', '6', '5', '4', '3', '2', '1']; // Dall'alto verso il basso

        let boardState = []; // Array[64] con null o { type: 'P', color: 'white' }
        let currentPlayer = 'white';
        let selectedSquareIndex = null;
        let possibleMoves = []; // Array di oggetti mossa { from, to, flags, ... }
        let gameHistory = []; // Array di { fenBefore, fenAfter, moveNotation, move }
        let currentHistoryIndex = -1;
        let isReviewingHistory = false;
        let lastMove = null; // { from, to } dell'ultima mossa
        let kingInCheckIndex = { white: -1, black: -1 }; // Indice del re sotto scacco, -1 se non lo è
        let gameOver = false;
        let winner = null; // 'white', 'black', o null per patta
        let gameOverReason = ''; // 'Checkmate', 'Stalemate', 'Resignation', 'Timeout', '50 Move Rule', 'Repetition', 'Insufficient Material', 'Agreement'
        let gameMode = 'classic';
        let playerTypes = { white: 'human', black: 'human' };
        let playerColorChoice = 'white'; // Scelta del giocatore se gioca vs IA
        let aiDifficulty = 'medium'; // Difficoltà default
        let useAnimations = true; // Abilita animazioni di default
        let castlingRights = { K: true, Q: true, k: true, q: true }; // Diritti di arrocco
        let enPassantTarget = null; // Indice della casella bersaglio per en passant, o null
        let halfmoveClock = 0; // Contatore per regola 50 mosse
        let fullmoveNumber = 1; // Numero mossa completa
        let promotionData = null; // Dati temporanei per la promozione { move }
        let timers = { white: null, black: null }; // Tempo rimanente in secondi
        let timerInterval = null; // Riferimento a setInterval
        let lowTimeThreshold = 15; // Secondi sotto cui il timer diventa rosso
        let gameStats = { whiteWins: 0, blackWins: 0, draws: 0 }; // Struttura stats aggiornata
        let aiMoveTimeout = null; // Riferimento a setTimeout per mossa AI
        let gameSettingsSnapshot = {}; // Per ricordare le impostazioni all'avvio/rivincita
        let feedbackTimeout = null; // Riferimento a setTimeout per il popup di feedback
        let drawOfferedBy = null; // Chi ha proposto la patta ('white', 'black', o null)
        let activeDrawOfferState = null; // Memorizza l'offerta al momento della visualizzazione del modal

        // --- Funzioni di Supporto ---

        function selectDOMElements() {
            console.log("Selecting DOM elements...");
            setupScreen = document.getElementById('setup-screen');
            mainContainer = document.getElementById('main-container');
            setupGameModeSelect = document.getElementById('setup-game-mode');
            setupAiSettingsDiv = document.getElementById('setup-ai-settings');
            setupAiDifficultySelect = document.getElementById('setup-ai-difficulty');
            setupPlayerColorSelect = document.getElementById('setup-player-color'); // Aggiunto selettore colore giocatore
            startSetupButton = document.getElementById('start-setup-button');
            chessboard = document.getElementById('chessboard');
            statusDisplay = document.getElementById('status');
            moveListEl = document.getElementById('move-list');
            newGameButton = document.getElementById('new-game-button');
            restartGameButton = document.getElementById('restart-game-button'); // Bottone 'Ricomincia Partita'
            resignButton = document.getElementById('resign-button');
            drawButton = document.getElementById('draw-button');

            settingsButton = document.getElementById('settings-button');
            themeSettingsModal = document.getElementById('theme-settings-modal');
            themeSwitch = document.getElementById('theme-switch');
            themeSettingsCloseBtn = document.getElementById('theme-settings-close'); // Bottone chiusura modale tema

            // animationsToggle = document.getElementById('animations-toggle'); // Rimosso - non presente in HTML

            promotionModal = document.getElementById('promotion-modal');
            promotionChoicesDiv = document.getElementById('promotion-choices');

            gameOverModal = document.getElementById('game-over-modal');
            gameOverTitle = document.getElementById('game-over-title');
            gameOverMessage = document.getElementById('game-over-message');
            gameOverNewGameBtn = document.getElementById('game-over-new-game'); // Bottone "Nuova Partita" nel modal
            gameOverRematchBtn = document.getElementById('game-over-rematch'); // Bottone "Rivincita" nel modal
            gameOverCloseBtn = document.getElementById('game-over-close'); // Bottone "Chiudi" nel modal

            whiteTimerDisplay = document.getElementById('timer-white'); // ID Corretto
            blackTimerDisplay = document.getElementById('timer-black'); // ID Corretto
            whitePlayerInfo = document.getElementById('player-white'); // ID Corretto
            blackPlayerInfo = document.getElementById('player-black'); // ID Corretto

            statsWhiteWinsEl = document.getElementById('stats-white-wins'); // ID Corretto
            statsBlackWinsEl = document.getElementById('stats-black-wins'); // ID Corretto
            statsDrawsEl = document.getElementById('stats-draws'); // ID Corretto
            resetStatsButton = document.getElementById('reset-stats-button');
            // Correzione ID bottoni storico
            historyStartBtn = document.getElementById('history-start');
            historyPrevBtn = document.getElementById('history-prev');
            historyNextBtn = document.getElementById('history-next');
            historyEndBtn = document.getElementById('history-end');
            historyStatusEl = document.getElementById('history-status');

            tabsContainer = document.getElementById('controls-tabs-container');
            feedbackPopup = document.getElementById('feedback-popup');
            // Correzione ID elementi modal patta
            drawOfferModal = document.getElementById('draw-offer-modal');
            drawOfferMessage = drawOfferModal ? drawOfferModal.querySelector('p') : null; // Cerca il paragrafo nel modal
            drawOfferAcceptBtn = document.getElementById('accept-draw-button'); // ID Corretto HTML
            drawOfferRejectBtn = document.getElementById('decline-draw-button');// ID Corretto HTML

            // Verifica elementi critici
            const criticalElements = [
                setupScreen, mainContainer, setupGameModeSelect, startSetupButton, chessboard,
                statusDisplay, moveListEl, tabsContainer, newGameButton, restartGameButton,
                resignButton, drawButton, settingsButton, themeSettingsModal, themeSwitch, themeSettingsCloseBtn,
                gameOverModal, gameOverNewGameBtn, gameOverRematchBtn, gameOverCloseBtn,
                whiteTimerDisplay, blackTimerDisplay, statsWhiteWinsEl, statsBlackWinsEl, statsDrawsEl,
                historyStartBtn, historyPrevBtn, historyNextBtn, historyEndBtn, historyStatusEl,
                promotionModal, feedbackPopup
            ];
            const missingElements = criticalElements.filter(el => !el);
            if (missingElements.length > 0) {
                 // Trova i nomi delle variabili degli elementi mancanti (approccio semplice)
                 const elementNames = Object.entries({
                    setupScreen, mainContainer, setupGameModeSelect, startSetupButton, chessboard,
                    statusDisplay, moveListEl, tabsContainer, newGameButton, restartGameButton,
                    resignButton, drawButton, settingsButton, themeSettingsModal, themeSwitch, themeSettingsCloseBtn,
                    gameOverModal, gameOverNewGameBtn, gameOverRematchBtn, gameOverCloseBtn,
                    whiteTimerDisplay, blackTimerDisplay, statsWhiteWinsEl, statsBlackWinsEl, statsDrawsEl,
                    historyStartBtn, historyPrevBtn, historyNextBtn, historyEndBtn, historyStatusEl,
                    promotionModal, feedbackPopup
                }).filter(([_, value]) => !value).map(([key]) => key);
                console.error("Critical DOM elements missing during selection:", elementNames.join(', '));
                alert(`Errore critico: Impossibile trovare elementi fondamentali (${elementNames.join(', ')}). Ricarica la pagina.`);
             } else {
                 console.log("All critical DOM elements selected successfully.");
             }
             // Avviso per elementi popup patta (se non implementati in HTML)
            if (!drawOfferModal || !drawOfferAcceptBtn || !drawOfferRejectBtn) {
                 console.warn("Draw offer modal elements not found or incomplete. Dedicated draw offer popup might not function correctly without corresponding HTML/CSS.");
             }

            tabButtons = tabsContainer?.querySelectorAll('.tab-button');
            tabContents = tabsContainer?.querySelectorAll('.tab-content');
         }

        function addEventListeners() {
            console.log("Adding event listeners...");
            // Setup Screen
            if (startSetupButton) {
                startSetupButton.addEventListener('click', startGameFromSetup);
                console.log("Listener added to startSetupButton");
            } else console.error("startSetupButton not found, cannot add listener.");
            if (setupGameModeSelect) {
                setupGameModeSelect.addEventListener('change', handleSetupGameModeChange);
                console.log("Listener added to setupGameModeSelect");
            } else console.warn("setupGameModeSelect not found, cannot add listener.");

            // Chessboard
            if (chessboard) {
                chessboard.addEventListener('click', handleSquareClick);
                console.log("Listener added to chessboard");
            } else console.error("chessboard not found, cannot add listener.");

            // Controls Tab
            if (newGameButton) {
                newGameButton.addEventListener('click', () => {
                    console.log("New Game button clicked");
                    stopTimers();
                    clearTimeout(aiMoveTimeout);
                    setupInitialScreen(); // Torna alla schermata di setup
                });
                console.log("Listener added to newGameButton");
            }
            if (restartGameButton) {
                restartGameButton.addEventListener('click', () => {
                    console.log("Restart Game button clicked");
                    // Ricomincia la partita corrente con le stesse impostazioni
                    if (confirm("Sei sicuro di voler ricominciare la partita corrente?")) {
                        startNewGame();
                    }
                });
                console.log("Listener added to restartGameButton");
            }
            if (resignButton) {
                resignButton.addEventListener('click', handleResign);
                console.log("Listener added to resignButton");
            }
            if (drawButton) {
                drawButton.addEventListener('click', handleDrawOffer);
                console.log("Listener added to drawButton");
            }

            // Settings (Modal and Button)
            if (settingsButton) {
                settingsButton.addEventListener('click', () => {
                     console.log("Settings button clicked."); // DEBUG
                     if(themeSettingsModal) {
                         console.log("Theme settings modal found, attempting to show."); // DEBUG
                         themeSettingsModal.classList.add('visible');
                     } else {
                         console.error("Theme settings modal not found when clicking settings button!"); // DEBUG
                     }
                });
                 console.log("Listener added to settingsButton");
            } else {
                 console.error("Settings button not found, cannot add listener."); // DEBUG
            }

            if (themeSettingsCloseBtn) {
                themeSettingsCloseBtn.addEventListener('click', () => {
                    console.log("Theme settings close button clicked."); // DEBUG
                    if(themeSettingsModal) {
                        console.log("Theme settings modal found, attempting to close."); // DEBUG
                        closeModal(themeSettingsModal);
                    } else {
                        console.error("Theme settings modal not found when clicking close button!"); // DEBUG
                    }
                });
                 console.log("Listener added to themeSettingsCloseBtn");
            } else {
                 console.warn("Theme settings close button not found, cannot add listener."); // DEBUG
            }

            if (themeSwitch) {
                themeSwitch.addEventListener('change', () => {
                    applyTheme(themeSwitch.checked ? 'dark' : 'casino-green'); // Usa tema di default se non dark
                    saveSettings();
                });
                 console.log("Listener added to themeSwitch");
            }

            // Game Over Modal Buttons (Corretti)
            if (gameOverNewGameBtn) {
                gameOverNewGameBtn.addEventListener('click', () => {
                    closeModal(gameOverModal);
                    setupInitialScreen(); // Torna alla schermata di setup
                });
                 console.log("Listener added to gameOverNewGameBtn");
            }
            if (gameOverRematchBtn) {
                gameOverRematchBtn.addEventListener('click', () => {
                    closeModal(gameOverModal);
                    startNewGame(); // Riavvia con le stesse impostazioni (Rivincita)
                });
                 console.log("Listener added to gameOverRematchBtn");
            }
            if (gameOverCloseBtn) {
                gameOverCloseBtn.addEventListener('click', () => {
                    closeModal(gameOverModal);
                    // Opzionale: tornare al setup o non fare nulla
                    // setupInitialScreen();
                });
                 console.log("Listener added to gameOverCloseBtn");
            }

            // Stats Tab
            if (resetStatsButton) {
                resetStatsButton.addEventListener('click', resetStats);
                console.log("Listener added to resetStatsButton");
            }

            // History Tab
            if (historyStartBtn) {
                historyStartBtn.addEventListener('click', () => reviewHistory(0));
                console.log("Listener added to historyStartBtn");
            }
            if (historyPrevBtn) {
                historyPrevBtn.addEventListener('click', () => reviewHistory(currentHistoryIndex - 1));
                console.log("Listener added to historyPrevBtn");
            }
            if (historyNextBtn) {
                historyNextBtn.addEventListener('click', () => reviewHistory(currentHistoryIndex + 1));
                console.log("Listener added to historyNextBtn");
            }
            if (historyEndBtn) {
                historyEndBtn.addEventListener('click', () => reviewHistory(gameHistory.length > 0 ? gameHistory.length - 1 : 0));
                console.log("Listener added to historyEndBtn");
            }
            if (moveListEl) {
                moveListEl.addEventListener('click', handleMoveListClick);
                console.log("Listener added to moveListEl");
            }

            // Draw Offer Modal Buttons (Corretti)
            if (drawOfferAcceptBtn) {
                drawOfferAcceptBtn.addEventListener('click', handleAcceptDrawClick);
                console.log("Listener added to drawOfferAcceptBtn");
            } else console.warn("Draw Offer Accept Button listener NOT added - button not found.");
            if (drawOfferRejectBtn) {
                drawOfferRejectBtn.addEventListener('click', handleRejectDrawClick);
                console.log("Listener added to drawOfferRejectBtn");
            } else console.warn("Draw Offer Reject Button listener NOT added - button not found.");


            console.log("Base event listeners adding process completed.");
         }

        function handleSetupGameModeChange() {
             console.log("Handling game mode change..."); // DEBUG
             const mode = setupGameModeSelect?.value;
             if (!mode) {
                 console.warn("Game mode select value is empty."); // DEBUG
                 return;
             }
             console.log("Selected game mode:", mode); // DEBUG
             const isVsAI = mode.includes('vsAI') || mode.includes('_ai');
             console.log("Is Vs AI?", isVsAI); // DEBUG

             if (setupAiSettingsDiv) {
                  console.log("AI settings div found. Setting display to:", isVsAI ? 'flex' : 'none'); // DEBUG
                  setupAiSettingsDiv.style.display = isVsAI ? 'flex' : 'none';
             } else {
                 console.warn("setupAiSettingsDiv not found, cannot toggle visibility."); // DEBUG
             }
        }

        function setupInitialScreen() {
             console.log("Setting up initial screen...");
             if (!setupScreen || !mainContainer) {
                  console.error("Cannot setup initial screen: setupScreen or mainContainer missing.");
                 return;
              }
             setupScreen.style.display = 'flex';
             mainContainer.style.display = 'none';
             closeModal(gameOverModal);
             closeModal(promotionModal);
             closeModal(drawOfferModal);
             closeModal(themeSettingsModal); // Chiudi anche modale impostazioni
             resetGameState();

             // Riattiva la tab 'Partita'
             if (tabsContainer && tabButtons && tabContents) {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                let defaultTab = document.querySelector('.tab-button[data-tab="game-info-content"]');
                let defaultContent = document.getElementById('game-info-content');
                if (!defaultTab && tabButtons.length > 0) { // Fallback alla prima tab
                    defaultTab = tabButtons[0];
                    const firstTabId = defaultTab.dataset.tab;
                    if (firstTabId) {
                         defaultContent = document.getElementById(firstTabId);
                    }
                }
                if (defaultTab) defaultTab.classList.add('active');
                if (defaultContent) defaultContent.classList.add('active');
            }

             // Pre-seleziona mode/difficulty/playerColor salvati, se esistono
             if(setupGameModeSelect && gameSettingsSnapshot.gameMode) setupGameModeSelect.value = gameSettingsSnapshot.gameMode;
             if(setupAiDifficultySelect && gameSettingsSnapshot.aiDifficulty) setupAiDifficultySelect.value = gameSettingsSnapshot.aiDifficulty;
             if(setupPlayerColorSelect && gameSettingsSnapshot.playerColorChoice) setupPlayerColorSelect.value = gameSettingsSnapshot.playerColorChoice;

             console.log("Calling handleSetupGameModeChange from setupInitialScreen"); // DEBUG
             handleSetupGameModeChange(); // Aggiorna visibilità opzioni AI

             console.log("Returned to setup screen.");
         }

        function startGameFromSetup() {
             console.log("Attempting to start game from setup..."); // DEBUG
             if (!setupGameModeSelect || !setupAiDifficultySelect || !setupPlayerColorSelect || !startSetupButton || !setupScreen || !mainContainer) {
                 console.error("Cannot start game from setup: Critical elements missing.");
                 // Log which elements are missing
                 if (!setupGameModeSelect) console.error("Missing: setupGameModeSelect");
                 if (!setupAiDifficultySelect) console.error("Missing: setupAiDifficultySelect");
                 if (!setupPlayerColorSelect) console.error("Missing: setupPlayerColorSelect");
                 if (!startSetupButton) console.error("Missing: startSetupButton");
                 if (!setupScreen) console.error("Missing: setupScreen");
                 if (!mainContainer) console.error("Missing: mainContainer");
                 return;
             }
             console.log("All necessary setup elements found."); // DEBUG

             try {
                 gameMode = setupGameModeSelect.value;
                 aiDifficulty = setupAiDifficultySelect.value;
                 playerColorChoice = setupPlayerColorSelect.value; // Leggi scelta colore
                 console.log(`Read setup values - Mode: ${gameMode}, AI Diff: ${aiDifficulty}, Player Color: ${playerColorChoice}`); // DEBUG

                 // Determina chi è umano e chi è AI
                 const isVsAI = gameMode.includes('vsAI') || gameMode.includes('_ai');
                 if (isVsAI) {
                    let humanColor = playerColorChoice;
                    if (humanColor === 'random') {
                        humanColor = Math.random() < 0.5 ? 'white' : 'black';
                    }
                    playerTypes.white = (humanColor === 'white') ? 'human' : 'ai';
                    playerTypes.black = (humanColor === 'black') ? 'human' : 'ai';
                 } else {
                    playerTypes = { white: 'human', black: 'human' };
                 }
                 console.log(`Determined player types - White: ${playerTypes.white}, Black: ${playerTypes.black}`); // DEBUG

                 // Salva le impostazioni scelte nello snapshot per la rivincita
                 gameSettingsSnapshot = { gameMode, aiDifficulty, playerTypes, playerColorChoice };
                 saveSettings(); // Salva le impostazioni incluso lo snapshot
                 console.log("Game settings snapshot saved:", gameSettingsSnapshot); // DEBUG

                 console.log(`Starting game. Mode: ${gameMode}, AI: ${aiDifficulty}, Player Types: W=${playerTypes.white}, B=${playerTypes.black}`);
                 setupScreen.style.display = 'none';
                 mainContainer.style.display = 'flex';
                 console.log("Switched from setup screen to main container."); // DEBUG

                 if (chessboard && (!chessboard.hasChildNodes() || chessboard.children.length !== 64)) { // Controlla se la scacchiera è vuota o invalida
                    console.log("Chessboard UI missing or invalid, creating...");
                    createBoardUI();
                 } else if (!chessboard) {
                    console.error("Chessboard element missing, cannot create UI.");
                    return; // Cannot proceed without a chessboard
                 } else {
                    console.log("Chessboard UI seems okay."); // DEBUG
                 }

                 initTabs(); // Assicura che le tab siano inizializzate
                 console.log("Tabs initialized."); // DEBUG

                 console.log("Calling startNewGame..."); // DEBUG
                 startNewGame(); // Avvia la logica della nuova partita
                 console.log("startNewGame function call completed."); // DEBUG

             } catch (error) {
                 console.error("Error during startGameFromSetup:", error);
                 showFeedback(`Errore avvio partita: ${error.message}`, 5000);
                 // Attempt to return to setup screen on error
                 setupInitialScreen();
             }
        }

        function createBoardUI() {
            if (!chessboard) {
                 console.error("Cannot create board UI: chessboard is null.");
                 return;
             }
            chessboard.innerHTML = ''; // Pulisci prima di ricreare
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const index = rank * 8 + file;
                    const square = document.createElement('div');
                    square.classList.add('square', (rank + file) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.index = index;
                    chessboard.appendChild(square);
                }
            }
            console.log("Board UI Created");
         }

        function startNewGame() {
            console.log("startNewGame called."); // DEBUG
            // Usa lo snapshot per ripristinare le impostazioni corrette per questa partita/rivincita
            if (!gameSettingsSnapshot || !gameSettingsSnapshot.gameMode || !gameSettingsSnapshot.playerTypes) {
                console.warn("Game settings snapshot missing or incomplete, cannot start game reliably. Returning to setup.");
                setupInitialScreen();
                return;
            }

            // Ripristina le impostazioni dallo snapshot
            gameMode = gameSettingsSnapshot.gameMode;
            aiDifficulty = gameSettingsSnapshot.aiDifficulty;
            playerTypes = { ...gameSettingsSnapshot.playerTypes }; // Copia per sicurezza
            playerColorChoice = gameSettingsSnapshot.playerColorChoice;
            console.log("Starting new game (or rematch) with settings:", gameSettingsSnapshot);

            resetGameState(); // Resetta tutto lo stato logico del gioco

            // Imposta la posizione iniziale FEN
            fenToBoard(INITIAL_BOARD_FEN);
            parseFenDetails(INITIAL_BOARD_FEN); // Assicura che currentPlayer, castling, etc. siano corretti

            // Inizializza lo storico per la nuova partita
            gameHistory = [{ fenBefore: null, fenAfter: boardToFen(), moveNotation: 'Inizio Partita', move: null }];
            currentHistoryIndex = 0;
            isReviewingHistory = false;

            // Aggiorna l'intera UI
            renderBoard(); // Renderizza la scacchiera iniziale
            updateStatus(); // Imposta lo status iniziale (es. "Turno del Bianco")
            updateMoveList(); // Pulisce e prepara la lista mosse
            updateHistoryControls(); // Disabilita/abilita bottoni storico
            updatePlayerInfoHighlight(); // Evidenzia il giocatore corrente
            updateControlButtonsState(); // Abilita/disabilita bottoni controllo
            setupTimers(); // Imposta i timer basati su gameMode
            startTimers(); // Avvia il timer del primo giocatore (Bianco)

            checkInitialGameOver(); // Controlla casi rari di fine partita immediata

            // Se il primo giocatore è l'IA, fai partire la sua mossa
            if (!gameOver && playerTypes[currentPlayer] === 'ai') {
                triggerAIMove();
             }
             console.log("startNewGame finished."); // DEBUG
        }

        function resetGameState() {
            console.log("Resetting game state...");
            boardState = Array(64).fill(null);
            currentPlayer = 'white'; // Bianco inizia sempre (FEN iniziale)
            selectedSquareIndex = null;
            possibleMoves = [];
            // gameHistory resettato in startNewGame
            // currentHistoryIndex resettato in startNewGame
            // isReviewingHistory resettato in startNewGame
            lastMove = null;
            kingInCheckIndex = { white: -1, black: -1 };
            gameOver = false;
            winner = null;
            gameOverReason = '';
            drawOfferedBy = null; // Resetta offerta patta
            activeDrawOfferState = null; // Resetta stato offerta modal
            castlingRights = { K: true, Q: true, k: true, q: true }; // Da FEN iniziale
            enPassantTarget = null; // Da FEN iniziale
            halfmoveClock = 0; // Da FEN iniziale
            fullmoveNumber = 1; // Da FEN iniziale
            promotionData = null;
            timers = { white: null, black: null };
            stopTimers(); // Ferma eventuali timer precedenti
            clearTimeout(aiMoveTimeout); // Ferma eventuale pensiero IA
            aiMoveTimeout = null;
            closeModal(promotionModal);
            closeModal(gameOverModal);
            closeModal(drawOfferModal);
            closeModal(themeSettingsModal);

            // Resetta UI elementi specifici
            if(statusDisplay) { statusDisplay.textContent = 'In attesa di inizio...'; statusDisplay.className = 'status'; }
            if(moveListEl) moveListEl.innerHTML = '';
            clearHighlights(); // Rimuove selezioni/mosse possibili dalla logica
            if(whiteTimerDisplay) { whiteTimerDisplay.textContent = '--:--'; whiteTimerDisplay.classList.remove('low-time'); }
            if(blackTimerDisplay) { blackTimerDisplay.textContent = '--:--'; blackTimerDisplay.classList.remove('low-time'); }
            if(whitePlayerInfo) whitePlayerInfo.classList.remove('active');
            if(blackPlayerInfo) blackPlayerInfo.classList.remove('active');
            if(historyStatusEl) historyStatusEl.textContent = 'Partita'; // Testo default storico

            updateControlButtonsState(); // Aggiorna stato bottoni
            console.log("Game state reset complete.");
         }

        function updateControlButtonsState() {
            const isHumanTurn = playerTypes[currentPlayer] === 'human';
            const canControl = !gameOver && !isReviewingHistory;
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';

            if (resignButton) resignButton.disabled = !canControl || !isHumanTurn; // Solo umani possono abbandonare
            if (restartGameButton) restartGameButton.disabled = false; // Ricomincia è sempre possibile (magari chiedere conferma)
            if (newGameButton) newGameButton.disabled = false; // Nuova partita (setup) è sempre possibile

            if (drawButton) {
                // Un umano può PROPORRE se è il suo turno, non c'è offerta, e può controllare
                const canOfferDraw = canControl && isHumanTurn && drawOfferedBy === null;
                // Un umano può ACCETTARE se è il suo turno, c'è un'offerta DALL'AVVERSARIO, e può controllare
                const canAcceptDraw = canControl && isHumanTurn && drawOfferedBy === opponentColor;

                drawButton.disabled = !(canOfferDraw || canAcceptDraw);

                if (canAcceptDraw) {
                    drawButton.textContent = `Accetta Patta`; // Testo più semplice
                    drawButton.classList.add('accept-draw-ready'); // Evidenzia (opzionale, richiede CSS)
                } else {
                    drawButton.textContent = 'Proponi Patta';
                    drawButton.classList.remove('accept-draw-ready'); // Rimuovi evidenziazione
                }
            } else {
                // console.warn("Draw button not found during state update."); // Already warned if missing
            }
        }

        function showFeedback(message, duration = 2000) {
             if (!feedbackPopup) return;
             feedbackPopup.textContent = message;
             feedbackPopup.classList.add('visible');
             clearTimeout(feedbackTimeout); // Cancella timeout precedente
             feedbackTimeout = setTimeout(() => {
                 feedbackPopup.classList.remove('visible');
             }, duration);
         }

        function updateStatus() {
             if (!statusDisplay) return;
             statusDisplay.className = 'status'; // Reset classi
             let statusText = '';

             if (gameOver) {
                 statusDisplay.classList.add('game-over');
                 let message = '';
                 let feedbackMsg = '';
                 switch (gameOverReason) {
                     case 'Checkmate': message = `Scacco Matto! ${winner === 'white' ? 'Bianco' : 'Nero'} vince.`; break;
                     case 'Stalemate': message = 'Patta per Stallo!'; break;
                     case 'Resignation':
                         const resigningPlayer = winner === 'white' ? 'Nero' : 'Bianco'; // Chi ha abbandonato è l'opposto del vincitore
                         message = `${resigningPlayer} ha abbandonato. ${winner === 'white' ? 'Bianco' : 'Nero'} vince.`;
                         feedbackMsg = `${resigningPlayer} ha abbandonato.`;
                         break;
                     case 'Timeout': message = `Tempo scaduto! ${winner === 'white' ? 'Bianco' : 'Nero'} vince.`; break;
                     case '50 Move Rule': message = 'Patta per regola delle 50 mosse!'; break;
                     case 'Repetition': message = 'Patta per tripla ripetizione!'; break;
                     case 'Insufficient Material': message = 'Patta per materiale insufficiente!'; break;
                     case 'Agreement': message = 'Patta per Accordo!'; break;
                     case 'Critical Error': message = 'ERRORE CRITICO - Riavviare Partita'; break;
                     default: message = `Partita Terminata ${gameOverReason ? '('+gameOverReason+')' : ''}.`;
                 }
                 statusText = message;

                 // Mostra il modal di fine partita solo se non è già visibile
                 if (gameOverModal && !gameOverModal.classList.contains('visible')) {
                     if (gameOverTitle) gameOverTitle.textContent = "Partita Terminata";
                     if (gameOverMessage) gameOverMessage.textContent = message;
                     // Abilita/Disabilita Rivincita basato su se era una partita valida (opzionale)
                     if (gameOverRematchBtn) gameOverRematchBtn.disabled = (gameOverReason === 'Critical Error');
                     gameOverModal.classList.add('visible');
                 }

                 // Mostra feedback popup (tranne per abbandono già notificato)
                 if (feedbackMsg || (message && gameOverReason !== 'Resignation' && gameOverReason !== 'Agreement')) { // Non mostrare feedback duplicato per patta accordata
                      showFeedback(feedbackMsg || message, 5000);
                 }

                 // Aggiorna le statistiche (logica semplificata per 1v1 e vs AI)
                 if (gameOverReason !== 'Critical Error') {
                     if (winner === 'white') gameStats.whiteWins++;
                     else if (winner === 'black') gameStats.blackWins++;
                     else gameStats.draws++;
                     updateStatsUI();
                     saveStats();
                 }

             } else { // Gioco in corso
                 const turn = currentPlayer === 'white' ? 'Bianco' : 'Nero';
                 const isCheck = isKingInCheck(currentPlayer, boardState);
                 const opponentColor = currentPlayer === 'white' ? 'black' : 'white';

                 // Gestione Offerta Patta Nello Status (se il modal non è visibile o non esiste)
                 if (drawOfferedBy) {
                     if (playerTypes[currentPlayer] === 'human' && drawOfferedBy === opponentColor) {
                         // Mostra nello status solo se il modal NON è attivo/visibile (o non esiste)
                         if (!drawOfferModal || !drawOfferModal.classList.contains('visible')) {
                             statusText = `Offerta di Patta da ${opponentColor}. Turno del ${turn}. ${isCheck ? ' - SCACCO!' : ''}`;
                             statusDisplay.classList.add('draw-offer'); // Stile per offerta ricevuta
                         } else {
                             // Se il modal è attivo, lo status rimane normale
                             statusText = `Turno del ${turn}${isCheck ? ' - SCACCO!' : ''}`;
                         }
                     } else if (drawOfferedBy === currentPlayer) {
                         statusText = `Offerta di patta inviata. Turno del ${turn}. ${isCheck ? ' - SCACCO!' : ''}`;
                         statusDisplay.classList.add('draw-offer-sent'); // Stile per offerta inviata (opzionale)
                     } else {
                         // Offerta all'AI o stato inconsistente
                         statusText = `Turno del ${turn}${isCheck ? ' - SCACCO!' : ''}`;
                     }
                 } else { // Nessuna offerta patta attiva
                     statusText = `Turno del ${turn}${isCheck ? ' - SCACCO!' : ''}`;
                 }

                 // Applica classe 'check' se necessario
                 if (isCheck) {
                     statusDisplay.classList.add('check');
                     kingInCheckIndex[currentPlayer] = findKingIndex(currentPlayer, boardState);
                 } else {
                     kingInCheckIndex[currentPlayer] = -1;
                 }
                 // Rimuovi highlight scacco dall'avversario se non più sotto scacco
                  const previouslyCheckedOpponent = kingInCheckIndex[opponentColor];
                  if (previouslyCheckedOpponent !== -1 && !isKingInCheck(opponentColor, boardState)) {
                      kingInCheckIndex[opponentColor] = -1;
                      // Non forzare re-render qui, lo fa già la fine di updateStatus
                  }
             }

             // Aggiorna il testo dello status solo se cambiato
             if (statusDisplay && statusDisplay.textContent !== statusText) {
                 statusDisplay.textContent = statusText;
             }

             // Renderizza sempre la scacchiera alla fine per riflettere TUTTI gli stati
             renderBoard();
             updatePlayerInfoHighlight(); // Evidenzia giocatore attivo
             updateControlButtonsState(); // Aggiorna stato bottoni (importante per patta)
        }


        function chooseAIMove() {
            const availableMoves = generateValidMovesForColor(currentPlayer);
            if (availableMoves.length === 0) {
                console.log("AI has no valid moves.");
                return null; // checkGameOver dovrebbe gestire questo
            }
            let chosenMove = null;
            console.log(`AI (${aiDifficulty}) evaluating ${availableMoves.length} moves...`);

            switch (aiDifficulty) {
                case 'easy': // Mossa casuale
                    chosenMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    break;

                case 'medium': // Priorità cattura + casuale
                    const captureMovesMed = availableMoves.filter(move =>
                        move.flags?.includes('c') || move.flags?.includes('e') || move.flags?.includes('pc')
                    );
                    if (captureMovesMed.length > 0) {
                        // Scegli la cattura di maggior valore (semplice)
                        captureMovesMed.sort((a, b) => {
                            const valA = pieceValues[boardState[a.to]?.type] || (a.flags?.includes('e') ? pieceValues.P : 0); // Valore EP è Pedone
                            const valB = pieceValues[boardState[b.to]?.type] || (b.flags?.includes('e') ? pieceValues.P : 0);
                            return valB - valA; // Valore più alto prima
                       });
                        // Scegli tra le migliori N catture per un po' di varietà
                        const topNCaptures = captureMovesMed.slice(0, Math.min(captureMovesMed.length, 3));
                        chosenMove = topNCaptures[Math.floor(Math.random() * topNCaptures.length)];
                        console.log(`AI (Medium) chose capture: ${JSON.stringify(chosenMove)}`);
                    } else {
                        // Nessuna cattura, scegli una mossa casuale
                        chosenMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                        console.log(`AI (Medium) chose random move: ${JSON.stringify(chosenMove)}`);
                    }
                    break;

                case 'hard': // Usa la funzione di valutazione migliorata
                    let bestMoveHard = null;
                    let bestScore = -Infinity; // Per bianco (massimizza)
                    if (currentPlayer === 'black') bestScore = Infinity; // Per nero (minimizza)
                    const maximizingPlayer = currentPlayer === 'white';

                    // Aggiungi casualità se ci sono molte mosse simili
                    const candidateMoves = [];
                    for (const move of availableMoves) {
                        const tempBoard = copyBoardState(boardState);
                        try {
                           simulateMove(tempBoard, move); // Simula mossa AI
                           let score = evaluateBoardEnhanced(tempBoard, currentPlayer); // Usa valutazione potenziata
                           // Valuta la posizione *dopo* la mossa AI

                           // Aggiungi un piccolo bias casuale per varietà tra mosse simili
                           score += Math.random() * 0.05 - 0.025;

                           if (maximizingPlayer) { // Bianco cerca score più alto
                                if (score > bestScore) {
                                     bestScore = score;
                                     candidateMoves.length = 0; // Resetta candidati
                                     candidateMoves.push(move);
                                } else if (score === bestScore) {
                                     candidateMoves.push(move); // Aggiungi mosse con stesso punteggio
                                 }
                           } else { // Nero cerca score più basso (vantaggio nero = score < 0)
                                if (score < bestScore) {
                                   bestScore = score;
                                   candidateMoves.length = 0; // Resetta candidati
                                   candidateMoves.push(move);
                                } else if (score === bestScore) {
                                    candidateMoves.push(move); // Aggiungi mosse con stesso punteggio
                                }
                           }
                        } catch (simError) {
                           console.error("Error simulating move in AI Hard:", simError, move);
                        }
                    }
                    // Scegli casualmente tra le mosse con il punteggio migliore
                    if (candidateMoves.length > 0) {
                        chosenMove = candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                    } else {
                        // Fallback se nessuna mossa è stata valutata (improbabile)
                        chosenMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    }
                     console.log(`AI (Hard) chose move from ${candidateMoves.length} candidates with score ${bestScore}: ${JSON.stringify(chosenMove)}`);
                    break;

                default: // Fallback a facile
                    chosenMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    break;
            }

            // Log dettagliato della mossa scelta dall'AI
             try {
                 // Simula di nuovo solo per ottenere la notazione (non ideale ma ok per ora)
                 const tempBoardForNotation = copyBoardState(boardState);
                 simulateMove(tempBoardForNotation, chosenMove);
                 const notation = chosenMove ? getMoveNotationSAN(chosenMove, boardToFen(), tempBoardForNotation, currentPlayer) : 'N/A';
                 console.log(`AI (${aiDifficulty}) final choice: ${notation || JSON.stringify(chosenMove)}`);
             } catch(e){ console.error("Error logging AI move notation", e);}


            return chosenMove;
         }

        // Funzione di valutazione base (NON PIU' USATA DA HARD)
        function evaluateBoard(board) {
             let whiteMaterial = 0;
             let blackMaterial = 0;
             for (let i = 0; i < 64; i++) {
                 const piece = board[i];
                 if (!piece) continue;
                 const value = pieceValues[piece.type] || 0;
                 if (piece.color === 'white') whiteMaterial += value;
                 else blackMaterial += value;
             }
             // Rimuovi valore Re (non conta nel materiale)
             whiteMaterial -= pieceValues['K'];
             blackMaterial -= pieceValues['K'];
             return whiteMaterial - blackMaterial; // Positivo = Vantaggio Bianco
        }

        // Funzione di valutazione POTENZIATA (usata da AI Hard)
        function evaluateBoardEnhanced(board, playerToMove) {
            let whiteMaterial = 0;
            let blackMaterial = 0;
            let whitePositional = 0;
            let blackPositional = 0;
            let whiteMobility = 0;
            let blackMobility = 0;
            let whiteKingSafety = 0;
            let blackKingSafety = 0;
            const kingIndices = { white: -1, black: -1 };

            // 1. Materiale e posizione base
            for (let i = 0; i < 64; i++) {
                const piece = board[i];
                if (!piece) continue;
                const value = pieceValues[piece.type] || 0;
                const rank = Math.floor(i / 8);
                const file = i % 8;
                let positionBonus = 0;

                if (piece.type === 'K') {
                    kingIndices[piece.color] = i;
                } else { // Bonus posizionali non per il Re
                    // Controllo centro
                    if (rank >= 2 && rank <= 5 && file >= 2 && file <= 5) positionBonus += 0.1; // Centro allargato
                    if ((rank === 3 || rank === 4) && (file === 3 || file === 4)) positionBonus += 0.15; // Centro stretto
                    // Pedoni avanzati
                    if (piece.type === 'P') {
                         positionBonus += (piece.color === 'white' ? (6 - rank) : (rank - 1)) * 0.08;
                         // Bonus per pedoni connessi o passati (più complesso, omesso per ora)
                    }
                    // Cavalli su avamposti (semplificato)
                    if (piece.type === 'N') {
                        if ((piece.color === 'white' && rank <= 3) || (piece.color === 'black' && rank >= 4)) {
                             positionBonus += 0.1;
                        }
                    }
                    // Torri su colonne aperte/semi-aperte (semplificato)
                    if (piece.type === 'R') {
                         let fileBlocked = false;
                         for(let r=0; r<8; r++) { if (board[r*8+file]?.type === 'P') { fileBlocked = true; break; }}
                         if (!fileBlocked) positionBonus += 0.1; // Colonna aperta
                    }
                }

                if (piece.color === 'white') {
                    whiteMaterial += value;
                    whitePositional += positionBonus;
                } else {
                    blackMaterial += value;
                    blackPositional += positionBonus;
                }
            }

            // Rimuovi valore Re dal materiale
            whiteMaterial -= pieceValues['K'];
            blackMaterial -= pieceValues['K'];

            // 2. Mobilità (costoso, calcola solo per AI Hard)
            // Questo viene calcolato implicitamente valutando le mosse future nel minimax vero,
            // qui lo approssimiamo contando le mosse pseudo-legali dalla posizione corrente
            // NB: generatePseudoLegalMovesForPiece non è ottimizzata, questo rallenta!
             try {
                 for (let i = 0; i < 64; i++) {
                     const piece = board[i];
                     if (!piece || piece.type === 'P' || piece.type === 'K') continue; // Solo pezzi maggiori/minori
                     const moves = generatePseudoLegalMovesForPiece(i, board);
                     const mobilityBonus = moves.length * 0.02; // Piccolo bonus per mossa
                     if (piece.color === 'white') whiteMobility += mobilityBonus;
                     else blackMobility += mobilityBonus;
                 }
             } catch (mobErr) { console.warn("Error calculating mobility bonus:", mobErr); }


            // 3. Sicurezza del Re (semplificato)
            const checkKingSafety = (kingIndex, kingColor) => {
                if (kingIndex === -1) return 0;
                let safetyScore = 0;
                const oppColor = kingColor === 'white' ? 'black' : 'white';

                // Malus se sotto scacco
                if (isSquareAttacked(kingIndex, oppColor, board)) {
                     safetyScore -= 0.5;
                }
                // Malus se poche difese vicine o molti attaccanti vicini (area 3x3)
                const kingRank = Math.floor(kingIndex / 8);
                const kingFile = kingIndex % 8;
                let friendlyNeighbors = 0;
                let enemyNeighbors = 0;
                for(let dr=-1; dr<=1; dr++) {
                     for(let df=-1; df<=1; df++) {
                         if (dr===0 && df===0) continue;
                         const r = kingRank + dr;
                         const f = kingFile + df;
                         if (r >= 0 && r <= 7 && f >= 0 && f <= 7) {
                             const neighbor = board[r*8+f];
                             if (neighbor) {
                                 if(neighbor.color === kingColor) friendlyNeighbors++;
                                 else if (neighbor.color === oppColor) enemyNeighbors++;
                             }
                         }
                     }
                 }
                 if (enemyNeighbors > friendlyNeighbors) safetyScore -= (enemyNeighbors - friendlyNeighbors) * 0.1; // Malus per squilibrio attaccanti
                 if (friendlyNeighbors < 2) safetyScore -= 0.1; // Malus se molto esposto

                 return safetyScore;
             };
             whiteKingSafety = checkKingSafety(kingIndices.white, 'white');
             blackKingSafety = checkKingSafety(kingIndices.black, 'black');


            // Combina i punteggi
            const whiteScore = whiteMaterial + whitePositional + whiteMobility + whiteKingSafety;
            const blackScore = blackMaterial + blackPositional + blackMobility + blackKingSafety;

            // Ritorna la differenza (Positivo = Vantaggio Bianco)
            const finalScore = whiteScore - blackScore;
            //console.log(`Eval: Mat W ${whiteMaterial.toFixed(2)} B ${blackMaterial.toFixed(2)} | Pos W ${whitePositional.toFixed(2)} B ${blackPositional.toFixed(2)} | Mob W ${whiteMobility.toFixed(2)} B ${blackMobility.toFixed(2)} | King W ${whiteKingSafety.toFixed(2)} B ${blackKingSafety.toFixed(2)} ||| FINAL: ${finalScore.toFixed(2)}`)
            return finalScore;
         }


        function applyTheme(theme) {
            // Gestisce solo 'dark' e default 'casino-green'
            document.body.className = document.body.className.replace(/theme-\S+/g, '').trim();
            if (theme === 'dark') {
                document.body.classList.add(`theme-dark`);
            } else {
                // Assumi che se non è dark, è il tema di default (casino-green implicito da :root)
                // Non serve aggiungere una classe specifica se usi :root per il default
            }
            // document.body.classList.toggle('no-animations', !useAnimations); // Se vuoi supporto per disabilitare animazioni CSS
            if (themeSwitch) themeSwitch.checked = (theme === 'dark');
            else console.warn("Theme switch element not found during applyTheme");
            console.log("Applied theme:", theme, "Body classes:", document.body.className);
         }

        function saveSettings() {
             try {
                 if (!themeSwitch) {
                      console.warn("Cannot save settings: themeSwitch missing.");
                     return;
                  }
                localStorage.setItem('chessSettings', JSON.stringify({
                    theme: themeSwitch.checked ? 'dark' : 'casino-green', // Salva il tema corrente
                    // animations: useAnimations, // Salva stato animazioni se implementato
                    gameSettingsSnapshot // Salva anche lo snapshot dell'ultima partita configurata
                }));
                console.log("Settings saved:", localStorage.getItem('chessSettings'));
            } catch (e) { console.error("Failed to save settings to localStorage:", e); showFeedback("Errore nel salvataggio delle impostazioni.", 2500); }
        }

        function saveStats() {
             try {
                 localStorage.setItem('chessStats', JSON.stringify(gameStats));
                 console.log("Stats saved:", localStorage.getItem('chessStats'));
            }
             catch (e) { console.error("Failed to save stats to localStorage:", e); showFeedback("Errore nel salvataggio delle statistiche.", 2500); }
        }

        function loadSettingsAndStats() {
             try {
                const saved = localStorage.getItem('chessSettings');
                let loadedTheme = 'casino-green'; // Default
                // useAnimations = true; // Default
                gameSettingsSnapshot = {}; // Default snapshot

                if (saved) {
                    const settings = JSON.parse(saved);
                    loadedTheme = settings.theme || 'casino-green';
                    // useAnimations = settings.animations !== undefined ? settings.animations : true;
                    gameSettingsSnapshot = settings.gameSettingsSnapshot || {}; // Carica snapshot
                    console.log("Settings loaded:", settings);
                 } else { console.log("No saved settings found, using defaults."); }

                applyTheme(loadedTheme); // Applica tema caricato/default
                // if (animationsToggle) { // Se esistesse l'elemento per le animazioni
                //     animationsToggle.checked = useAnimations;
                //     document.body.classList.toggle('no-animations', !useAnimations);
                // }

                // Pre-compila i select nella schermata di setup (verranno usati se l'utente torna al setup)
                if (setupGameModeSelect && gameSettingsSnapshot.gameMode) setupGameModeSelect.value = gameSettingsSnapshot.gameMode;
                if (setupAiDifficultySelect && gameSettingsSnapshot.aiDifficulty) setupAiDifficultySelect.value = gameSettingsSnapshot.aiDifficulty;
                if (setupPlayerColorSelect && gameSettingsSnapshot.playerColorChoice) setupPlayerColorSelect.value = gameSettingsSnapshot.playerColorChoice;
                console.log("Calling handleSetupGameModeChange from loadSettingsAndStats"); // DEBUG
                handleSetupGameModeChange(); // Assicura visibilità corretta opzioni AI

                const savedStats = localStorage.getItem('chessStats');
                if (savedStats) {
                    const loadedStats = JSON.parse(savedStats);
                    // Assicura che la struttura sia corretta
                    gameStats = {
                        whiteWins: loadedStats.whiteWins || 0,
                        blackWins: loadedStats.blackWins || 0,
                        draws: loadedStats.draws || 0
                    };
                    console.log("Stats loaded:", gameStats);
                }
                else { gameStats = { whiteWins: 0, blackWins: 0, draws: 0 }; console.log("No saved stats found, starting from zero."); }
                updateStatsUI(); // Aggiorna la UI con le statistiche caricate/default

            } catch (e) {
                  console.error("Failed to load settings/stats from localStorage:", e);
                  showFeedback("Errore nel caricamento di impostazioni/statistiche.", 3000);
                  // Fallback ai default in caso di errore
                  applyTheme('casino-green');
                  // useAnimations = true;
                  // if(animationsToggle) animationsToggle.checked = true;
                  // document.body.classList.toggle('no-animations', !useAnimations);
                  gameStats = { whiteWins: 0, blackWins: 0, draws: 0 };
                  updateStatsUI();
                  gameSettingsSnapshot = {};
             }
        }

        function resetStats() {
             if (confirm("Sei sicuro di voler azzerare tutte le statistiche (Vittorie Bianco, Vittorie Nero, Patte)?")) {
                 gameStats = { whiteWins: 0, blackWins: 0, draws: 0 };
                 saveStats(); // Salva le statistiche azzerate
                 updateStatsUI(); // Aggiorna la UI
                 showFeedback("Statistiche azzerate.", 2000);
             }
        }

        function updateStatsUI() {
             // Usa gli ID corretti dall'HTML
             if (statsWhiteWinsEl) statsWhiteWinsEl.textContent = gameStats.whiteWins;
             // else console.warn("statsWhiteWinsEl not found for UI update."); // Already warned if missing
             if (statsBlackWinsEl) statsBlackWinsEl.textContent = gameStats.blackWins;
             // else console.warn("statsBlackWinsEl not found for UI update.");
             if (statsDrawsEl) statsDrawsEl.textContent = gameStats.draws;
             // else console.warn("statsDrawsEl not found for UI update.");
         }


        // --- Funzioni FEN e Scacchiera ---
        function fenToBoard(fen) {
            // Implementazione robusta come nella risposta precedente...
            if (typeof fen !== 'string') { fen = INITIAL_BOARD_FEN; console.error("Invalid FEN (not a string):", fen); showFeedback("Errore FEN, ripristino pos. iniziale.", 4000); }
            const parts = fen.split(' ');
            let position = parts[0];
            if (!position) { fen = INITIAL_BOARD_FEN; position = fen.split(' ')[0]; console.error("Invalid FEN (missing position part):", fen); showFeedback("Errore FEN, ripristino pos. iniziale.", 4000); }
            const rows = position.split('/');
            let newBoardState = Array(64).fill(null); let index = 0;
            try {
                if (rows.length !== 8) throw new Error(`FEN position must have 8 ranks (found ${rows.length})`);
                for (const row of rows) { let fileCount = 0;
                    for (const char of row) {
                        if (index >= 64) throw new Error("FEN string processed more than 64 squares");
                        if (/\d/.test(char)) { const emptySquares = parseInt(char);
                            if (isNaN(emptySquares) || emptySquares <= 0 || fileCount + emptySquares > 8) throw new Error(`Invalid empty squares count '${char}' at index ${index}, fileCount ${fileCount}`);
                            index += emptySquares; fileCount += emptySquares;
                        } else { const color = /[A-Z]/.test(char) ? 'white' : 'black';
                            const type = char.toUpperCase();
                            if (!PIECE_IMAGES[type]) throw new Error(`Invalid piece type: ${char}`);
                            newBoardState[index] = { type, color };
                            index++; fileCount++;
                        }
                    } if (fileCount !== 8) throw new Error(`Rank processed with ${fileCount} files, expected 8. Rank: "${row}"`);
                } if (index !== 64) throw new Error(`Processed ${index} squares, expected 64`);
                boardState = newBoardState; // Assegna solo se il parsing ha successo
            } catch (e) {
                 console.error("Error parsing FEN position:", e, `FEN: "${fen}"`);
                 showFeedback("Errore caricamento FEN. Ripristino pos. iniziale.", 5000);
                 // Se fallisce, ricarica il FEN iniziale e parsa quello
                 if (fen !== INITIAL_BOARD_FEN) {
                     fenToBoard(INITIAL_BOARD_FEN);
                     parseFenDetails(INITIAL_BOARD_FEN);
                 } else {
                     // Errore anche con FEN iniziale, stato critico
                     boardState = Array(64).fill(null); // Prova a resettare
                     console.error("CRITICAL: Failed to parse even initial FEN.");
                 }
            }
            return boardState; // Ritorna lo stato corrente
        }

        function parseFenDetails(fen) {
            // Implementazione robusta come nella risposta precedente...
            if (typeof fen !== 'string') { fen = INITIAL_BOARD_FEN; console.warn("Invalid FEN passed to parseFenDetails, using initial.");}
             const parts = fen.split(' ');
             if (parts.length < 6) {
                console.warn("Incomplete FEN, using defaults:", fen);
                currentPlayer = 'white';
                castlingRights = { K: false, Q: false, k: false, q: false };
                enPassantTarget = null;
                halfmoveClock = 0;
                fullmoveNumber = 1;
                return;
            }
             try {
                 const [position, turn, castling, enpassant, halfmove, fullmove] = parts;
                 currentPlayer = (turn === 'w') ? 'white' : 'black';
                 castlingRights = { K: castling.includes('K'), Q: castling.includes('Q'), k: castling.includes('k'), q: castling.includes('q') };
                 if (enpassant !== '-' && enpassant.length === 2 && FILES.includes(enpassant[0]) && RANKS.includes(enpassant[1])) {
                     const fileIndex = FILES.indexOf(enpassant[0]);
                     const rankIndex = RANKS.indexOf(enpassant[1]);
                     enPassantTarget = rankIndex * 8 + fileIndex;
                 } else {
                     enPassantTarget = null;
                     if (enpassant !== '-') console.warn(`Invalid en passant format/target in FEN: ${enpassant}`);
                 }
                 halfmoveClock = parseInt(halfmove);
                 fullmoveNumber = parseInt(fullmove);
                 if (isNaN(halfmoveClock) || halfmoveClock < 0) { console.warn(`Invalid halfmove clock in FEN: ${halfmove}, setting to 0.`); halfmoveClock = 0; }
                 if (isNaN(fullmoveNumber) || fullmoveNumber < 1) { console.warn(`Invalid fullmove number in FEN: ${fullmove}, setting to 1.`); fullmoveNumber = 1; }
             } catch (e) {
                 console.error("Error parsing FEN details:", e, `FEN: "${fen}"`);
                 // Fallback ai default
                 currentPlayer = 'white';
                 castlingRights = { K: false, Q: false, k: false, q: false }; enPassantTarget = null; halfmoveClock = 0;
                 fullmoveNumber = 1;
             }
        }

        function boardToFen() {
            // Implementazione robusta come nella risposta precedente...
             try { let fen = '';
                 let emptyCount = 0;
                 for (let rank = 0; rank < 8; rank++) {
                     for (let file = 0; file < 8; file++) { const index = rank * 8 + file;
                         const piece = boardState[index];
                         if (index < 0 || index > 63) throw new Error(`Invalid index ${index} during FEN generation`);
                         if (!piece) { emptyCount++; }
                         else { if (emptyCount > 0) { fen += emptyCount; emptyCount = 0; } const pieceChar = piece.type.toUpperCase();
                             if (!PIECE_IMAGES[pieceChar]) throw new Error(`Invalid piece type '${piece.type}' at index ${index}`);
                             fen += piece.color === 'white' ? pieceChar : pieceChar.toLowerCase();
                         }
                     } if (emptyCount > 0) { fen += emptyCount; emptyCount = 0; } if (rank < 7) { fen += '/'; }
                 } fen += ` ${currentPlayer === 'white' ? 'w' : 'b'}`;
                 let castlingStr = ''; if (castlingRights.K) castlingStr += 'K'; if (castlingRights.Q) castlingStr += 'Q';
                 if (castlingRights.k) castlingStr += 'k'; if (castlingRights.q) castlingStr += 'q'; fen += ` ${castlingStr || '-'}`;
                 let epStr = '-';
                 if (enPassantTarget !== null && typeof enPassantTarget === 'number' && enPassantTarget >= 0 && enPassantTarget < 64) {
                     const file = FILES[enPassantTarget % 8];
                     const rank = RANKS[Math.floor(enPassantTarget / 8)];
                     if (file && rank) { epStr = file + rank; }
                     else { console.warn(`Invalid enPassantTarget index ${enPassantTarget}, cannot convert to algebraic.`); }
                 } fen += ` ${epStr}`;
                 fen += ` ${halfmoveClock} ${fullmoveNumber}`; return fen;
             } catch (error) { console.error("Error generating FEN string:", error);
                 console.error("Current boardState:", JSON.stringify(boardState));
                 return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; // Fallback
             }
        }

        function renderBoard() {
             if (!chessboard) { console.error("Cannot render board: chessboard is missing."); return; }
             const squares = chessboard.children;
             if (squares.length !== 64) { console.error("Chessboard has wrong number of children. Recreating."); createBoardUI();
                 if (!chessboard || chessboard.children.length !== 64) return; } // Exit if recreation failed

             for (let i = 0; i < 64; i++) {
                 const square = squares[i];
                 if (!square) { console.error(`Square element missing at index ${i}`); continue; }
                 const pieceData = boardState[i]; // Stato logico

                 // Rimuovi highlights vecchi
                 square.classList.remove('selected', 'possible-move', 'capture-move', 'last-move-from', 'last-move-to', 'in-check');

                 // Sincronizza pezzo DOM con stato logico
                 const existingPieceEl = square.querySelector('.piece:not(.piece-captured)'); // Ignora pezzi in animazione cattura

                 if (pieceData) {
                     // Pezzo esiste nello stato logico
                     const expectedSrc = PIECE_IMAGES[pieceData.type]?.[pieceData.color];
                     if (!expectedSrc) {
                         console.error(`Missing image source for piece: ${pieceData.color} ${pieceData.type} at index ${i}`);
                         if (existingPieceEl) existingPieceEl.remove(); // Rimuovi se l'immagine non è valida
                         continue;
                     }
                     if (!existingPieceEl) { // Crea pezzo DOM se non esiste
                        const pieceEl = document.createElement('div');
                        pieceEl.classList.add('piece', pieceData.color);
                        const img = document.createElement('img');
                        img.src = expectedSrc;
                        img.alt = `${pieceData.color} ${pieceData.type}`;
                        pieceEl.appendChild(img);
                        square.appendChild(pieceEl);
                     } else { // Aggiorna pezzo DOM esistente se necessario
                        const img = existingPieceEl.querySelector('img');
                        // Aggiorna immagine se cambiata (es. promozione)
                        if (img && img.getAttribute('src') !== expectedSrc) {
                            img.src = expectedSrc;
                            img.alt = `${pieceData.color} ${pieceData.type}`;
                        }
                        // Aggiorna classe colore se cambiata (improbabile ma sicuro)
                        if (!existingPieceEl.classList.contains(pieceData.color)) {
                            existingPieceEl.className = `piece ${pieceData.color}`;
                        }
                        // Assicura che non sia nascosto o trasformato erroneamente
                        existingPieceEl.style.opacity = '';
                        existingPieceEl.style.transform = '';
                    }
                 } else {
                     // Pezzo non esiste nello stato logico: rimuovi pezzo DOM se presente e non è in animazione cattura
                     if (existingPieceEl) {
                        // console.warn(`Removing non-captured piece DOM at index ${i} in renderBoard as it's missing from state.`);
                        existingPieceEl.remove();
                     }
                     // Se c'è un pezzo con 'piece-captured', NON rimuoverlo qui,
                     // la logica in makeMove gestirà la sua rimozione dopo l'animazione/timeout.
                 }

                 // Applica nuovi highlights basati sullo stato attuale
                 if (i === selectedSquareIndex) square.classList.add('selected');

                 // Mostra mosse possibili (solo se è turno umano, non in review, non in attesa risposta patta)
                 const isHumanTurn = playerTypes[currentPlayer] === 'human';
                 const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
                 // Controllo se siamo in attesa di una risposta a una *nostra* offerta
                 // O se abbiamo appena ricevuto un'offerta e il modal non è ancora apparso/gestito
                 const waitingDrawInteraction = (drawOfferedBy === currentPlayer) || (drawOfferedBy === opponentColor);

                 if (selectedSquareIndex !== null && !isReviewingHistory && isHumanTurn && !waitingDrawInteraction && Array.isArray(possibleMoves)) {
                      const possibleMove = possibleMoves.find(m => m?.to === i);
                      if (possibleMove) {
                          const isCapture = possibleMove.flags?.includes('c') || possibleMove.flags?.includes('e') || possibleMove.flags?.includes('pc');
                          square.classList.add(isCapture ? 'capture-move' : 'possible-move');
                      }
                  }
                 // Mostra ultima mossa
                 if (lastMove && typeof lastMove.from === 'number' && typeof lastMove.to === 'number') {
                     if (i === lastMove.from) square.classList.add('last-move-from');
                     if (i === lastMove.to) square.classList.add('last-move-to');
                 }
                 // Mostra scacco
                 if (i === kingInCheckIndex.white || i === kingInCheckIndex.black) {
                     square.classList.add('in-check');
                 }
             }
         }

        function clearHighlights() {
            selectedSquareIndex = null;
            possibleMoves = [];
            // La rimozione effettiva delle classi CSS avviene in renderBoard()
            // Non serve farlo qui esplicitamente, basta chiamare renderBoard() dopo.
         }


        // --- Gestione Click e Mosse ---

        function handleSquareClick(event) {
            try {
                 const isHumanTurn = playerTypes[currentPlayer] === 'human';
                 const opponentColor = currentPlayer === 'white' ? 'black' : 'white';

                 // Impedisci interazione se: gioco finito, in review, non è turno umano, o c'è un modal visibile importante
                 const isModalVisible = promotionModal?.classList.contains('visible') ||
                                       gameOverModal?.classList.contains('visible') ||
                                       (drawOfferModal?.classList.contains('visible') && activeDrawOfferState !== null) || // Considera modal patta solo se attivo con offerta
                                       themeSettingsModal?.classList.contains('visible');

                 if (gameOver || isReviewingHistory || !isHumanTurn || isModalVisible) {
                    if (isReviewingHistory) {
                        reviewHistory(gameHistory.length - 1); // Clic sulla scacchiera durante review -> torna a Live
                        showFeedback("Tornato alla visualizzazione Live.", 1500);
                    } else if (isModalVisible && !isReviewingHistory && !gameOver) {
                         // Controlla specificamente il modal patta
                         if(drawOfferModal?.classList.contains('visible') && activeDrawOfferState !== null) {
                             showFeedback(`Rispondi all'offerta di patta per continuare.`, 2000);
                         } else if (promotionModal?.classList.contains('visible')) {
                             showFeedback(`Scegli il pezzo per la promozione.`, 2000);
                         } else {
                             showFeedback("Chiudi la finestra di dialogo per continuare.", 2000);
                         }
                    } else if (!isHumanTurn && !gameOver && !isReviewingHistory) {
                       // Non mostrare feedback continuo "È il turno di..."
                    }
                    clearHighlights(); // Deseleziona se si clicca durante stato non interattivo
                    if(!isModalVisible || !drawOfferModal?.classList.contains('visible')) renderBoard(); // Aggiorna UI se non c'è un modal bloccante aperto
                    return;
                 }

                const square = event.target.closest('.square');
                // Se si clicca fuori da una casella, deseleziona
                if (!square) { if(selectedSquareIndex !== null) { clearHighlights(); renderBoard(); } return; }

                const index = parseInt(square.dataset.index);
                if (isNaN(index) || index < 0 || index > 63) { console.error("Invalid square index:", square.dataset.index); return; }

                const piece = boardState[index];

                if (selectedSquareIndex === null) {
                    // Primo click: Seleziona un pezzo proprio
                    if (piece && piece.color === currentPlayer) {
                        selectedSquareIndex = index;
                        possibleMoves = generateValidMovesForPiece(index, boardState);
                        if (possibleMoves.length === 0) {
                             selectedSquareIndex = null; // Deseleziona subito se non ci sono mosse
                        }
                        renderBoard(); // Mostra selezione e mosse
                    }
                } else {
                    // Secondo click: Muovi o cambia selezione
                    if (index === selectedSquareIndex) {
                         // Click sullo stesso pezzo: deseleziona
                         clearHighlights();
                         renderBoard();
                    } else {
                         // Click su un'altra casella
                         if (!Array.isArray(possibleMoves)) {
                             console.error("handleSquareClick Error: possibleMoves is not an array.", possibleMoves); possibleMoves = [];
                         }
                         const move = possibleMoves.find(m => m?.to === index);
                         if (move) {
                             // Mossa valida trovata
                             clearHighlights(); // Pulisci highlights PRIMA di muovere

                             if (move.flags?.includes('p') || move.flags?.includes('pc')) {
                                 // Mossa di promozione: mostra modal
                                 promotionData = { move };
                                 showPromotionModal();
                             } else {
                                 // Mossa normale: esegui
                                 makeMove(move);
                             }
                         } else {
                             // Click non valido come mossa:
                             // Se è un *altro* pezzo proprio, cambia selezione
                             if (piece && piece.color === currentPlayer) {
                                 selectedSquareIndex = index;
                                 possibleMoves = generateValidMovesForPiece(index, boardState);
                                  if (possibleMoves.length === 0) {
                                      selectedSquareIndex = null; // Deseleziona
                                  }
                                 renderBoard();
                             } else {
                                 // Click su casella vuota o pezzo avversario (non come mossa): deseleziona
                                 clearHighlights();
                                 renderBoard();
                             }
                         }
                    }
                }
            } catch (error) {
                  console.error("Errore grave in handleSquareClick:", error);
                  showFeedback(`Errore click: ${error.message}. Ricarica se persiste.`, 4000);
                  clearHighlights(); renderBoard(); // Tenta di resettare UI click
            }
        }

        function showPromotionModal() {
             if (!promotionChoicesDiv || !promotionModal) { console.error("Promotion modal elements missing."); return; }
             promotionChoicesDiv.innerHTML = ''; // Pulisci scelte precedenti
             const piecesToPromote = ['Q', 'R', 'B', 'N'];
             piecesToPromote.forEach(type => {
                 const option = document.createElement('div');
                 option.classList.add('promotion-option', currentPlayer);
                 option.dataset.type = type; // Salva il tipo nel dataset
                 const img = document.createElement('img');
                 const imgSrc = PIECE_IMAGES[type]?.[currentPlayer];
                 if (!imgSrc) { console.error(`Missing image for promotion piece ${type} ${currentPlayer}`); return; }
                 img.src = imgSrc;
                 img.alt = `Promuovi a ${type}`;
                 option.appendChild(img);

                 // Aggiungi event listener UNA SOLA VOLTA qui
                 option.addEventListener('click', handlePromotionChoice);

                 promotionChoicesDiv.appendChild(option);
             });
             promotionModal.classList.add('visible');
        }

        // Funzione separata per gestire la scelta della promozione
        function handlePromotionChoice(event) {
            try {
                const chosenType = event.currentTarget.dataset.type;
                if (!chosenType) throw new Error("Promotion type not found in dataset.");

                if (promotionData?.move) {
                      const finalMove = { ...promotionData.move, promotion: chosenType };
                      // Aggiorna flag per notazione SAN corretta
                      if (finalMove.flags?.includes('pc')) { /* ok */ }
                      else if (finalMove.flags?.includes('p')) { finalMove.flags = finalMove.flags.replace('p', 'np').trim(); }
                      else { finalMove.flags = (finalMove.flags || '') + ' np'; } // Aggiungi flag 'np' (normal promotion) se mancante

                      closeModal(promotionModal); // Chiudi modal PRIMA di makeMove
                      promotionData = null;
                      makeMove(finalMove); // Esegui mossa DOPO chiusura modal

                } else {
                    console.error("Promotion data missing when choice was made.");
                    closeModal(promotionModal);
                    promotionData = null;
                    showFeedback("Errore promozione.", 3000);
                }
            } catch(error) {
                console.error("Error processing promotion choice:", error);
                showFeedback("Errore critico promozione.", 4000);
                closeModal(promotionModal);
                promotionData = null;
            }
        }


        function makeMove(move) {
           let fenBefore = '';
           const previousPlayer = currentPlayer;
           let boardStateBefore = []; // Per rollback in caso di errore
           const fromSquareEl = chessboard?.children[move.from];
           // Memorizza l'elemento DOM del pezzo catturato *prima* di aggiornare lo stato logico
           let capturedEl = null;
           let actualCaptureIndex = -1; // Indice del pezzo effettivamente catturato (per EP)

           try {
                // Annulla offerta patta (implicito con mossa)
                if (drawOfferedBy) {
                     console.log(`Draw offer by ${drawOfferedBy} implicitly rejected/cancelled by move from ${previousPlayer}.`);
                     drawOfferedBy = null;
                     activeDrawOfferState = null; // Resetta stato modal patta
                     closeModal(drawOfferModal); // Chiudi modal patta se aperto
                }

                console.log(`Attempting move: ${JSON.stringify(move)} by ${previousPlayer}`);
                boardStateBefore = copyBoardState(boardState); // Salva stato per rollback
                fenBefore = boardToFen(); // Salva FEN per storico

                const movingPieceData = boardState[move.from];
                if (!movingPieceData) throw new Error(`No piece at origin square ${move.from}`);
                if (movingPieceData.color !== previousPlayer) throw new Error(`Piece color mismatch at ${move.from}`);

                // --- Identifica Pezzo Catturato (Logica e DOM) ---
                const capturedPieceData = boardState[move.to]; // Pezzo sulla casella di destinazione
                const capturedPieceIndex = move.to;
                let enPassantCaptureIndex = -1;
                let capturedActualPieceData = capturedPieceData; // Il pezzo effettivamente catturato (può essere diverso per EP)

                if (move.flags?.includes('e')) { // Cattura En Passant
                    const epVictimRankOffset = previousPlayer === 'white' ? 8 : -8;
                    enPassantCaptureIndex = move.to + epVictimRankOffset;
                    if (enPassantCaptureIndex >= 0 && enPassantCaptureIndex < 64) {
                         capturedActualPieceData = boardState[enPassantCaptureIndex]; // Pedone catturato EP
                         if (capturedActualPieceData?.type !== 'P' || capturedActualPieceData?.color === previousPlayer) {
                            console.warn(`En passant inconsistency: Expected opponent Pawn at ${enPassantCaptureIndex}, found ${JSON.stringify(capturedActualPieceData)}`);
                            capturedActualPieceData = null; // Non considerarlo catturato se non è un pedone avversario
                            enPassantCaptureIndex = -1; // Annulla indice EP
                         } else {
                             actualCaptureIndex = enPassantCaptureIndex; // Indice del pezzo EP catturato
                             console.log(`EP Capture: Target index ${actualCaptureIndex}, Piece: ${JSON.stringify(capturedActualPieceData)}`);
                         }
                    } else {
                        console.error("Invalid enPassantCaptureIndex calculated:", enPassantCaptureIndex);
                        enPassantCaptureIndex = -1;
                    }
                } else if (capturedPieceData) { // Cattura normale
                    actualCaptureIndex = capturedPieceIndex; // Indice del pezzo catturato normally
                }

                // Ottieni riferimento all'elemento DOM del pezzo catturato (se esiste)
                capturedEl = (actualCaptureIndex !== -1) ? chessboard?.children[actualCaptureIndex]?.querySelector('.piece') : null;


                 // --- Aggiorna Stato Logico (boardState) ---
                const pieceToPlace = { type: move.promotion || movingPieceData.type, color: movingPieceData.color };
                boardState[move.to] = pieceToPlace; // Metti pezzo a destinazione
                boardState[move.from] = null; // Svuota origine

                // Rimuovi pedone catturato EP dallo stato logico
                if (move.flags?.includes('e') && enPassantCaptureIndex !== -1 && capturedActualPieceData) {
                     boardState[enPassantCaptureIndex] = null;
                     console.log(`EP Capture: Logically removed pawn at ${enPassantCaptureIndex}`);
                }

                // Gestisci movimento Torre per Arrocco nello stato logico
                if (move.flags?.includes('ks') || move.flags?.includes('qs')) {
                    const isKingSide = move.flags.includes('ks');
                    const rankIndex = previousPlayer === 'white' ? 7 : 0; // Riga 1 o 8
                    const rookFromIndex = rankIndex * 8 + (isKingSide ? 7 : 0); // h1/h8 o a1/a8
                    const rookToIndex = rankIndex * 8 + (isKingSide ? 5 : 3); // f1/f8 o d1/d8
                    const originalRook = boardStateBefore[rookFromIndex]; // Usa stato PRIMA della mossa per trovare la torre giusta
                    if (originalRook && originalRook.type === 'R' && originalRook.color === previousPlayer) {
                        boardState[rookToIndex] = originalRook; // Muovi torre logicamente
                        boardState[rookFromIndex] = null; // Svuota casa iniziale torre
                        console.log(`Castling: Moved rook logically from ${rookFromIndex} to ${rookToIndex}`);
                    } else {
                        console.error(`Castling logic error: Rook inconsistency. FEN Before: ${fenBefore}. Expected R at ${rookFromIndex}, found:`, originalRook);
                        throw new Error("Errore logico arrocco: torre non trovata o colore errato.");
                    }
                }

                // --- Aggiorna Stato Partita Globale (Castling Rights, EP Target, Clocks, Turno) ---
                const oldCastlingRights = {...castlingRights};
                const oldEnPassantTarget = enPassantTarget;

                // Diritti Arrocco persi per movimento Re o Torre
                if (movingPieceData.type === 'K') { if (previousPlayer === 'white') { castlingRights.K = castlingRights.Q = false; } else { castlingRights.k = castlingRights.q = false; } }
                if (movingPieceData.type === 'R') {
                    if (previousPlayer === 'white') { if (move.from === 56) castlingRights.Q = false; if (move.from === 63) castlingRights.K = false; } // a1=56, h1=63
                    else { if (move.from === 0) castlingRights.q = false; if (move.from === 7) castlingRights.k = false; } // a8=0, h8=7
                }
                // Diritti Arrocco persi se Torre viene CATTURATA sulla sua casa iniziale
                if (capturedActualPieceData?.type === 'R') { // Usa pezzo *effettivamente* catturato
                     const captureIdx = actualCaptureIndex; // Indice da cui è stato rimosso
                     if (captureIdx === 56 && boardStateBefore[56]?.color === 'white') castlingRights.Q = false; // Torre a1 bianca catturata
                     if (captureIdx === 63 && boardStateBefore[63]?.color === 'white') castlingRights.K = false; // Torre h1 bianca catturata
                     if (captureIdx === 0 && boardStateBefore[0]?.color === 'black') castlingRights.q = false; // Torre a8 nera catturata
                     if (captureIdx === 7 && boardStateBefore[7]?.color === 'black') castlingRights.k = false; // Torre h8 nera catturata
                }
                if (JSON.stringify(oldCastlingRights) !== JSON.stringify(castlingRights)) console.log("Castling rights changed:", oldCastlingRights, "->", castlingRights);

                // Nuovo En Passant Target (solo se pedone muove di 2)
                enPassantTarget = (movingPieceData.type === 'P' && Math.abs(move.from - move.to) === 16)
                                  ? (move.to + (previousPlayer === 'white' ? 8 : -8)) // Casella "dietro" il pedone mosso
                                  : null;
                if (oldEnPassantTarget !== enPassantTarget) console.log(`En passant target changed: ${oldEnPassantTarget ? indexToAlgebraic(oldEnPassantTarget) : '-'} -> ${enPassantTarget ? indexToAlgebraic(enPassantTarget) : '-'}`);

                // Clocks e Turno
                if (previousPlayer === 'black') { fullmoveNumber++; }
                const isPawnMove = movingPieceData.type === 'P';
                const isCaptureMove = capturedActualPieceData !== null; // Se c'è stato un pezzo effettivamente catturato (inclusa EP)
                halfmoveClock = (isPawnMove || isCaptureMove) ? 0 : halfmoveClock + 1; // Resetta se pedone o cattura
                currentPlayer = previousPlayer === 'white' ? 'black' : 'white'; // Cambia Turno

                // --- Aggiorna Storico ---
                lastMove = { from: move.from, to: move.to }; // Salva ultima mossa per highlight
                const fenAfter = boardToFen();
                const moveNotation = getMoveNotationSAN(move, fenBefore, boardState, previousPlayer);
                console.log(`Move Notation generated: ${moveNotation}`);

                // Aggiorna storico (rimuovi futuro se si era in review)
                if (isReviewingHistory) {
                    gameHistory = gameHistory.slice(0, currentHistoryIndex + 1);
                    isReviewingHistory = false;
                    if(historyStatusEl) historyStatusEl.textContent = 'Partita'; // Torna a 'Partita'
                }
                gameHistory.push({ fenBefore, fenAfter, moveNotation, move: {...move, fullmoveNumber, halfmoveClock} }); // Aggiungi mossa completa
                currentHistoryIndex = gameHistory.length - 1; // Vai all'ultimo stato

                 // --- Gestione Rimozione DOM Pezzo Catturato (DOPO aggiornamento stato) ---
                 if (capturedEl) { // Solo se c'era un elemento DOM da rimuovere
                     if (useAnimations) {
                         if (!capturedEl.classList.contains('piece-captured')) {
                             capturedEl.classList.add('piece-captured'); // Aggiungi classe per animazione CSS (fade out, scale down, etc.)
                             // Usa transitionend per rimuovere l'elemento DOPO l'animazione
                             const removeCapturedPiece = () => {
                                 if (capturedEl) { // Ricontrolla esistenza
                                     capturedEl.remove();
                                     console.log(`Captured piece DOM removed by transition/timeout at index ${actualCaptureIndex}`);
                                     // Forza un re-render minimo della casella svuotata se necessario
                                     // Potrebbe non servire se renderBoard() è chiamato dopo
                                     // const squareEl = chessboard?.children[actualCaptureIndex];
                                     // if(squareEl) squareEl.innerHTML = ''; // Modo rozzo per forzare aggiornamento
                                 }
                             };
                             // Listener una tantum per transitionend
                             capturedEl.addEventListener('transitionend', removeCapturedPiece, { once: true });
                             // Fallback con setTimeout (leggermente più lungo della transizione attesa)
                             setTimeout(removeCapturedPiece, 400); // Es: 300ms transizione + 100ms buffer
                         }
                     } else {
                         // Nessuna animazione: rimuovi subito il DOM del pezzo catturato
                         capturedEl.remove();
                         console.log(`Captured piece DOM removed immediately (no animation) at index ${actualCaptureIndex}`);
                     }
                 } else if (capturedActualPieceData) {
                      console.warn(`Logical capture at index ${actualCaptureIndex}, but no DOM element found to remove.`);
                 }

                // --- Aggiorna UI principale ---
                updateMoveList(); // Aggiorna lista mosse UI
                updateHistoryControls(); // Aggiorna bottoni storico

                // --- Controlla Fine Partita e Aggiorna Status COMPLETO ---
                checkGameOver(); // Controlla se questa mossa termina la partita
                updateStatus(); // Aggiorna display status, scacchiera (con stato logico aggiornato), highlights, bottoni, timer, ecc.
                // Questa chiamata a renderBoard() interna a updateStatus dovrebbe ora mostrare correttamente la casella vuota

                // --- Gestisci Prossima Mossa (Timer/AI) ---
                if (!gameOver) {
                    if (timers[currentPlayer] !== null) { stopTimers(); startTimers(); } // Riavvia timer per nuovo giocatore
                    else { stopTimers(); } // Ferma timer se modalità senza tempo
                    if (playerTypes[currentPlayer] === 'ai') { triggerAIMove(); } // Se tocca all'IA, falla muovere
                } else {
                    stopTimers(); // Ferma i timer se la partita è finita
                    console.log(`Game over detected after move by ${previousPlayer}. Reason: ${gameOverReason}`);
                    // updateStatus() ha già mostrato il modal di fine partita
                }

           } catch (error) {
                // --- BLOCCO CATCH MIGLIORATO ---
                console.error("--------------------------------------------------");
                console.error("CRITICAL ERROR in makeMove:", error.message, "\nStack:", error.stack);
                console.error("Move attempted:", move, " By:", previousPlayer);
                console.error("FEN before move:", fenBefore);
                console.error("Board state BEFORE (restore point):", JSON.stringify(boardStateBefore));
                console.error("Board state AFTER error:", JSON.stringify(boardState)); // Stato potenzialmente corrotto
                console.error("--------------------------------------------------");
                showFeedback(`Errore critico: ${error.message}. Tentativo ripristino...`, 5000);

                // Tenta il ripristino allo stato precedente
                try {
                    if (boardStateBefore && boardStateBefore.length === 64 && fenBefore) {
                        console.warn("Attempting state restoration...");
                        boardState = boardStateBefore; // Ripristina board logico
                        parseFenDetails(fenBefore); // Ripristina stato globale (turno, diritti, etc.)
                        drawOfferedBy = null; // Cancella offerta patta per sicurezza
                        activeDrawOfferState = null;

                        // Rimuovi mossa fallita dallo storico se era l'ultima
                        if (gameHistory.length > 0 && gameHistory[gameHistory.length - 1].fenBefore === fenBefore) {
                             gameHistory.pop();
                        }
                        currentHistoryIndex = gameHistory.length - 1;
                        lastMove = currentHistoryIndex > 0 ? gameHistory[currentHistoryIndex]?.move : null;
                        gameOver = false; winner = null; gameOverReason = ''; // Resetta game over
                        isReviewingHistory = false; // Assicura di non essere in review

                        clearHighlights();
                        renderBoard(); // Renderizza lo stato ripristinato
                        updateMoveList(); // Aggiorna storico UI
                        updateHistoryControls();
                        updateStatus(); // Aggiorna UI con stato ripristinato (turno, etc.)
                        stopTimers(); // Ferma i timer

                        console.warn("State restored to before the failed move.");
                        showFeedback("Stato precedente ripristinato.", 3500);
                    } else { throw new Error("Cannot restore: Invalid boardStateBefore or fenBefore."); }
                } catch (restoreError) {
                    console.error("!!! FAILED TO RESTORE STATE !!!:", restoreError);
                    showFeedback("Errore critico IRREVERSIBILE. Riavviare la partita.", 7000);
                    gameOver = true; winner = '?'; gameOverReason = 'Critical Error';
                    if(statusDisplay) statusDisplay.textContent = "ERRORE CRITICO - Riavvia";
                    stopTimers();
                    updateControlButtonsState(); // Aggiorna bottoni (disabilita controlli)
                    renderBoard(); // Prova a renderizzare lo stato (potrebbe essere corrotto)
                }
           }
        }
        // =============== FINE FUNZIONE makeMove ===============

        function triggerAIMove() {
             if (aiMoveTimeout) { console.warn("AI move trigger attempted while AI is already thinking."); return; } // Prevenzione chiamate multiple
             if (gameOver || isReviewingHistory || playerTypes[currentPlayer] !== 'ai') {
                 console.log("AI move trigger cancelled (game over, reviewing, or not AI turn).");
                 return;
             }

             console.log(`Triggering AI move for ${currentPlayer}...`);
             if(statusDisplay && !gameOver) {
                 // Non mostrare "sta pensando" se sta valutando la patta e c'è il modal (gestito altrove)
                 const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
                 const humanOfferedDraw = drawOfferedBy === opponentColor;
                 if (!humanOfferedDraw) { // Mostra solo se non c'è offerta attiva da valutare
                    statusDisplay.textContent = `L'IA (${currentPlayer}) sta pensando...`;
                 }
             }
             clearTimeout(aiMoveTimeout); // Sicurezza extra
             aiMoveTimeout = setTimeout(() => {
                 try {
                     if (gameOver || isReviewingHistory || playerTypes[currentPlayer] !== 'ai') { // Ricontrolla prima di muovere
                         console.log("AI move execution cancelled just before choosing move.");
                         aiMoveTimeout = null;
                         return;
                     }

                     const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
                     // --- Logica IA per valutazione offerta patta ---
                     if (drawOfferedBy === opponentColor) { // Se l'avversario umano ha offerto patta
                         // Usa valutazione potenziata per decidere
                         const currentEval = evaluateBoardEnhanced(boardState, currentPlayer); // Valuta posizione attuale
                         const aiIsBetter = (currentPlayer === 'white' && currentEval > 0.5) || (currentPlayer === 'black' && currentEval < -0.5);
                         const aiIsWorse = (currentPlayer === 'white' && currentEval < -0.8) || (currentPlayer === 'black' && currentEval > 0.8);
                         let acceptDraw = false;

                         if (aiIsWorse && Math.random() < 0.8) { // 80% accetta se in svantaggio netto
                             acceptDraw = true;
                             console.log(`AI accepts draw (eval: ${currentEval.toFixed(2)}, disadvantageous).`);
                         } else if (!aiIsBetter && !aiIsWorse && Math.random() < 0.4) { // 40% accetta se materiale quasi pari
                             acceptDraw = true;
                             console.log(`AI accepts draw (eval: ${currentEval.toFixed(2)}, even position, random).`);
                         } else if (aiIsBetter && Math.random() < 0.1) { // 10% accetta se in vantaggio (poco probabile)
                             acceptDraw = true;
                             console.log(`AI accepts draw (eval: ${currentEval.toFixed(2)}, advantageous, rare random).`);
                         } else {
                             acceptDraw = false;
                             console.log(`AI rejects draw (eval: ${currentEval.toFixed(2)}).`);
                         }

                         // Logica aggiuntiva: se poche mosse legali, più propenso ad accettare
                         const availableMovesCount = generateValidMovesForColor(currentPlayer, boardState).length;
                         if (availableMovesCount < 4 && !aiIsBetter && Math.random() < 0.6) {
                             acceptDraw = true;
                             console.log("AI considers accepting draw (few moves available). Eval:", currentEval.toFixed(2));
                         }

                         if (acceptDraw) {
                             acceptDrawOffer(); // Chiama funzione per accettare
                             aiMoveTimeout = null;
                             return; // Partita finita
                         } else {
                             console.log("AI rejects draw offer and proceeds to move.");
                             showFeedback("L'IA ha rifiutato l'offerta di patta.", 2500);
                             drawOfferedBy = null; // Offerta rifiutata
                             activeDrawOfferState = null;
                             updateStatus(); // Aggiorna status per rimuovere messaggio offerta
                         }
                     }
                     // --- Fine Logica Patta IA ---

                     // Scegli e fai la mossa
                     const chosenMove = chooseAIMove();
                     if (chosenMove) {
                         const movingPieceLogic = boardState[chosenMove.from]; // Prendi da boardState per sicurezza
                          // Gestione Promozione AI (sempre Regina)
                          if (movingPieceLogic?.type === 'P') {
                             const targetRank = Math.floor(chosenMove.to / 8);
                             const promotionRank = movingPieceLogic.color === 'white' ? 0 : 7;
                             if (targetRank === promotionRank) {
                                    chosenMove.promotion = 'Q'; // Promuovi a Regina
                                    // Aggiorna flag per notazione
                                    const isCapture = boardState[chosenMove.to] !== null || chosenMove.flags?.includes('e');
                                    let flags = chosenMove.flags || '';
                                    flags = flags.replace(/[cpe]/g,''); // Rimuovi vecchi flag correlati
                                    flags += isCapture ? ' pc' : ' np'; // Aggiungi flag promozione (con o senza cattura)
                                    chosenMove.flags = flags.trim();
                                    console.log("AI promotes pawn to Queen.");
                             }
                          }
                         makeMove(chosenMove); // Esegui la mossa scelta
                     } else {
                         console.error("AI couldn't find a move, but game not over? Checking again...");
                         checkGameOver(); // Ricalcola stato (dovrebbe trovare matto/stallo)
                         updateStatus(); // Aggiorna UI
                     }
                 } catch(error) {
                     console.error("Error during AI move execution:", error);
                     showFeedback("Errore mossa IA.", 4000);
                     updateStatus(); // Aggiorna status anche in caso di errore AI
                 } finally {
                     aiMoveTimeout = null; // Resetta timeout in ogni caso
                 }
             }, 500 + Math.random() * 500); // Delay variabile (0.5s - 1s) per realismo
        }


        function getMoveNotationSAN(move, fenBeforeMove, boardAfterMove, playerWhoMoved) {
            // Implementazione robusta come nella risposta precedente...
            try {
                if (!move || typeof move.from !== 'number' || typeof move.to !== 'number' || move.from < 0 || move.from > 63 || move.to < 0 || move.to > 63) { console.error("Invalid move for SAN:", move); return "ERR"; }
                if (typeof fenBeforeMove !== 'string' || fenBeforeMove.split(' ').length < 1) throw new Error(`Invalid fenBeforeMove: ${fenBeforeMove}`);

                // Crea board *prima* della mossa dal FEN
                const boardBeforeMove = Array(64).fill(null);
                const fillBoardFromFen = (fenPos) => {
                    const rows = fenPos.split('/');
                    let currentIdx = 0;
                    if (rows.length !== 8) throw new Error("FEN pos no 8 ranks");
                    for (const row of rows) { let fileCount = 0;
                        for (const char of row) { if (currentIdx > 63) throw new Error("FEN > 64");
                            if (/\d/.test(char)) { const skip = parseInt(char); if(isNaN(skip) || skip <= 0 || fileCount + skip > 8) throw new Error(`Invalid skip ${char}`);
                                currentIdx += skip; fileCount += skip; }
                            else { const color = /[A-Z]/.test(char) ? 'white' : 'black'; const type = char.toUpperCase(); if (!PIECE_IMAGES[type]) throw new Error(`Invalid piece ${char}`); boardBeforeMove[currentIdx] = { type, color };
                                currentIdx++; fileCount++; }
                        } if (fileCount !== 8) throw new Error(`Rank files ${fileCount} != 8`);
                    } if (currentIdx !== 64) throw new Error(`FEN squares ${currentIdx} != 64`);
                };
                fillBoardFromFen(fenBeforeMove.split(' ')[0]);

                const movingPiece = boardBeforeMove[move.from];
                if (!movingPiece) throw new Error(`No piece at origin ${move.from} (${indexToAlgebraic(move.from)}) in FEN: ${fenBeforeMove}`);
                if (movingPiece.color !== playerWhoMoved) throw new Error(`Piece color ${movingPiece.color} mismatch player ${playerWhoMoved}`);

                const pieceType = movingPiece.type.toUpperCase();
                const toSquare = indexToAlgebraic(move.to);
                const fromSquare = indexToAlgebraic(move.from);
                let notation = "";

                // Casi speciali: Arrocco
                if (move.flags?.includes('ks')) return "O-O";
                if (move.flags?.includes('qs')) return "O-O-O";

                // Pezzi diversi dal pedone
                if (pieceType !== 'P') {
                    notation += pieceType;
                    // Gestione ambiguità
                    try {
                        const otherMovers = findAmbiguousPieces(pieceType, movingPiece.color, move.to, move.from, fenBeforeMove);
                        if (otherMovers.length > 0) {
                            const fromFile = fromSquare[0];
                            const fromRank = fromSquare[1];
                            let needsFile = false; let needsRank = false;
                            for (const otherIndex of otherMovers) {
                                const otherAlg = indexToAlgebraic(otherIndex);
                                if (otherAlg[0] === fromFile) needsRank = true; // Altro pezzo sulla stessa colonna
                                else needsFile = true; // Altro pezzo su colonna diversa
                            }
                            if (needsFile && needsRank) notation += fromSquare; // Serve tutta la casa
                            else if (needsFile) notation += fromFile; // Basta la colonna
                            else if (needsRank) notation += fromRank; // Basta la riga
                        }
                    } catch (ambError) { console.error("Error during ambiguity check:", ambError); notation += "?"; }
                }

                // Gestione Cattura
                // Considera cattura se flag presente O se c'era pezzo avversario a destinazione PRIMA della mossa
                const targetPieceBefore = boardBeforeMove[move.to];
                const isCapture = move.flags?.includes('c') || move.flags?.includes('e') || move.flags?.includes('pc') || (targetPieceBefore && targetPieceBefore.color !== movingPiece.color);
                if (isCapture) {
                    if (pieceType === 'P' && notation.length === 0) notation += fromSquare[0]; // Aggiungi file per cattura pedone se non già ambiguo
                    notation += 'x';
                }

                // Casella di destinazione
                notation += toSquare;

                // Promozione
                if (move.promotion) { notation += '=' + move.promotion.toUpperCase(); }

                // Check e Checkmate (basati su boardAfterMove!)
                let isCheckAfterMove = false;
                let isCheckmateAfterMove = false;
                try {
                    if (!Array.isArray(boardAfterMove) || boardAfterMove.length !== 64) throw new Error("Invalid boardAfterMove for check/mate check.");
                    const opponentColor = playerWhoMoved === 'white' ? 'black' : 'white';
                    isCheckAfterMove = isKingInCheck(opponentColor, boardAfterMove); // Controlla scacco sull'avversario *dopo* la mossa
                    if (isCheckAfterMove) {
                        const opponentMoves = generateValidMovesForColor(opponentColor, boardAfterMove);
                        if (opponentMoves.length === 0) isCheckmateAfterMove = true; // Se è scacco e non ci sono mosse valide, è matto
                    }
                } catch(checkError) { console.error("Error during check/mate check for notation:", checkError); }

                if (isCheckmateAfterMove) notation += '#';
                else if (isCheckAfterMove) notation += '+';

                return notation;
            } catch (error) {
                console.error("!!! Error generating SAN:", error);
                console.error("Move:", move, " FEN before:", fenBeforeMove);
                // Fallback più descrittivo possibile
                const pieceTypeFallback = boardState[move?.from]?.type?.toUpperCase() || '?';
                const fromSqFallback = typeof move?.from === 'number' ? indexToAlgebraic(move.from) : "??";
                const toSqFallback = typeof move?.to === 'number' ? indexToAlgebraic(move.to) : "??";
                const isCaptureFallback = move?.flags?.includes('c') || move?.flags?.includes('e') || move?.flags?.includes('pc');
                return `${pieceTypeFallback}${fromSqFallback}${isCaptureFallback ? 'x':'-'}${toSqFallback}?`;
            }
        }

        function indexToAlgebraic(index) {
             if (typeof index !== 'number' || index < 0 || index > 63) return "??";
             const file = FILES[index % 8]; const rank = RANKS[Math.floor(index / 8)];
             return file + rank;
         }

        // Funzione helper per trovare pezzi ambigui (usata in getMoveNotationSAN)
        function findAmbiguousPieces(pieceType, pieceColor, toIndex, fromIndex, fenBeforeMove) {
             // Crea board *prima* della mossa dal FEN
             const boardBefore = Array(64).fill(null);
             try {
                 const fillBoardFromFen = (fenPos) => { /* ... implementazione robusta ... */
                     const rows = fenPos.split('/');
                     let currentIdx = 0;
                     if (rows.length !== 8) throw new Error("FEN pos no 8 ranks");
                     for (const row of rows) { let fileCount = 0;
                         for (const char of row) { if (currentIdx > 63) throw new Error("FEN > 64");
                             if (/\d/.test(char)) { const skip = parseInt(char); if(isNaN(skip) || skip <= 0 || fileCount + skip > 8) throw new Error(`Invalid skip ${char}`);
                                 currentIdx += skip; fileCount += skip; }
                             else { const color = /[A-Z]/.test(char) ? 'white' : 'black'; const type = char.toUpperCase(); if (!PIECE_IMAGES[type]) throw new Error(`Invalid piece ${char}`); boardBefore[currentIdx] = { type, color };
                                 currentIdx++; fileCount++; }
                         } if (fileCount !== 8) throw new Error(`Rank files ${fileCount} != 8`);
                     } if (currentIdx !== 64) throw new Error(`FEN squares ${currentIdx} != 64`);
                 };
                fillBoardFromFen(fenBeforeMove.split(' ')[0]);
             } catch (e) { console.error("Error parsing FEN in findAmbiguous:", e, fenBeforeMove); return []; } // Ritorna array vuoto se FEN non valido

             const ambiguousIndices = [];
             for (let i = 0; i < 64; i++) {
                 if (i === fromIndex) continue; // Salta il pezzo stesso
                 const piece = boardBefore[i];
                 if (piece && piece.type === pieceType && piece.color === pieceColor) {
                     // Controlla se questo pezzo alternativo può muovere legalmente a toIndex
                     const pseudoMoves = generatePseudoLegalMovesForPiece(i, boardBefore);
                     const candidateMove = pseudoMoves.find(m => m.to === toIndex);
                     if (candidateMove) {
                         // Verifica se la mossa è *legale* (non lascia il re sotto scacco)
                         try {
                             const tempBoard = copyBoardState(boardBefore);
                             simulateMove(tempBoard, candidateMove); // Simula la mossa alternativa
                             if (!isKingInCheck(pieceColor, tempBoard)) {
                                  ambiguousIndices.push(i); // Se la mossa è legale, aggiungi l'indice
                             }
                         } catch (simError) { console.error(`Error simulating ambiguous move ${i} to ${toIndex}:`, simError); }
                     }
                 }
             }
             return ambiguousIndices;
         }


        // --- Storico UI & Logica ---
        function updateMoveList() {
            if (!moveListEl) return;
            moveListEl.innerHTML = ''; // Pulisci lista
            let currentMoveNumber = 1;
            let historyEntryLi = null;
            // Determina il numero di mossa iniziale dal FEN della prima posizione (se disponibile)
            if (gameHistory.length > 0 && gameHistory[0].fenAfter) {
                 const initialFenParts = gameHistory[0].fenAfter.split(' ');
                 if (initialFenParts.length >= 6) {
                      const fenMoveNum = parseInt(initialFenParts[5]);
                      if (!isNaN(fenMoveNum) && fenMoveNum >= 1) {
                           currentMoveNumber = fenMoveNum;
                      }
                 }
            }

            for (let i = 1; i < gameHistory.length; i++) { // Inizia da 1 perché 0 è lo stato iniziale
                const entry = gameHistory[i];
                if (!entry || !entry.fenBefore || !entry.moveNotation || !entry.move) { // Verifica anche 'move'
                    console.warn(`Skipping invalid history entry at index ${i}:`, entry);
                    continue;
                }
                // Determina il turno *prima* della mossa i-esima
                const fenBeforeParts = entry.fenBefore.split(' ');
                const turnBefore = (fenBeforeParts.length > 1 && fenBeforeParts[1] === 'b') ? 'black' : 'white';
                const isWhiteMove = turnBefore === 'white';
                const moveNumberForEntry = entry.move.fullmoveNumber || Math.ceil(i / 2) || 1; // Usa numero mossa salvato o calcolato

                if (isWhiteMove) {
                    // Inizia una nuova riga per la mossa del bianco
                    historyEntryLi = document.createElement('li');
                    historyEntryLi.dataset.index = i; // Indice nello storico
                    // Crea span separati per numero, bianco, nero
                    const numSpan = `<span class="move-number">${moveNumberForEntry}.</span>`;
                    const whiteSpan = `<span class="move-notation white-move">${entry.moveNotation}</span>`;
                    const blackSpan = `<span class="move-notation black-move"></span>`; // Placeholder per nero
                    historyEntryLi.innerHTML = numSpan + whiteSpan + blackSpan;
                    moveListEl.appendChild(historyEntryLi);
                } else { // Mossa del Nero
                    if (historyEntryLi) {
                        // Aggiungi mossa del nero alla riga esistente
                         historyEntryLi.dataset.blackIndex = i; // Aggiungi anche indice per il nero
                        const blackMoveSpan = historyEntryLi.querySelector('.black-move');
                        if (blackMoveSpan) blackMoveSpan.textContent = entry.moveNotation;
                        // Il numero di mossa completo non incrementa qui
                    } else {
                        // Caso strano: mossa nera senza mossa bianca precedente (es. inizio da FEN nero)
                        console.warn(`History anomaly: Black move at index ${i} without preceding white move LI.`);
                        historyEntryLi = document.createElement('li');
                        historyEntryLi.dataset.blackIndex = i;
                        const numSpan = `<span class="move-number">${moveNumberForEntry}...</span>`; // Indica mossa nera
                        const whiteSpan = `<span class="move-notation white-move">...</span>`; // Placeholder bianco
                        const blackSpan = `<span class="move-notation black-move">${entry.moveNotation}</span>`;
                        historyEntryLi.innerHTML = numSpan + whiteSpan + blackSpan;
                        moveListEl.appendChild(historyEntryLi);
                    }
                    historyEntryLi = null; // Resetta per la prossima coppia
                }
            }
            highlightCurrentMoveInList(); // Evidenzia la mossa corrente
            // Scroll automatico alla fine solo se non si sta navigando
            if (!isReviewingHistory && moveListEl.lastChild) {
                moveListEl.scrollTop = moveListEl.scrollHeight;
             }
        }

        function highlightCurrentMoveInList() {
              if (!moveListEl) return;
              // Rimuovi highlight precedente
              moveListEl.querySelectorAll('li.highlighted-move').forEach(li => li.classList.remove('highlighted-move'));

              if (currentHistoryIndex > 0 && currentHistoryIndex < gameHistory.length) {
                    // Trova l'elemento LI che contiene l'indice corrente (sia esso bianco o nero)
                    const highlightedLi = moveListEl.querySelector(`li[data-index="${currentHistoryIndex}"], li[data-black-index="${currentHistoryIndex}"]`);
                    if (highlightedLi) {
                        highlightedLi.classList.add('highlighted-move');
                        // Scrolla l'elemento in vista se si sta navigando e non è visibile
                        if (isReviewingHistory) {
                            // Verifica se l'elemento è visibile nell'area scrollabile
                            const listRect = moveListEl.getBoundingClientRect();
                            const itemRect = highlightedLi.getBoundingClientRect();
                            const isVisible = itemRect.top >= listRect.top && itemRect.bottom <= listRect.bottom;
                            if (!isVisible) {
                                highlightedLi.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        }
                    }
              }
         }

        function handleMoveListClick(event) {
             const li = event.target.closest('li');
             if (!li) return;
             let targetIndex = null;
             // Determina su quale mossa (bianca o nera) si è cliccato o sulla riga
             const whiteIndex = li.dataset.index ? parseInt(li.dataset.index) : null;
             const blackIndex = li.dataset.blackIndex ? parseInt(li.dataset.blackIndex) : null;

             // Se si clicca specificamente sulla notazione di una mossa
             if (event.target.classList.contains('white-move') && whiteIndex !== null) {
                 targetIndex = whiteIndex;
             } else if (event.target.classList.contains('black-move') && blackIndex !== null) {
                 targetIndex = blackIndex;
             } else {
                  // Se si clicca sulla riga in generale, vai all'ultima mossa della riga (nera se esiste, altrimenti bianca)
                 targetIndex = blackIndex !== null ? blackIndex : whiteIndex;
             }

             // Naviga allo storico se l'indice è valido
             if (targetIndex !== null && targetIndex >= 0 && targetIndex < gameHistory.length) {
                  reviewHistory(targetIndex);
             } else {
                  console.warn("Could not determine valid history index from clicked li:", li.outerHTML);
             }
        }

        function reviewHistory(index) {
             // Assicura che l'indice sia nei limiti
             if (index < 0) index = 0;
             if (index >= gameHistory.length) index = gameHistory.length > 0 ? gameHistory.length - 1 : 0;

             console.log(`Reviewing history - Target index: ${index}`);
             currentHistoryIndex = index;
             // Si è in review se non si è all'ultimo stato della partita *attuale*
             isReviewingHistory = (index < gameHistory.length - 1);

             const stateData = gameHistory[index];
             if (!stateData) {
                 console.error(`History data missing at index ${index}. Cannot review.`);
                 showFeedback("Errore nello storico (dati mancanti).", 3000);
                 return;
             }
             const fenToLoad = stateData.fenAfter; // Carica lo stato DOPO la mossa all'indice richiesto
              if (!fenToLoad) {
                  console.error(`FEN After missing at history index ${index}`, stateData);
                  showFeedback("Errore nello storico (FEN mancante).", 3000);
                   // Prova a tornare all'ultimo stato valido se possibile
                   if (gameHistory.length > 0) reviewHistory(gameHistory.length - 1);
                   return;
              }

             try {
                 fenToBoard(fenToLoad); // Carica la posizione logica
                 parseFenDetails(fenToLoad); // Aggiorna stato globale (turno, diritti, etc.)

                 // Imposta l'ultima mossa per l'highlight (è la mossa che *ha portato* a questo stato)
                 lastMove = index > 0 ? gameHistory[index]?.move : null;

                 // Resetta stato scacco (verrà ricalcolato se necessario da isKingInCheck)
                 kingInCheckIndex = { white: -1, black: -1 };
                 drawOfferedBy = null; // Non ci sono offerte attive nello storico
                 activeDrawOfferState = null;

                 // Valuta se questa posizione storica era game over (solo per informazione, non cambia stato globale)
                 // const historicalGameOverInfo = checkGameOverConditionsForBoard(boardState, currentPlayer);

                 clearHighlights(); // Rimuovi selezioni/mosse possibili
                 stopTimers(); // Ferma i timer durante la review

                 updateMoveList(); // Aggiorna la lista e l'highlight
                 updateHistoryControls(); // Aggiorna i pulsanti di navigazione
                 updateStatus(); // Aggiorna la UI (scacchiera, status text, info giocatore)

                 // Aggiorna testo status storico
                 let historyStatusText = 'Partita'; // Default se si torna live
                 if (isReviewingHistory) {
                      const moveData = gameHistory[index]; // Mossa che ha portato a questo stato
                      const playerWhoMadeTheMove = index > 0 ? (moveData?.fenBefore?.split(' ')[1] === 'w' ? 'Bianco' : 'Nero') : null;
                      const moveNum = index === 0 ? 0 : (moveData?.move?.fullmoveNumber ?? Math.ceil(index / 2));
                      historyStatusText = index === 0
                                        ? 'Inizio Partita'
                                        : `Dopo ${moveNum}${playerWhoMadeTheMove === 'Bianco' ? '.' : '...'} ${moveData?.moveNotation || '??'}`;
                 } else if (index === 0) {
                       historyStatusText = 'Inizio Partita';
                 }
                 if(historyStatusEl) historyStatusEl.textContent = historyStatusText;
             } catch (loadError) {
                  console.error("Error loading state during history review:", loadError, `FEN: ${fenToLoad}`);
                  showFeedback("Errore visualizzazione storico.", 3000);
                   // Tenta di tornare live
                   if (gameHistory.length > 0) reviewHistory(gameHistory.length - 1);
             }
        }

        // Funzione di supporto per valutare fine partita per una data board (usata solo per info, non cambia stato globale)
        function checkGameOverConditionsForBoard(boardToCheck, playerWhoseTurn) {
             let isGameOverEval = false;
             let winnerEval = null;
             let reasonEval = '';
             try {
                 const validMoves = generateValidMovesForColor(playerWhoseTurn, boardToCheck);
                 if (validMoves.length === 0) {
                      isGameOverEval = true;
                      const isInCheckEval = isKingInCheck(playerWhoseTurn, boardToCheck);
                      if (isInCheckEval) {
                           winnerEval = playerWhoseTurn === 'white' ? 'black' : 'white';
                           reasonEval = 'Checkmate';
                      } else {
                           winnerEval = null;
                           reasonEval = 'Stalemate';
                      }
                 } else {
                      // Altri controlli (materiale, etc.) potrebbero essere aggiunti qui se necessario per la valutazione
                      if (hasInsufficientMaterial(boardToCheck)) {
                         isGameOverEval = true; winnerEval = null; reasonEval = 'Insufficient Material';
                      }
                 }
             } catch (evalError) { console.error("Error evaluating game over for board:", evalError, boardToCheck); }
             return { isGameOver: isGameOverEval, winner: winnerEval, reason: reasonEval };
         }


        function updateHistoryControls() {
             const historyLength = gameHistory.length;
             // currentHistoryIndex è l'indice dello stato ATTUALMENTE visualizzato (da 0 a length-1)
             const canGoBack = currentHistoryIndex > 0;
             const canGoForward = currentHistoryIndex < historyLength - 1;

             if(historyStartBtn) historyStartBtn.disabled = !canGoBack;
             if(historyPrevBtn) historyPrevBtn.disabled = !canGoBack;
             if(historyNextBtn) historyNextBtn.disabled = !canGoForward;
             if(historyEndBtn) historyEndBtn.disabled = !canGoForward;
         }

        function updatePlayerInfoHighlight() {
             if (!whitePlayerInfo || !blackPlayerInfo) return;
             const isWhiteActive = currentPlayer === 'white' && !gameOver && !isReviewingHistory;
             const isBlackActive = currentPlayer === 'black' && !gameOver && !isReviewingHistory;
             whitePlayerInfo.classList.toggle('active', isWhiteActive);
             blackPlayerInfo.classList.toggle('active', isBlackActive);
         }

        // --- Gestione Timer ---
        function setupTimers() {
            stopTimers(); // Ferma timer precedenti
            let timeInSeconds = null;
            if (gameMode?.includes('rapid_10')) timeInSeconds = 10 * 60;
            else if (gameMode?.includes('blitz_5')) timeInSeconds = 5 * 60;
            else if (gameMode?.includes('bullet_1')) timeInSeconds = 1 * 60;
            // Aggiungi altre modalità tempo qui se necessario

            if (timeInSeconds !== null && timeInSeconds > 0) {
                timers.white = timeInSeconds;
                timers.black = timeInSeconds;
                console.log(`Timers set to ${timeInSeconds}s for ${gameMode}`);
            } else {
                timers.white = null;
                timers.black = null;
                console.log(`Timers disabled for ${gameMode}`);
            }
            updateTimerDisplay(); // Mostra tempo iniziale o '--:--'
        }

        function startTimers() {
             if (timers[currentPlayer] === null || gameOver || isReviewingHistory || timerInterval !== null) {
                 if (timerInterval !== null) console.warn("startTimers called but interval exists.");
                 stopTimers(); // Assicura che non ci siano timer duplicati
                 return;
             }
             console.log(`Starting timer for ${currentPlayer} with ${timers[currentPlayer]}s.`);
             const playerToTick = currentPlayer; // Salva chi deve tickare
             timerInterval = setInterval(() => {
                  // Controlli robusti all'interno dell'intervallo
                  if (gameOver || isReviewingHistory || timers[playerToTick] === null || currentPlayer !== playerToTick || !timerInterval) {
                      console.log(`Timer for ${playerToTick} stopped implicitly.`);
                      stopTimers();
                      return;
                  }

                  timers[playerToTick]--; // Decrementa tempo
                  updateTimerDisplay(); // Aggiorna UI

                  if (timers[playerToTick] <= 0) {
                       console.log(`${playerToTick} timed out.`);
                      stopTimers();
                      if (!gameOver) { // Imposta game over solo se non lo è già per altri motivi
                           gameOver = true;
                           winner = playerToTick === 'white' ? 'black' : 'white'; // L'avversario vince
                           gameOverReason = 'Timeout';
                           updateStatus(); // Aggiorna stato e mostra modal
                      }
                  }
             }, 1000);
         }

        function updateTimerDisplay() {
             if (!whiteTimerDisplay || !blackTimerDisplay) return;
             const formatTime = (s) => {
                 if (s === null) return '--:--';
                 if (s < 0) s = 0; // Non mostrare tempi negativi
                 const min = Math.floor(s / 60);
                 const sec = s % 60;
                 return `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
             };
             whiteTimerDisplay.textContent = formatTime(timers.white);
             blackTimerDisplay.textContent = formatTime(timers.black);

             // Applica classe 'low-time'
             whiteTimerDisplay.classList.toggle('low-time', timers.white !== null && timers.white <= lowTimeThreshold && timers.white > 0);
             blackTimerDisplay.classList.toggle('low-time', timers.black !== null && timers.black <= lowTimeThreshold && timers.black > 0);
         }

        function stopTimers() {
             if (timerInterval) {
                 clearInterval(timerInterval);
                 timerInterval = null;
                 console.log("Timer stopped.");
             }
        }


        // --- Logica di Fine Partita e Controllo Scacco/Matto ---
        function checkGameOver() {
             // Non ricalcolare se già finita per motivi definitivi come accordo, abbandono, errore
             if (gameOver && (gameOverReason === 'Agreement' || gameOverReason === 'Resignation' || gameOverReason === 'Critical Error')) {
                return true;
             }
             if (isReviewingHistory) return false; // Non c'è game over durante la review

             let isGameOverNow = false;
             let currentWinner = null;
             let currentReason = '';
             try {
                 const validMoves = generateValidMovesForColor(currentPlayer, boardState);
                 if (validMoves.length === 0) {
                      isGameOverNow = true;
                      const isInCheck = isKingInCheck(currentPlayer, boardState);
                      if (isInCheck) {
                           currentWinner = currentPlayer === 'white' ? 'black' : 'white'; // L'avversario vince
                           currentReason = 'Checkmate';
                           console.log("Game Over Check: Checkmate!");
                      } else {
                           currentWinner = null; // Patta
                           currentReason = 'Stalemate';
                           console.log("Game Over Check: Stalemate!");
                      }
                 } else if (halfmoveClock >= 100) { // Regola 50 mosse (100 semimosse)
                      isGameOverNow = true; currentWinner = null; currentReason = '50 Move Rule'; console.log("Game Over Check: 50 Move Rule Draw!");
                 } else if (checkRepetition()) { // Tripla ripetizione
                      isGameOverNow = true; currentWinner = null; currentReason = 'Repetition'; console.log("Game Over Check: Repetition Draw!");
                 } else if (hasInsufficientMaterial(boardState)) { // Materiale insufficiente
                      isGameOverNow = true; currentWinner = null; currentReason = 'Insufficient Material'; console.log("Game Over Check: Insufficient Material Draw!");
                 }
             } catch (e) {
                 console.error("Error during game over check:", e);
                 // Non impostare game over per errore qui, potrebbe essere transitorio
             }

             if (isGameOverNow) {
                 if (!gameOver) { // Imposta lo stato globale solo se non era già game over
                     gameOver = true;
                     winner = currentWinner;
                     gameOverReason = currentReason;
                     stopTimers(); // Ferma i timer quando la partita finisce
                     console.log(`Game over state set: ${currentReason}, Winner: ${currentWinner}`);
                 } else {
                      // La partita era già finita (magari per timeout), non sovrascrivere motivo/vincitore
                      console.log(`Game over condition (${currentReason}) met, but game was already over (${gameOverReason}).`);
                 }
                 return true;
             }

             // Se nessun controllo ha dato esito positivo, la partita non è finita
             if (gameOver && !isGameOverNow && gameOverReason !== 'Resignation' && gameOverReason !== 'Agreement' && gameOverReason !== 'Timeout') {
                 console.warn(`Inconsistency: Global gameOver is true (${gameOverReason}), but checks indicate not game over. Resetting.`);
                 gameOver = false; // Tenta di correggere lo stato se non è un game over definitivo
                 winner = null;
                 gameOverReason = '';
             } else if (!isGameOverNow) {
                  gameOver = false; // Assicura che sia false se nessun check ha dato esito positivo
                  winner = null;
                  gameOverReason = '';
             }
             return false;
        }

        function checkRepetition() {
             const positionHistory = {};
             let repetitionCount = 0;
             const currentFen = boardToFen();
             if (!currentFen) { console.warn("checkRepetition: Cannot get current FEN."); return false; }
             const currentFenParts = currentFen.split(' ');
             if (currentFenParts.length < 4) { console.warn("checkRepetition: Cannot get key from current FEN", currentFen); return false; }
             // La chiave include posizione, turno, diritti arrocco, target EP
             const currentKey = `${currentFenParts[0]} ${currentFenParts[1]} ${currentFenParts[2]} ${currentFenParts[3]}`;

             // Controlla gli stati *dopo* ogni mossa nello storico, incluso lo stato corrente
             const historyToCheck = [...gameHistory.map(h => h.fenAfter), currentFen].filter(Boolean); // Aggiungi FEN corrente alla fine

             for (const fen of historyToCheck) {
                 const fenParts = fen.split(' ');
                 if (fenParts.length < 4) continue;
                 const key = `${fenParts[0]} ${fenParts[1]} ${fenParts[2]} ${fenParts[3]}`;
                 positionHistory[key] = (positionHistory[key] || 0) + 1;
             }

             repetitionCount = positionHistory[currentKey] || 0;

             if (repetitionCount >= 3) {
                 console.log(`Repetition! Position key ${currentKey} occurred ${repetitionCount} times.`);
                 return true;
             }
             return false;
         }

        function hasInsufficientMaterial(board) {
             // Implementazione robusta come nella risposta precedente...
            const pieces = { white: [], black: [] };
            let whiteBishops = { light: 0, dark: 0 }; let blackBishops = { light: 0, dark: 0 };
            let pieceCount = 0; // Conteggio pezzi esclusi i Re
            let hasMajorPieces = false; // Regina o Torre

            for (let i = 0; i < 64; i++) { const piece = board[i];
                if (!piece) continue;
                if (piece.type !== 'K') {
                    pieceCount++;
                    pieces[piece.color].push(piece.type);
                    if (piece.type === 'Q' || piece.type === 'R' || piece.type === 'P') {
                         // Se c'è una Regina, Torre o Pedone, non è materiale insufficiente
                         return false;
                    }
                    if (piece.type === 'B') {
                        const isLightSquare = (Math.floor(i / 8) + (i % 8)) % 2 === 0;
                        if (piece.color === 'white') { if (isLightSquare) whiteBishops.light++; else whiteBishops.dark++; }
                        else { if (isLightSquare) blackBishops.light++; else blackBishops.dark++; }
                    }
                }
            }
            // Casi base: K vs K, K vs K+N, K vs K+B
            if (pieceCount <= 1) {
                console.log("Insufficient Material: K vs K / K+N / K+B");
                return true;
            }
             // Caso K+B vs K+B (stesso colore)
            if (pieceCount === 2 && pieces.white.length === 1 && pieces.black.length === 1 && pieces.white[0] === 'B' && pieces.black[0] === 'B') {
                 if ((whiteBishops.light === 1 && blackBishops.light === 1) || (whiteBishops.dark === 1 && blackBishops.dark === 1)) {
                    console.log("Insufficient Material: K+B vs K+B (same color squares)");
                    return true;
                 }
             }
             // Aggiungere altri casi se necessario (es. K+N vs K+N) - raro

             return false; // Se non ricade nei casi sopra, assumi materiale sufficiente
        }

        function checkInitialGameOver() {
            // Chiamato solo all'inizio della partita
            if (checkGameOver()) {
                updateStatus(); // Aggiorna UI se la partita finisce subito (molto raro)
            }
        }

        function handleResign() {
             if (gameOver || isReviewingHistory || playerTypes[currentPlayer] !== 'human') return; // Solo umani possono
             const playerName = currentPlayer === 'white' ? 'Bianco' : 'Nero';
             if (confirm(`Sei sicuro di voler abbandonare? (${playerName})`)) {
                 const resigningPlayer = currentPlayer;
                 stopTimers();
                 gameOver = true;
                 winner = resigningPlayer === 'white' ? 'black' : 'white'; // L'avversario vince
                 gameOverReason = 'Resignation';
                 console.log(`${resigningPlayer} resigned.`);
                 // Mostra feedback PRIMA di updateStatus che potrebbe aprire il modal
                 showFeedback(`${playerName} ha abbandonato.`, 4000);
                 updateStatus(); // Aggiorna stato, mostra modal, aggiorna stats
             }
        }


        // --- Gestione Offerta/Accettazione Patta ---
        function handleDrawOffer() {
            if (gameOver || isReviewingHistory || playerTypes[currentPlayer] !== 'human') return; // Solo umani
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';

            // Caso 1: C'è un'offerta DALL'AVVERSARIO -> Accetta
            if (drawOfferedBy === opponentColor) {
                 console.log(`${currentPlayer} accepts draw offer via button.`);
                 acceptDrawOffer();
            }
            // Caso 2: NON c'è offerta -> Proponi
            else if (drawOfferedBy === null) {
                 console.log(`${currentPlayer} initiates draw offer via button.`);
                 proposeDraw();
            }
            // Caso 3: Hai GIA' proposto tu -> Informa
            else if (drawOfferedBy === currentPlayer) {
                 showFeedback("Hai già proposto la patta. Attendi risposta.", 2000);
             }
        }

        function proposeDraw() {
             // Puoi proporre solo se è il tuo turno, non c'è già un'offerta, non è finito, sei umano
             if (gameOver || isReviewingHistory || drawOfferedBy || playerTypes[currentPlayer] !== 'human') return;

             drawOfferedBy = currentPlayer; // Registra chi ha fatto l'offerta
             const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
             console.log(`${currentPlayer} offers a draw.`);
             showFeedback(`${currentPlayer === 'white' ? 'Bianco' : 'Nero'} propone la patta.`, 3500);
             updateStatus(); // Aggiorna status per mostrare "Offerta inviata" o simile
             updateControlButtonsState(); // Aggiorna stato bottone patta

             // Se l'avversario è l'IA, la valutazione avverrà in triggerAIMove
             if (playerTypes[opponentColor] === 'ai') {
                 console.log("Draw offer made to AI. AI will evaluate on its turn.");
             }
             // Se l'avversario è umano E esiste il modal popup, mostralo
             else if (playerTypes[opponentColor] === 'human' && drawOfferModal) {
                 showDrawOfferModal(); // Mostra il modal per l'avversario umano
             }
        }

         function showDrawOfferModal() {
              // Mostra il modal (RICHIEDE HTML/CSS e elementi selezionati)
              if (drawOfferModal && drawOfferMessage && drawOfferAcceptBtn && drawOfferRejectBtn && drawOfferedBy) {
                  drawOfferMessage.textContent = `${drawOfferedBy === 'white' ? 'Bianco' : 'Nero'} propone la patta. Accetti?`;
                  // Memorizza lo stato dell'offerta al momento dell'apertura del modal
                  activeDrawOfferState = { offeredBy: drawOfferedBy, offeredTo: (drawOfferedBy === 'white' ? 'black' : 'white') };
                  drawOfferModal.classList.add('visible');
                  // Blocca interazione scacchiera mentre il modal è aperto
                   if(chessboard) chessboard.style.pointerEvents = 'none';
               } else {
                   console.warn("Cannot show draw offer modal - elements missing or no valid offer pending.");
                   // Se mancano elementi, l'offerta verrà gestita solo tramite lo status text e il bottone principale
              }
         }

         // Chiamata dal bottone "Accetta" nel modal di patta
         function handleAcceptDrawClick() {
             acceptDrawOffer();
             // closeModal è chiamato internamente da acceptDrawOffer se ha successo
              // Riabilita click scacchiera se bloccati (fatto in closeModal)
         }
         // Chiamata dal bottone "Rifiuta" nel modal di patta
         function handleRejectDrawClick() {
             rejectDrawOffer();
             // closeModal è chiamato internamente da rejectDrawOffer se ha successo
              // Riabilita click scacchiera se bloccati (fatto in closeModal)
         }

         function rejectDrawOffer() {
             // Controlla usando lo stato memorizzato all'apertura del modal
             if (gameOver || isReviewingHistory || !activeDrawOfferState || playerTypes[activeDrawOfferState.offeredTo] !== 'human') {
                 console.warn("Cannot reject draw: No valid offer pending in modal state or not human turn.");
                 closeModal(drawOfferModal); // Chiudi modal se aperto per errore
                 return;
             }
             const rejectedBy = activeDrawOfferState.offeredTo;
             const offerer = activeDrawOfferState.offeredBy;

             console.log(`${rejectedBy} rejects draw offer from ${offerer}.`);
             showFeedback("Offerta di patta rifiutata.", 2500);
              drawOfferedBy = null; // Cancella l'offerta globale
              closeModal(drawOfferModal); // Chiudi modal e resetta activeDrawOfferState
              updateStatus(); // Aggiorna UI (status text, bottoni)
              updateControlButtonsState();
         }

        function acceptDrawOffer() {
            // Determina chi sta accettando (currentPlayer) e chi ha offerto (drawOfferedBy)
            const acceptor = currentPlayer; // Chi sta compiendo l'azione ora
            const offerer = drawOfferedBy; // Chi ha fatto l'offerta registrata
            const opponentColor = acceptor === 'white' ? 'black' : 'white';

            // Verifica fondamentale: ci DEVE essere un'offerta registrata e deve essere DALL'AVVERSARIO
            if (gameOver || isReviewingHistory || offerer !== opponentColor) {
                console.warn(`Cannot accept draw: Game Over=${gameOver}, Reviewing=${isReviewingHistory}, Offer By=${offerer}, Acceptor=${acceptor}, Expected Offerer=${opponentColor}`);
                // Se il modal era aperto ma l'offerta non è più valida, chiudilo e informa
                if (drawOfferModal?.classList.contains('visible')) {
                     closeModal(drawOfferModal);
                     showFeedback("L'offerta di patta non è più valida.", 2500);
                } else if (!gameOver && !isReviewingHistory && offerer !== null && offerer !== opponentColor) {
                     // Caso: Offerta esistente ma non dall'avversario (es. propria offerta?)
                     showFeedback("Non puoi accettare la tua stessa offerta.", 2500);
                }
                return;
            }

             console.log(`${acceptor} accepts the draw offer from ${offerer}.`);
             stopTimers();
             gameOver = true;
             winner = null; // Patta
             gameOverReason = 'Agreement'; // Motivo: Accordo
             drawOfferedBy = null; // Resetta offerta globale
             closeModal(drawOfferModal); // Chiudi modal se esiste e visibile

             // Mostra feedback PRIMA di updateStatus che apre il modal game over
             showFeedback("Patta accettata per accordo!", 4000);
             updateStatus(); // Aggiorna UI, mostra modal fine partita, aggiorna stats
             updateControlButtonsState(); // Aggiorna stato bottoni
        }


        // --- Funzioni Utilità Generali ---
        function closeModal(modal) {
            if (modal && modal.classList.contains('visible')) {
                console.log("Closing modal:", modal.id); // DEBUG
                modal.classList.remove('visible');
                // Se stavamo chiudendo il modal di patta, riabilita i click sulla scacchiera e resetta stato modal
                if (modal === drawOfferModal) {
                    activeDrawOfferState = null; // Resetta stato offerta modal
                    if (chessboard) {
                        chessboard.style.pointerEvents = 'auto';
                        console.log("Re-enabled chessboard pointer events."); // DEBUG
                    }
                }
                // Riabilita eventi anche per modal impostazioni
                if (modal === themeSettingsModal) {
                     if (chessboard) chessboard.style.pointerEvents = 'auto';
                     console.log("Re-enabled chessboard pointer events after closing settings."); // DEBUG
                }
            }
        }

        function initTabs() {
             if (!tabsContainer || !tabButtons || !tabContents) { console.error("Tab elements missing, cannot initialize."); return; }
             console.log("Initializing tabs..."); // DEBUG
             // Rimuovi vecchi listener per evitare duplicati e riaggiungi
             tabButtons.forEach(button => {
                 button.removeEventListener('click', handleTabClick); // Usa la funzione nominata
                 button.addEventListener('click', handleTabClick);
             });

             // Assicura che almeno una tab sia attiva all'inizio
             let activeTabFound = Array.from(tabButtons).some(btn => btn.classList.contains('active'));
             if (!activeTabFound) {
                  console.log("No active tab found, setting default."); // DEBUG
                  tabContents.forEach(content => content.classList.remove('active'));
                  tabButtons.forEach(btn => btn.classList.remove('active'));
                  // Tenta di attivare la tab 'Partita' di default
                  const defaultTabButton = tabsContainer.querySelector('.tab-button[data-tab="game-info-content"]');
                  const defaultTabContent = document.getElementById('game-info-content');
                  if (defaultTabButton && defaultTabContent) {
                       defaultTabButton.classList.add('active');
                       defaultTabContent.classList.add('active');
                       console.log("Default tab 'game-info-content' activated."); // DEBUG
                  } else if (tabButtons.length > 0 && tabContents.length > 0) {
                       // Fallback: attiva la prima tab trovata
                       tabButtons[0].classList.add('active');
                       tabContents[0].classList.add('active');
                       console.log(`Fallback: Activated first tab '${tabButtons[0].dataset.tab}'`); // DEBUG
                  } else {
                       console.warn("Could not activate any tab."); // DEBUG
                  }
             } else {
                 console.log("An active tab was already present."); // DEBUG
             }
             console.log("Tabs Initialized.");
         }

         function handleTabClick(event) { // Funzione nominata
             const clickedButton = event.currentTarget;
             if (!clickedButton) return;
             const tabId = clickedButton.dataset.tab;
             const contentToShow = document.getElementById(tabId);

             console.log(`Tab clicked: ${tabId}`); // DEBUG

             if (contentToShow && !clickedButton.classList.contains('active')) {
                  tabButtons.forEach(btn => btn.classList.remove('active'));
                  tabContents.forEach(content => content.classList.remove('active'));
                  clickedButton.classList.add('active');
                  contentToShow.classList.add('active');
                  console.log(`Activated tab content: ${tabId}`); // DEBUG
             } else if (!contentToShow) {
                  console.error(`Content for tab ID "${tabId}" not found.`);
             } else {
                  console.log(`Tab ${tabId} was already active.`); // DEBUG
             }
         }


        // --- Funzioni Generazione Mosse e Controllo Scacco ---
        // (Implementazioni robuste come nella risposta precedente)
        function copyBoardState(board) { if (!Array.isArray(board)) return []; return board.map(piece => piece ? { ...piece } : null); }
        function findKingIndex(color, board = boardState) { if (!Array.isArray(board)) { console.error("findKingIndex invalid board:", board); return -1; } return board.findIndex(p => p?.type === 'K' && p?.color === color); }
        function isSquareAttacked(squareIndex, attackerColor, board = boardState) {
             if (typeof squareIndex !== 'number' || squareIndex < 0 || squareIndex >= 64) return false;
             if (!Array.isArray(board)) { console.error("isSquareAttacked invalid board"); return false;}

             for (let i = 0; i < 64; i++) { const piece = board[i];
                 if (piece && piece.color === attackerColor) {
                     // Usiamo le mosse pseudo-legali perché non ci interessa se il re attaccante si scopre
                     const pseudoMoves = generatePseudoLegalMovesForPiece(i, board);
                     // Per i pedoni, la cattura è diversa dal movimento
                     if (piece.type === 'P') {
                         // Un pedone attacca le caselle diagonali *in avanti* rispetto alla sua direzione
                         const forwardDir = piece.color === 'white' ? -1 : 1;
                         const diag1 = i + forwardDir * 8 - 1; // Diagonale sinistra
                         const diag2 = i + forwardDir * 8 + 1; // Diagonale destra
                         // Controlla se la casella target è una delle caselle attaccate E se è sulla colonna giusta
                         if ((diag1 === squareIndex && (i%8 !== 0)) || (diag2 === squareIndex && (i%8 !== 7))) {
                            return true;
                         }
                     } else {
                          // Per gli altri pezzi, ogni mossa pseudo-legale verso la casella è un attacco
                          if (pseudoMoves.some(move => move.to === squareIndex)) return true;
                     }
                 }
             } return false;
         }
        function isKingInCheck(kingColor, board = boardState) { const kingIndex = findKingIndex(kingColor, board);
             if (kingIndex === -1) { /* console.warn(`King not found for ${kingColor} in isKingInCheck`); */ return false; } // Meno verboso
             const opponentColor = kingColor === 'white' ? 'black' : 'white'; return isSquareAttacked(kingIndex, opponentColor, board);
         }
        function generateValidMovesForColor(color, board = boardState) {
            const allValidMoves = [];
            if (!Array.isArray(board)) { console.error("generateValidMovesForColor invalid board"); return []; }
            const currentBoard = board; // Non serve copiare qui, lo fa generateValidMovesForPiece
            for (let i = 0; i < 64; i++) { if (currentBoard[i] && currentBoard[i].color === color) { allValidMoves.push(...generateValidMovesForPiece(i, currentBoard)); } }
            return allValidMoves;
         }
        function generateValidMovesForPiece(index, board = boardState) {
             const piece = board[index];
             if (!piece) return [];
             if (!Array.isArray(board)) { console.error("generateValidMovesForPiece invalid board"); return []; }

             const pseudoLegalMoves = generatePseudoLegalMovesForPiece(index, board);
             const validMoves = [];

             for (const move of pseudoLegalMoves) {
                 // Simula la mossa su una copia temporanea
                 const tempBoard = copyBoardState(board);
                 try {
                     simulateMove(tempBoard, move); // Esegue la mossa sulla copia
                     // Controlla se il *proprio* re è sotto scacco DOPO la mossa simulata
                     if (!isKingInCheck(piece.color, tempBoard)) {
                         validMoves.push(move); // Se non è sotto scacco, la mossa è valida
                     }
                 } catch (simError) {
                     // Non loggare errori di simulazione qui, sono spesso attesi per mosse non valide
                     // console.error(`Error simulating move ${JSON.stringify(move)} during validation:`, simError);
                 }
             }

             // Filtro aggiuntivo per arrocco: non si può arroccare attraverso lo scacco
             const finalValidMoves = validMoves.filter(move => {
                 if (move.flags?.includes('ks') || move.flags?.includes('qs')) {
                      const kingFrom = index;
                      const isKingSide = move.flags.includes('ks');
                      const pathSquare1 = isKingSide ? index + 1 : index - 1;
                      const kingTo = isKingSide ? index + 2 : index - 2; // Casella finale del re

                      const oppColor = piece.color === 'white' ? 'black' : 'white';

                      // Non si può arroccare se il re è SOTTO SCACCO ora (sulla board originale)
                      if (isKingInCheck(piece.color, board)) return false;

                      // Non si può arroccare se la casella DI PASSAGGIO o di ARRIVO del re è attaccata (sulla board originale)
                      if (isSquareAttacked(pathSquare1, oppColor, board) || isSquareAttacked(kingTo, oppColor, board)) return false;
                 }
                 return true; // Mossa valida se non è arrocco o se i controlli arrocco passano
             });
             return finalValidMoves; // Usa finalValidMoves se hai aggiunto il filtro arrocco
         }
         function simulateMove(tempBoard, move) {
            // Implementazione robusta come nella risposta precedente...
              const movingPiece = tempBoard[move.from];
              if (!movingPiece) throw new Error(`Simulate error: No piece at ${move.from}`);
              let epCaptureIndex = -1;
              let capturedPiece = null; // Pezzo effettivamente rimosso

              // Gestione Cattura EP
              if (move.flags?.includes('e')) {
                  const epVictimRankOffset = movingPiece.color === 'white' ? 8 : -8;
                  epCaptureIndex = move.to + epVictimRankOffset;
                  if (epCaptureIndex >= 0 && epCaptureIndex < 64) {
                       capturedPiece = tempBoard[epCaptureIndex];
                       if (capturedPiece?.type === 'P' && capturedPiece?.color !== movingPiece.color) {
                           tempBoard[epCaptureIndex] = null; // Rimuovi pedone EP
                       } else {
                           throw new Error(`Simulate EP error: Invalid index/target at ${epCaptureIndex}. Found: ${JSON.stringify(capturedPiece)}`);
                       }
                  } else {
                       throw new Error(`Simulate EP error: Invalid capture index ${epCaptureIndex}`);
                  }
              } else {
                  capturedPiece = tempBoard[move.to]; // Cattura normale
              }

              // Gestione Arrocco (Movimento Torre)
              if (move.flags?.includes('ks') || move.flags?.includes('qs')) {
                  const isKingSide = move.flags.includes('ks');
                  const rankIndex = movingPiece.color === 'white' ? 7 : 0;
                  const rookFrom = rankIndex * 8 + (isKingSide ? 7 : 0);
                  const rookTo = rankIndex * 8 + (isKingSide ? 5 : 3);
                  const rookPiece = tempBoard[rookFrom];
                  if (rookPiece?.type === 'R' && rookPiece?.color === movingPiece.color) {
                      tempBoard[rookTo] = rookPiece;
                      tempBoard[rookFrom] = null;
                  } else {
                      throw new Error(`Simulate castling error: Rook not found/wrong color at ${rookFrom}. Found: ${JSON.stringify(rookPiece)}`);
                  }
              }

              // Movimento Pezzo Principale
              tempBoard[move.to] = { type: move.promotion || movingPiece.type, color: movingPiece.color };
              tempBoard[move.from] = null;
              return tempBoard; // Ritorna la board modificata
          }
          function generatePseudoLegalMovesForPiece(index, board = boardState) {
             // Implementazione robusta come nella risposta precedente...
            const piece = board[index];
            if (!piece) return [];
            if (!Array.isArray(board)) { /* console.error("generatePseudoLegalMoves invalid board"); */ return []; } // Meno verboso

            const moves = [];
            const { type, color } = piece;
            const rank = Math.floor(index / 8);
            const file = index % 8;
            const oppColor = color === 'white' ? 'black' : 'white';

            // Funzione interna per aggiungere mosse, gestisce catture e blocchi
            const addMove = (to, flags = '') => {
                 if (to < 0 || to > 63) return { blocksLine: true }; // Fuori scacchiera, blocca linea per pezzi scorrevoli

                 const targetPiece = board[to];
                 let finalFlags = flags;
                 let blocksLine = true; // Di default, la casella blocca (se pezzo amico o cattura)

                 if (!targetPiece) { // Casella vuota
                     blocksLine = false; // Non blocca la linea per pezzi scorrevoli
                     let moveToAdd = { from: index, to, flags: finalFlags.trim() };
                     // Controlla se è una mossa di promozione (pedone arriva all'ultima riga)
                     if (type === 'P') {
                          const promotionRank = color === 'white' ? 0 : 7;
                          if (Math.floor(to / 8) === promotionRank) {
                               moveToAdd.flags = (moveToAdd.flags + ' p').trim(); // Aggiunge flag 'p' (promozione)
                          }
                     }
                     moves.push(moveToAdd);
                 } else if (targetPiece.color === oppColor) { // Casella con pezzo avversario (cattura)
                     blocksLine = true; // Blocca la linea
                     finalFlags = (finalFlags + ' c').trim(); // Aggiunge flag 'c' (cattura)
                     let moveToAdd = { from: index, to, flags: finalFlags };
                     // Controlla se è una cattura con promozione
                      if (type === 'P') {
                          const promotionRank = color === 'white' ? 0 : 7;
                          if (Math.floor(to / 8) === promotionRank) {
                               // Rimuove 'c' e 'p', aggiunge 'pc' (promotion capture)
                               moveToAdd.flags = (moveToAdd.flags.replace('c','').replace('p','').trim() + ' pc').trim();
                          }
                      }
                     moves.push(moveToAdd);
                 } else { // Casella con pezzo amico
                     blocksLine = true; // Blocca la linea
                 }
                 return { blocksLine }; // Ritorna se la casella blocca ulteriori mosse sulla linea
            };

            // Funzione interna per generare mosse lineari (Torre, Alfiere, Regina)
             const addLinearMoves = (directions) => {
                  for (const [dr, df] of directions) { // Per ogni direzione (delta riga, delta colonna)
                      for (let i = 1; ; i++) { // Muoviti lungo la direzione
                          const currentRank = rank + i * dr;
                          const currentFile = file + i * df;
                          // Controlla se siamo ancora dentro la scacchiera
                          if (currentRank < 0 || currentRank > 7 || currentFile < 0 || currentFile > 7) break; // Fuori scacchiera, interrompi questa direzione
                          // Prova ad aggiungere la mossa alla casella corrente
                          const result = addMove(currentRank * 8 + currentFile);
                          // Se la casella blocca (pezzo amico o cattura), interrompi per questa direzione
                          if (result.blocksLine) break;
                      }
                  }
             };

             switch (type) {
                 case 'P': // Pedone
                     const forwardDir = color === 'white' ? -1 : 1; // Direzione avanti
                     const startRank = color === 'white' ? 6 : 1; // Riga di partenza
                     const promotionRank = color === 'white' ? 0 : 7; // Riga di promozione

                     // Mossa avanti di 1
                     const oneStep = index + forwardDir * 8;
                     if (oneStep >= 0 && oneStep < 64 && !board[oneStep]) { // Se dentro e vuota
                         addMove(oneStep); // Aggiungi mossa (gestirà promozione se necessario)
                         // Mossa avanti di 2 (solo dalla riga iniziale e se il primo passo è libero)
                          if (rank === startRank) {
                              const twoSteps = index + 2 * forwardDir * 8;
                              if (twoSteps >= 0 && twoSteps < 64 && !board[twoSteps]) {
                                   addMove(twoSteps, 'b'); // Aggiungi flag 'b' (pawn buffer for EP target)
                              }
                          }
                     }

                     // Catture diagonali
                     const captureOffsets = [forwardDir * 8 - 1, forwardDir * 8 + 1];
                     for (const offset of captureOffsets) {
                          const capTo = index + offset;
                          // Verifica se la casella di cattura è sulla scacchiera E sulla colonna adiacente
                          if (capTo >= 0 && capTo < 64 && Math.abs((capTo % 8) - file) === 1) {
                              // Cattura normale
                              if (board[capTo] && board[capTo].color === oppColor) {
                                   addMove(capTo); // Aggiunge mossa (gestirà 'c'/'pc')
                              }
                              // Cattura En Passant
                              else if (capTo === enPassantTarget) {
                                   // Verifica addizionale: il pedone deve essere sulla riga giusta per catturare EP
                                   const epCaptureRank = color === 'white' ? 3 : 4; // Riga 3 per bianco, riga 4 per nero
                                   if (rank === epCaptureRank) {
                                       // Verifica che ci sia effettivamente un pedone avversario da catturare logicamente
                                       const epVictimRankOffset = color === 'white' ? 8 : -8;
                                       const epVictimIndex = capTo + epVictimRankOffset;
                                       if(board[epVictimIndex]?.type === 'P' && board[epVictimIndex]?.color === oppColor) {
                                           addMove(enPassantTarget, 'e'); // Aggiungi flag 'e' (en passant)
                                       }
                                   }
                              }
                          }
                     }
                     break;
                 case 'R': // Torre
                     addLinearMoves([[0, 1], [0, -1], [1, 0], [-1, 0]]); // Orizzontale e Verticale
                     break;
                 case 'N': // Cavallo
                     const nMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                     for (const [dr, df] of nMoves) {
                         const r = rank + dr;
                         const f = file + df;
                         if (r >= 0 && r <= 7 && f >= 0 && f <= 7) { // Se dentro la scacchiera
                              addMove(r * 8 + f); // Aggiungi mossa (gestirà cattura)
                         }
                     }
                     break;
                 case 'B': // Alfiere
                     addLinearMoves([[-1,-1],[-1,1],[1,-1],[1,1]]); // Diagonali
                     break;
                 case 'Q': // Regina
                     addLinearMoves([[0,1],[0,-1],[1,0],[-1,0],[-1,-1],[-1,1],[1,-1],[1,1]]); // Tutte le direzioni lineari
                     break;
                 case 'K': // Re
                     const kMoves = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                     for(const [dr,df] of kMoves) {
                         const r = rank + dr;
                         const f = file + df;
                         if(r >= 0 && r <= 7 && f >= 0 && f <= 7) { // Se dentro la scacchiera
                              addMove(r*8+f); // Aggiungi mossa (gestirà cattura)
                         }
                     }
                     // Arrocco (Pseudo-legale: controlla solo pezzi, non attacchi)
                     const kingSideRight = color === 'white' ? 'K' : 'k';
                     const queenSideRight = color === 'white' ? 'Q' : 'q';
                     const kingSideRookIndex = index + 3; // h1/h8
                     const queenSideRookIndex = index - 4; // a1/a8

                     // Arrocco Corto (Kingside)
                     if (castlingRights[kingSideRight] &&        // Diritto arrocco presente
                         !board[index + 1] && !board[index + 2] && // Caselle tra re e torre vuote
                         board[kingSideRookIndex]?.type === 'R' && board[kingSideRookIndex]?.color === color) { // Torre giusta presente
                          addMove(index + 2, 'ks'); // Mossa re a g1/g8, flag 'ks'
                     }
                     // Arrocco Lungo (Queenside)
                     if (castlingRights[queenSideRight] &&      // Diritto arrocco presente
                         !board[index - 1] && !board[index - 2] && !board[index - 3] && // Caselle tra re e torre vuote
                         board[queenSideRookIndex]?.type === 'R' && board[queenSideRookIndex]?.color === color) { // Torre giusta presente
                          addMove(index - 2, 'qs'); // Mossa re a c1/c8, flag 'qs'
                     }
                     break;
             }
             return moves;
          }

        // --- Inizializzazione ---
        function initializeApp() {
            console.log("Initializing application..."); // DEBUG
            try {
                selectDOMElements(); // Seleziona tutti gli elementi
                addEventListeners(); // Aggiungi tutti i listener
                loadSettingsAndStats(); // Carica impostazioni e statistiche salvate
                initTabs(); // Inizializza le tab del pannello laterale
                setupInitialScreen(); // Mostra la schermata iniziale di configurazione
                console.log("Application Initialized Successfully.");
             } catch (error) {
                console.error("CRITICAL ERROR during initialization:", error);
                alert("Errore critico inizializzazione. Controlla console (F12) e ricarica.");
                // Mostra messaggio di errore fallback se l'UI non può essere creata
                document.body.innerHTML = `<div style="padding: 20px; color: red; font-weight: bold;">Errore Critico Inizializzazione. Ricarica la pagina. Dettagli nella console (F12).</div>`;
            }
        }

function changeGame() {
        console.log("Tentativo di reindirizzamento a 'index.html'");
        // Assicurati che 'index.html' sia il nome corretto e il percorso giusto.
        // Se si trova nella stessa cartella, questo dovrebbe funzionare:
        window.location.href = 'index.html';
        // Se si trova in una cartella diversa, adegua il percorso, es: '../schermata iniziale.html' o '/path/to/schermata iniziale.html'
    }

        // Avvia l'applicazione quando il DOM è pronto
        initializeApp();
    }); // Fine DOMContentLoaded
</script>

    </body>
</html>
