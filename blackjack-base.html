<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blackjack base</title>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-J1YN9CKJS2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-J1YN9CKJS2');
</script>
<meta name="google-adsense-account" content="ca-pub-9456850571765688">
<meta name="description" content="Gioca a Blackjack online con salvataggio del saldo e stato Premium tramite Firebase, tavoli a limiti diversi, sfide giornaliere e funzionalità avanzate!" />
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap');
  :root {
    /* Light/Green Theme */
    --bg-color: #1e5631;
    --text-color: #ffffff;
    --card-bg: white;
    --card-text-black: black;
    --card-text-red: red;
    --button-bg: #e0e0e0;
    --button-text: #333333;
    --button-hover-bg: #d0d0d0;
    --button-disabled-opacity: 0.5;
    --highlight-color: #ffeb3b;
    --border-color: rgba(255, 255, 255, 0.2);
    --panel-bg: rgba(0, 0, 0, 0.3);
    --accent-color: #4fc3f7;
    --dealer-hidden-card-bg: #8b4513;
    --font-main: 'Nunito', sans-serif;
    --result-bg-color: rgba(0, 0, 0, 0.75);
    --result-text-color: #ffffff;
    --result-win-glow: rgba(76, 175, 80, 0.8);
    --result-lose-glow: rgba(244, 67, 54, 0.8);
    --result-push-glow: rgba(255, 152, 0, 0.8);
    --details-summary-bg: rgba(0, 0, 0, 0.4);
    --premium-popup-bg: rgba(50, 50, 50, 0.9);
    --premium-popup-border: #ffd700;
    /* Chip Colors */
    --chip-color-1: #f8f8f8; --chip-text-1: #333; --chip-border-1: #aaa;
    --chip-color-5: #e53935; --chip-text-5: white; --chip-border-5: #b71c1c;
    --chip-color-10: #1e88e5; --chip-text-10: white; --chip-border-10: #0d47a1;
    --chip-color-25: #43a047; --chip-text-25: white; --chip-border-25: #1b5e20;
    --chip-color-100: #37474f; --chip-text-100: white; --chip-border-100: #212121;
    --chip-color-500: #8e24aa; --chip-text-500: white; --chip-border-500: #4a148c;
    --chip-color-1000: #fdd835; --chip-text-1000: #333; --chip-border-1000: #f57f17;
    --chip-color-5000: #f06292; --chip-text-5000: white; --chip-border-5000: #e91e63;
    --challenge-item-bg: rgba(255, 255, 255, 0.05);
    --challenge-border: rgba(255, 255, 255, 0.1);
    --auth-status-bg: rgba(0, 0, 0, 0.2);
  }

  body[data-theme="dark"] {
    --bg-color: #1f1f1f;
    --text-color: #dcdcdc;
    --card-bg: #383838;
    --card-text-black: #dcdcdc;
    --card-text-red: #ff9a8f;
    --button-bg: #4a4a4a;
    --button-text: #dcdcdc;
    --button-hover-bg: #5a5a5a;
    --highlight-color: #ffd700;
    --border-color: rgba(255, 255, 255, 0.15);
    --panel-bg: rgba(255, 255, 255, 0.1);
    --accent-color: #4fc3f7;
    --dealer-hidden-card-bg: #252525;
    --details-summary-bg: rgba(255, 255, 255, 0.15);
    --premium-popup-bg: rgba(20, 20, 20, 0.95);
    --premium-popup-border: #4fc3f7;
    background-image: radial-gradient(circle at top center, hsl(0, 0%, 18%) 0%, var(--bg-color) 70%);
    background-attachment: fixed;
    /* Dark Theme Chip Colors (optional adjustments) */
    --chip-color-1: #bdbdbd; --chip-text-1: #212121; --chip-border-1: #757575;
    --chip-color-100: #546e7a; --chip-text-100: #eceff1; --chip-border-100: #37474f;
    --chip-color-1000: #ffeb3b; --chip-text-1000: #3e2723; --chip-border-1000: #fbc02d;
    --challenge-item-bg: rgba(0, 0, 0, 0.15);
    --challenge-border: rgba(0, 0, 0, 0.25);
    --auth-status-bg: rgba(255, 255, 255, 0.05);
  }

  /* --- General Styles --- */
  body {
    font-family: var(--font-main);
    text-align: center;
    background-color: var(--bg-color);
    color: var(--text-color);
    padding-top: 60px; /* Increased for auth status and balance */
    margin: 0;
    transition: background-color 0.3s, color 0.3s, background-image 0.3s;
    background-image: none;
    min-height: 100vh;
  }

  .game-container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 20px;
    position: relative;
    overflow-x: hidden;
  }

  h1 { margin-bottom: 15px; }
  h2 { margin-bottom: 10px; font-size: 1.5em; text-transform: uppercase; letter-spacing: 1px;}

   /* --- Auth Status & Balance Display (Top Right) --- */
    #top-bar-info {
        position: absolute;
        top: 10px;
        right: 15px;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 5px;
        z-index: 10;
    }
   #auth-status-display {
       background-color: var(--auth-status-bg);
       color: var(--text-color);
       padding: 6px 10px;
       border-radius: 6px;
       font-size: 0.8em;
       border: 1px solid var(--border-color);
   }
   #balance-display {
       background-color: var(--panel-bg);
       color: var(--highlight-color);
       padding: 8px 15px;
       border-radius: 8px;
       font-size: 1.1em;
       font-weight: bold;
       border: 1px solid var(--border-color);
       box-shadow: 0 2px 4px rgba(0,0,0,0.3);
       transition: background-color 0.3s, color 0.3s;
   }

  /* --- Collapsible Sections (Details/Summary) --- */
  details {
    background-color: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    padding: 0;
    margin: 15px auto;
    max-width: 450px;
    font-size: 1em;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    overflow: hidden;
    position: relative;
  }
   details.premium-locked > summary {
       cursor: not-allowed;
       opacity: 0.7;
   }
   details.premium-locked summary:hover {
       background-color: var(--details-summary-bg);
   }

  details summary {
    font-weight: bold;
    cursor: pointer;
    padding: 12px 15px;
    background-color: var(--details-summary-bg);
    list-style: none;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
  }

  details summary:hover {
      background-color: rgba(0,0,0,0.5);
  }

  details[open] summary {
      border-bottom: 1px solid var(--border-color);
  }

  details summary::-webkit-details-marker { display: none; }

  details .content-wrapper {
      padding: 15px;
  }

  details h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: var(--accent-color);
      font-size: 1.2em;
      text-align: center;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 8px;
  }

   details summary::after {
        content: '+';
        font-size: 1.4em;
        font-weight: bold;
        margin-left: 10px;
        transition: transform 0.2s ease-in-out;
   }
   details[open] summary::after {
        content: '−';
   }

  /* --- Specific Content Styling within <details> --- */
  #utility-controls-content div,
  #stats-content div,
  #trainer-controls-content div
  {
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 3px 0;
   }
   #utility-controls-content label, #trainer-controls-content label {
      margin-right: 15px;
      font-weight: bold;
   }
   #stats-content span:last-child, #trainer-controls-content span:last-child {
      font-weight: bold;
      color: var(--highlight-color);
   }
   #stats-content #stats-win-rate {
      color: var(--accent-color);
   }
   #reset-stats-button {
       margin-top: 10px;
       width: 100%;
   }
   #trainer-title {
       display: flex;
       justify-content: center;
       align-items: center;
       position: relative;
   }
   #hilo-info-button {
       padding: 0; margin: 0 0 0 10px; width: 24px;
       height: 24px; font-size: 15px; line-height: 22px; font-weight: bold; border-radius: 50%; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--border-color); box-shadow: none;
       cursor: help; vertical-align: middle; transition: background-color 0.2s, border-color 0.2s; flex-shrink: 0;
   }
   #hilo-info-button:hover { background-color: var(--button-hover-bg); border-color: var(--accent-color); transform: none; box-shadow: none; }

   /* --- Daily Challenges --- */
   #daily-challenges-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 10px;
   }
   .challenge-item {
      background-color: var(--challenge-item-bg);
      border: 1px solid var(--challenge-border);
      border-radius: 8px;
      padding: 10px 12px;
      text-align: left;
      transition: opacity 0.3s;
   }
   .challenge-item.premium-challenge {
      border-left: 4px solid var(--premium-popup-border); /* Highlight premium */
   }
   .challenge-item.locked {
       opacity: 0.6;
       cursor: not-allowed;
       position: relative;
       overflow: hidden; /* Keep lock inside */
   }
   .challenge-item.locked::after {
       content: '🔒 Premium';
       position: absolute;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
       background-color: rgba(0,0,0,0.7);
       color: var(--highlight-color);
       padding: 6px 10px;
       border-radius: 5px;
       font-size: 0.9em;
       font-weight: bold;
       z-index: 2;
       pointer-events: none; /* Allow clicks on item for popup */
   }
   .challenge-item p {
       margin: 3px 0;
       font-size: 0.95em;
   }
   .challenge-item .challenge-description {
       font-weight: bold;
       margin-bottom: 5px;
   }
   .challenge-item .challenge-progress-bar {
        width: 100%;
        height: 10px;
        background-color: rgba(255, 255, 255, 0.15);
        border-radius: 5px;
        overflow: hidden;
        margin-top: 5px;
   }
   .challenge-item .challenge-progress {
        height: 100%;
        width: 0%;
        background-color: var(--highlight-color);
        border-radius: 5px 0 0 5px;
        transition: width 0.5s ease-in-out;
    }
    .challenge-item .challenge-reward {
        font-weight: bold;
        color: var(--highlight-color);
    }
    .challenge-item .challenge-completed-text {
        font-style: italic;
        font-weight: bold;
        color: var(--accent-color);
        text-align: center;
        margin-top: 5px;
    }
    .challenge-item[data-completed="true"] .challenge-progress-bar {
        opacity: 0.7;
    }
    .challenge-item[data-completed="true"] .challenge-progress {
        background-color: var(--accent-color); /* Change color on completion */
    }


  /* --- Table Limits --- */
   #table-limits {
       margin: 15px auto;
       padding: 10px 15px;
       background-color: var(--panel-bg);
       border: 1px solid var(--border-color);
       border-radius: 8px;
       max-width: 450px;
       display: flex;
       align-items: center;
       justify-content: center;
       gap: 15px;
   }
   #table-limits label {
       font-weight: bold;
       margin-right: 5px;
   }
   #table-select {
       padding: 8px 10px;
       border-radius: 5px;
       border: 1px solid var(--border-color);
       background-color: var(--button-bg);
       color: var(--button-text);
       font-family: var(--font-main);
       font-size: 0.9em;
       cursor: pointer;
   }
   #table-select:focus {
       outline: none;
       box-shadow: 0 0 5px var(--accent-color);
   }

  /* --- Cards Styles --- */
  .cards { margin: 15px auto; display: flex; justify-content: center; min-height: 115px; gap: 12px; flex-wrap: wrap; perspective: 1200px; transition: opacity 0.5s ease-out; /* Added for fade out */ }
  .card { display: inline-block; border: 1px solid var(--border-color); border-radius: 8px; background: var(--card-bg); width: 65px; height: 95px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); margin: 3px; position: relative; transform-style: preserve-3d; transition: transform 0.7s cubic-bezier(0.4, 0.0, 0.2, 1); transform: rotateY(180deg); }
  .card-inner { position: relative; width: 100%; height: 100%; text-align: center; transform-style: preserve-3d; }
  .card-face { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; border-radius: 8px; display: flex; flex-direction: column; justify-content: space-around; /* Distribute space */ align-items: center; padding: 8px 5px; /* Adjust padding */ box-sizing: border-box; }
  .card-front { background-color: var(--card-bg); background-image: linear-gradient(to bottom, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.05) 100%); color: var(--card-text-black); font-size: 24px; /* Slightly larger */ font-weight: bold; transform: rotateY(0deg); border: 1px solid rgba(0,0,0,0.1); }
  .card-back { background-color: var(--dealer-hidden-card-bg); color: var(--text-color); transform: rotateY(180deg); background-image: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%), linear-gradient(-45deg, rgba(255,255,255,0.1) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, rgba(255,255,255,0.1) 75%), linear-gradient(-45deg, transparent 75%, rgba(255,255,255,0.1) 75%); background-size: 18px 18px; }
  .card.flipped { transform: rotateY(0deg); }
  .card-front.red { color: var(--card-text-red); }
  .card-front.black { color: var(--card-text-black); }
  .card .value { line-height: 1; /* Ensure value is tight */ }
  .card .suit { font-size: 18px; /* Slightly larger suit */ font-weight: normal; line-height: 1; }

  /* --- Buttons & Betting --- */
  #buttons, #betting-buttons { margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
  button, .toggle-switch label { padding: 12px 20px; font-size: 15px; font-weight: bold; margin: 5px; cursor: pointer; border: none; border-radius: 8px; background-color: var(--button-bg); color: var(--button-text); transition: background-color 0.2s ease, opacity 0.3s ease, transform 0.15s ease, box-shadow 0.2s ease; user-select: none; -webkit-user-select: none; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); letter-spacing: 0.5px; }
  button:hover:not(:disabled) { background-color: var(--button-hover-bg); transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); }
  button:active:not(:disabled) { transform: translateY(0px); box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); }
  button:disabled { opacity: var(--button-disabled-opacity); cursor: not-allowed; box-shadow: none; transform: none; }
  button.hint-highlight { box-shadow: 0 0 12px 4px var(--highlight-color); border: 1px solid var(--highlight-color); transform: translateY(-1px); }
  button.premium-locked { position: relative; }
  button.premium-locked::after { content: '🔒'; position: absolute; top: 2px; right: 5px; font-size: 10px; color: var(--highlight-color); background-color: rgba(0,0,0,0.6); padding: 1px 3px; border-radius: 3px; }

  /* --- Betting Area with CSS Chips --- */
   #betting-area { margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 15px; }
   #proposed-bet-display { font-size: 1.4em; font-weight: bold; color: var(--highlight-color); min-height: 1.5em; background-color: var(--panel-bg); padding: 5px 15px; border-radius: 5px; }
   #clickable-chips { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; margin-bottom: 15px; }
   /* Base Chip Button Style */
   .chip-button { width: 55px; height: 55px; cursor: pointer; border-radius: 50%; border: none; /* Removed default border */ padding: 0; /* Remove padding */ transition: transform 0.1s ease-out, opacity 0.3s ease, box-shadow 0.2s ease; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); user-select: none; -webkit-user-select: none; position: relative; /* For premium lock */ display: flex; /* Use flexbox for centering content */ justify-content: center; align-items: center; font-family: var(--font-main); font-weight: bold; font-size: 14px; /* Adjust as needed */ background-color: grey; /* Default background */ color: white; /* Default text */ border: 3px solid rgba(255, 255, 255, 0.1); /* Default border */ }
   /* Chip Button Inner Circle (for layered effect) */
   .chip-button::before { content: ''; position: absolute; top: 5px; /* Inset distance */ left: 5px; right: 5px; bottom: 5px; border-radius: 50%; border: 2px dashed rgba(255, 255, 255, 0.3); /* Example inner detail */ box-sizing: border-box; /* Include border in size */ }
   /* Chip Value Text */
   .chip-value { position: relative; /* Ensure text is above pseudo-elements */ z-index: 1; }
    /* Chip Colors using data attribute */
    .chip-button[data-value="1"] { background-color: var(--chip-color-1); color: var(--chip-text-1); border-color: var(--chip-border-1); }
    .chip-button[data-value="5"] { background-color: var(--chip-color-5); color: var(--chip-text-5); border-color: var(--chip-border-5); }
    .chip-button[data-value="10"] { background-color: var(--chip-color-10); color: var(--chip-text-10); border-color: var(--chip-border-10); }
    .chip-button[data-value="25"] { background-color: var(--chip-color-25); color: var(--chip-text-25); border-color: var(--chip-border-25); }
    .chip-button[data-value="100"] { background-color: var(--chip-color-100); color: var(--chip-text-100); border-color: var(--chip-border-100); }
    .chip-button[data-value="500"] { background-color: var(--chip-color-500); color: var(--chip-text-500); border-color: var(--chip-border-500); }
    .chip-button[data-value="1000"] { background-color: var(--chip-color-1000); color: var(--chip-text-1000); border-color: var(--chip-border-1000); }
    .chip-button[data-value="5000"] { background-color: var(--chip-color-5000); color: var(--chip-text-5000); border-color: var(--chip-border-5000); }
   /* Chip Hover/Active States */
   .chip-button:hover:not([disabled]) { transform: scale(1.05) translateY(-2px); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), 0 0 8px var(--highlight-color); }
   .chip-button:active:not([disabled]) { transform: scale(0.98); box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.6); }
   .chip-button[disabled] { opacity: 0.5; /* Dim disabled chips */ cursor: not-allowed; transform: none; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4); /* Keep some shadow */ background-image: linear-gradient(rgba(100,100,100,0.5), rgba(100,100,100,0.5)); /* Grey overlay */ }
   /* Remove image styles */
   .chip-button img { display: none; }
   /* Premium Lock on Chips (keep) */
   .chip-button.premium-locked::after { content: '🔒'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; color: var(--highlight-color); background-color: rgba(0,0,0,0.7); padding: 5px; border-radius: 50%; line-height: 1; pointer-events: none; z-index: 2; /* Ensure lock is above chip content */ }
   #bet-chips { min-height: 30px; margin-top: 10px; font-size: 1.2em; font-weight: bold; color: var(--text-color); background-color: var(--panel-bg); padding: 3px 10px; border-radius: 5px; }

  /* --- Player/Dealer Info --- */
  #player-info, #dealer-info { margin-bottom: 20px; }
  #player-info h2 { font-size: 1.3em; }
  #player-money { /* Style the original player money display */
      font-size: 0.9em; color: rgba(255,255,255,0.7); /* Make less prominent */
      font-weight: normal;
      margin-left: 5px;
  }
  /* Dealer Score Display */
  #dealer-score {
      font-weight: bold;
      margin-left: 8px;
      color: var(--text-color);
      background-color: var(--panel-bg);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.9em;
      min-width: 25px; /* Ensure space for score */
      display: inline-block; /* Allow padding and alignment */
      text-align: center;
  }

  /* --- Multiple Hands --- */
  #player-hands-container { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 15px; transition: opacity 0.5s ease-out; /* Added for fade out */ }
  .player-hand { border: 2px solid var(--border-color); border-radius: 12px; padding: 15px; min-width: 180px; background-color: var(--panel-bg); position: relative; transition: border-color 0.3s, box-shadow 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
  .player-hand h3 { margin-top: 0; margin-bottom: 8px; font-size: 1.1em; color: var(--accent-color); text-align: center; }
  .player-hand .cards { min-height: 100px; margin-bottom: 10px; }
  .player-score { font-size: 1em; margin-bottom: 5px; margin-top: 8px; font-weight: bold; }
  .hand-status { font-size: 1em; font-weight: bold; color: var(--highlight-color); min-height: 1.2em; text-align: center; }
  .player-hand.current-hand { border-color: var(--highlight-color); box-shadow: 0 0 15px rgba(255, 223, 0, 0.6); }

  /* --- Result Message --- */
  #result { opacity: 0; visibility: hidden; transform: translate(-50%, -50%) scale(0.8); transition: opacity 0.4s ease-out, visibility 0s linear 0.4s, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: fixed; top: 50%; left: 50%; z-index: 100; background-color: var(--result-bg-color); color: var(--result-text-color); padding: 25px 40px; border-radius: 15px; font-size: 2.8em; font-weight: bold; text-align: center; white-space: pre-line; min-width: 300px; max-width: 80%; box-shadow: 0 0 20px 5px rgba(0, 0, 0, 0.5); }
  #result.result-show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition: opacity 0.4s ease-out, visibility 0s linear 0s, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
  #result.win { box-shadow: 0 0 25px 10px var(--result-win-glow); }
  #result.lose { box-shadow: 0 0 25px 10px var(--result-lose-glow); }
  #result.push { box-shadow: 0 0 25px 10px var(--result-push-glow); }

  /* --- Premium Popup --- */
  #premium-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); background-color: var(--premium-popup-bg); color: var(--text-color); padding: 30px 40px; border-radius: 15px; border: 3px solid var(--premium-popup-border); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); z-index: 1001; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-out, visibility 0s linear 0.3s, transform 0.3s ease-out; text-align: center; max-width: 85%; width: 450px; }
  #premium-popup.show { opacity: 1; visibility: visible; transform: translate(-50%, -50%) scale(1); transition: opacity 0.3s ease-out, visibility 0s linear 0s, transform 0.3s ease-out; }
  #premium-popup h3 { margin-top: 0; margin-bottom: 15px; color: var(--highlight-color); font-size: 1.5em; }
  #premium-popup #premium-message { margin-bottom: 25px; font-size: 1.1em; line-height: 1.5; text-align: left; }
  #premium-popup #premium-message ul { list-style-type: '⭐ '; padding-left: 20px; margin-top: 15px; }
   #premium-popup #premium-message li { margin-bottom: 8px; }
  #premium-popup .popup-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 20px; }
  #premium-popup button { padding: 10px 25px; font-size: 1em; }
  #premium-popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease-out, visibility 0s linear 0.3s; }
   #premium-popup-overlay.show { opacity: 1; visibility: visible; transition: opacity 0.3s ease-out, visibility 0s linear 0s; }

  /* --- Toggle Switch --- */
   .toggle-switch { position: relative; display: inline-block; width: 50px; height: 24px; vertical-align: middle; }
   .toggle-switch input { opacity: 0; width: 0; height: 0; }
   .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 24px; }
   .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
   input:checked + .slider { background-color: var(--accent-color); }
   input:focus + .slider { box-shadow: 0 0 2px var(--accent-color); }
   input:checked + .slider:before { transform: translateX(26px); }

  /* --- Visually Hidden --- */
  .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }

  /* --- Responsiveness --- */
  @media (max-width: 768px) {
      #top-bar-info { right: 10px; }
      #auth-status-display { font-size: 0.75em; padding: 4px 8px;}
      #balance-display { font-size: 1em; padding: 6px 10px; }
      .card { width: 60px; height: 90px; border-radius: 6px;}
      .card-front { font-size: 20px; }
      .card .suit { font-size: 16px; /* Adjusted */ }
      button, .toggle-switch label { font-size: 14px; padding: 10px 15px;}
      #hilo-info-button { width: 22px; height: 22px; font-size: 14px; line-height: 20px; }
      .player-hand { min-width: 160px; padding: 12px; border-radius: 10px;}
      h1 { font-size: 2em; }
      details, #table-limits { max-width: 90%; }
       details .content-wrapper, #table-limits { padding: 12px; }
       .challenge-item { padding: 8px 10px; }
       .challenge-item p { font-size: 0.9em; }
       .challenge-item .challenge-progress-bar { height: 8px; }
      /* Adjusted chip size */
      .chip-button { width: 50px; height: 50px; font-size: 12px; border-width: 2px; }
       .chip-button::before { top: 4px; left: 4px; right: 4px; bottom: 4px; border-width: 1px; }
      #result { font-size: 2.2em; padding: 20px 30px; }
      #table-limits { flex-direction: column; gap: 8px; }
      #premium-popup { width: 80%; padding: 20px; }
      #premium-popup h3 { font-size: 1.3em; }
      #premium-popup #premium-message { font-size: 1em; }
  }

   @media (max-width: 480px) {
      body { padding-top: 55px; /* Adjusted for auth & balance */ }
      #top-bar-info { right: 5px; }
      #auth-status-display { font-size: 0.7em; padding: 3px 6px;}
      #balance-display { top: 28px; /* Position balance below auth */ right: 5px; font-size: 0.9em; padding: 5px 8px; }
      .game-container { padding: 10px; }
      h1 { font-size: 1.6em; margin-top: 20px; }
      .cards { min-height: 100px; gap: 8px;}
      .card { width: 50px; height: 75px; border-radius: 4px; margin: 2px;}
      .card-front { font-size: 18px; /* Adjusted */ padding: 5px 3px; /* Adjusted */ }
      .card .suit { font-size: 14px; /* Adjusted */ }
      #buttons, #betting-buttons { margin-top: 15px; gap: 5px;}
      button, .toggle-switch label { font-size: 12px; padding: 8px 10px; margin: 3px;}
      #hilo-info-button { width: 20px; height: 20px; font-size: 12px; line-height: 18px; margin-left: 5px;}
      .player-hand { min-width: 130px; padding: 8px; gap: 8px; border-radius: 8px;}
      .player-hand .cards { min-height: 80px; }
      #player-hands-container { gap: 10px; }
      #result { font-size: 1.6em; padding: 15px 20px; min-width: 250px;}
      details, #table-limits { margin: 10px auto; font-size: 0.9em; }
      details .content-wrapper, #table-limits { padding: 10px; }
      #utility-controls-content div, #stats-content div, #trainer-controls-content div { flex-direction: row; align-items: center; }
      .challenge-item { padding: 6px 8px; }
      .challenge-item p { font-size: 0.85em; }
      .challenge-item .challenge-progress-bar { height: 6px; }
      .challenge-item.locked::after { font-size: 0.8em; padding: 4px 6px; }
      /* Adjusted chip size */
      .chip-button { width: 45px; height: 45px; font-size: 11px; border-width: 2px; }
       .chip-button::before { top: 3px; left: 3px; right: 3px; bottom: 3px; border-width: 1px; }
      #proposed-bet-display { font-size: 1.2em; padding: 4px 10px; }
      #premium-popup { width: 90%; font-size: 0.9em; padding: 15px;}
      #premium-popup h3 { font-size: 1.2em; }
      #premium-popup #premium-message { font-size: 0.95em; }
      #premium-popup button { font-size: 0.9em; }
   }
</style>
</head>
<body data-theme="light">

<div id="premium-popup-overlay"></div> <div id="premium-popup">
    <h3>🌟 Sblocca i Vantaggi Premium! 🌟</h3>
    <div id="premium-message">
        <p>Passa a Premium per accedere a funzionalità esclusive:</p>
        <ul>
            <li>Statistiche dettagliate della sessione</li>
            <li>Trainer per il conteggio delle carte (Hi-Lo)</li>
            <li>Suggerimenti di gioco basati sulla strategia ottimale</li>
            <li>Fiches di valore più alto per puntate maggiori</li>
            <li>Sfide Premium con ricompense maggiori</li>
            <li>Supporta lo sviluppo del gioco!</li>
        </ul>
    </div>
    <div class="popup-buttons">
        <button id="close-premium-popup-button">Più Tardi</button>
        <button id="activate-premium-button">Passa a Premium</button>
    </div>
</div>

<div class="game-container">
    <h1>Blackjack Premium Trainer</h1>
    <div id="top-bar-info">
        <div id="auth-status-display">Non collegato</div>
        <div id="balance-display">Saldo: €1000</div>
    </div>

    <details id="utility-controls">
        <summary>Utilità e Opzioni</summary>
        <div class="content-wrapper" id="utility-controls-content">
            <div>
                <label for="theme-toggle">Tema Scuro</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="theme-toggle">
                    <span class="slider"></span>
                </label>
            </div>
             <div>
                <label for="training-mode-toggle">Modalità Allenamento Conteggio</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="training-mode-toggle">
                     <span class="slider"></span>
                </label>
            </div>
             <div class="premium-option">
                <label for="show-hints-toggle">Mostra Suggerimenti (Premium)</label>
                <label class="toggle-switch">
                     <input type="checkbox" id="show-hints-toggle" class="premium-feature-input">
                    <span class="slider"></span>
                </label>
            </div>
            <div style="margin-top: 15px; text-align: center;">
                <button id="change-game-button">Cambia Gioco</button>
            </div>
        </div>
    </details>

    <details id="trainer-controls" class="premium-feature-section">
        <summary>Contatore Carte (Hi-Lo) - Premium</summary>
        <div class="content-wrapper" id="trainer-controls-content">
             <h3 id="trainer-title">
                Contatore Carte (Hi-Lo)
                <button id="hilo-info-button" aria-label="Informazioni sul conteggio Hi-Lo" title="Cos'è il conteggio Hi-Lo?">?</button>
             </h3>
             <div><span>Conteggio Corrente (Running Count):</span> <span id="running-count">0</span></div>
             <div><span>Mazzi Rimanenti (stimati):</span> <span id="decks-remaining">0.0</span></div>
             <div><span>Conteggio Reale (True Count):</span> <span id="true-count">0.0</span></div>
        </div>
    </details>

    <details id="session-stats" class="premium-feature-section">
        <summary>Statistiche Sessione - Premium</summary>
        <div class="content-wrapper" id="stats-content">
            <h3>Statistiche Sessione</h3>
            <div><span>Mani Giocate:</span> <span id="stats-hands">0</span></div>
            <div><span>Vittorie:</span> <span id="stats-wins">0</span></div>
            <div><span>Sconfitte:</span> <span id="stats-losses">0</span></div>
             <div><span>Pareggi:</span> <span id="stats-pushes">0</span></div>
            <div><span>Blackjack Vinti:</span> <span id="stats-bjs">0</span></div>
            <div><span>Win Rate (V/V+S):</span> <span id="stats-win-rate">N/A</span></div>
            <button id="reset-stats-button">Azzera Statistiche</button>
        </div>
    </details>

    <details id="daily-challenges-details">
        <summary>Sfide Giornaliere</summary>
        <div class="content-wrapper" id="daily-challenges-content">
            <h3>Sfide Giornaliere</h3>
            <div id="daily-challenges-container">
                <p id="challenges-loading">Caricamento sfide...</p>
            </div>
        </div>
     </details>


     <div id="table-limits">
        <label for="table-select">Limiti Tavolo:</label>
        <select id="table-select">
            <option value="low">€5 - €100</option>
            <option value="medium">€25 - €500</option>
            <option value="high" class="premium-feature">€100 - €2000 (Premium)</option>
            <option value="whale" class="premium-feature">€500 - €10000 (Premium)</option>
        </select>
     </div>


     <div id="betting-area">
        <div id="proposed-bet-display">Punta: €0</div>
        <div id="clickable-chips">
            </div>
        <div id="betting-buttons">
            <button id="deal-button">Distribuisci</button>
            <button id="rebet-button" style="display: none;">Stessa Puntata</button>
            <button id="clear-bet-button">Azzera Puntata</button>
        </div>
    </div>

    <div id="game-area" style="display: none;">
        <div id="dealer-info">
            <h2>Dealer <span id="dealer-score">?</span></h2>
            <div id="dealer-cards" class="cards"></div>
        </div>

        <div id="player-info">
             <h2>Giocatore <span id="player-money">€1000</span></h2>
             <div id="player-hands-container" class="cards">
             </div>
        </div>

        <div id="buttons">
            <button id="hit-button">Carta</button>
            <button id="stand-button">Stai</button>
            <button id="double-button">Raddoppia</button>
            <button id="split-button">Dividi</button>
        </div>
    </div>

    <div id="result"></div>
</div>

<script type="module">
    // Firebase imports (MODIFIED PATH)
    import {
        auth,
        db, // db might not be directly used here if all Firestore ops are in firebase-logic
        onAuthStateChanged,
        updateSaldoInFirestore,
        getSaldoFromFirestore,
        setUserVIPStatus,
        checkUserVIPStatus
        // Non importare registerUser, loginUser, logoutUser qui,
        // verranno gestite da uno script separato per l'autenticazione (es. auth.js)
        // o tramite un'interfaccia utente per il login/registrazione.
        // Per ora, questo script si concentrerà sulla logica del gioco dopo l'autenticazione.
    } from "./js/firebase-logic.js"; // ASSUMING firebase-logic.js IS IN A 'js' SUBFOLDER

    // --- DOM Elements ---
    const playerMoneyElement = document.getElementById('player-money'); // Inside game area
    const balanceDisplayElement = document.getElementById('balance-display'); // Top right display
    const authStatusDisplayElement = document.getElementById('auth-status-display');
    const dealerCardsElement = document.getElementById('dealer-cards');
    const playerHandsContainer = document.getElementById('player-hands-container');
    const dealerScoreElement = document.getElementById('dealer-score');
    const hitButton = document.getElementById('hit-button');
    const standButton = document.getElementById('stand-button');
    const doubleButton = document.getElementById('double-button');
    const splitButton = document.getElementById('split-button');
    const dealButton = document.getElementById('deal-button');
    const rebetButton = document.getElementById('rebet-button');
    const clearBetButton = document.getElementById('clear-bet-button');
    const resultElement = document.getElementById('result');
    const bettingArea = document.getElementById('betting-area');
    const gameArea = document.getElementById('game-area');
    const clickableChipsContainer = document.getElementById('clickable-chips');
    const proposedBetDisplay = document.getElementById('proposed-bet-display');
    const themeToggle = document.getElementById('theme-toggle');
    const runningCountElement = document.getElementById('running-count');
    const decksRemainingElement = document.getElementById('decks-remaining');
    const trueCountElement = document.getElementById('true-count');
    const statsHandsElement = document.getElementById('stats-hands');
    const statsWinsElement = document.getElementById('stats-wins');
    const statsLossesElement = document.getElementById('stats-losses');
    const statsPushesElement = document.getElementById('stats-pushes');
    const statsBjsElement = document.getElementById('stats-bjs');
    const statsWinRateElement = document.getElementById('stats-win-rate');
    const resetStatsButton = document.getElementById('reset-stats-button');
    const trainingModeToggle = document.getElementById('training-mode-toggle');
    const showHintsToggle = document.getElementById('show-hints-toggle');
    const premiumPopup = document.getElementById('premium-popup');
    const premiumPopupOverlay = document.getElementById('premium-popup-overlay');
    const premiumFeatureSections = document.querySelectorAll('.premium-feature-section');
    const premiumFeatureInputs = document.querySelectorAll('.premium-feature-input');
    const trainerControls = document.getElementById('trainer-controls');
    const sessionStats = document.getElementById('session-stats');
    const utilityControls = document.getElementById('utility-controls');
    const tableSelect = document.getElementById('table-select');
    const dailyChallengesDetails = document.getElementById('daily-challenges-details');
    const dailyChallengesContainer = document.getElementById('daily-challenges-container');
    const challengesLoading = document.getElementById('challenges-loading');
    const changeGameButton = document.getElementById('change-game-button');
    const hiloInfoButton = document.getElementById('hilo-info-button');
    const closePremiumPopupButton = document.getElementById('close-premium-popup-button');
    const activatePremiumButton = document.getElementById('activate-premium-button');


    // --- Game Variables ---
    let deck = [];
    let playerHands = [];
    let dealerHand = [];
    let currentHandIndex = 0;
    let playerMoney = 1000; // Default if not logged in or no Firestore data
    let currentBet = 0;     // Bet for the current active hand in a split scenario
    let initialBet = 0;   // Total bet placed at the start of the round for the first hand
    let lastBet = 0;
    let proposedBet = 0;
    let isGameOver = true;
    let isPremium = false; // Will be updated from Firestore
    let runningCount = 0;
    let decksInShoe = 6;
    let cardsDealt = 0;
    let sessionStatsData = { hands: 0, wins: 0, losses: 0, pushes: 0, blackjacks: 0 };
    let trainingModeActive = false;
    let showHintsActive = false;
    let isSplitRound = false;
    let dailyChallenges = [];
    let dailyBonusInfo = { collectedToday: false, lastLoginTimestamp: 0, consecutiveDays: 0 };
    let cardClearTimeout = null;
    let currentUID = null; // Store logged-in user's UID

    const SUITS = ["C", "D", "H", "S"];
    const VALUES = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];
    const TABLE_LIMITS = {
        low: { min: 5, max: 100, chips: [1, 5, 10, 25] },
        medium: { min: 25, max: 500, chips: [5, 10, 25, 100] },
        high: { min: 100, max: 2000, chips: [25, 100, 500, 1000], premium: true },
        whale: { min: 500, max: 10000, chips: [100, 500, 1000, 5000], premium: true }
    };
    let currentTableLimits = TABLE_LIMITS.low;
    const DAILY_CHALLENGE_COUNT = 3;
    const PREMIUM_CHALLENGE_INDEX = 2;
    const PREMIUM_CHALLENGE_REWARD = 1000;
    const NORMAL_CHALLENGE_REWARD_BASE = 100;
    const DEFAULT_PLAYER_MONEY = 1000; // Default money for non-logged-in or new Firebase users

    // --- Firebase Auth Listener ---
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            currentUID = user.uid;
            authStatusDisplayElement.textContent = `Connesso: ${user.email.split('@')[0]}`; // Show part of email
            console.log("User signed in:", user.uid, user.email);
            try {
                const firestoreSaldo = await getSaldoFromFirestore(user.uid);
                playerMoney = (firestoreSaldo !== undefined && firestoreSaldo !== null) ? firestoreSaldo : DEFAULT_PLAYER_MONEY;
                console.log(`Saldo caricato da Firestore per ${user.uid}: €${playerMoney}`);

                isPremium = await checkUserVIPStatus(user.uid);
                localStorage.setItem('blackjackPremium', isPremium ? 'true' : 'false'); // Keep local sync
                console.log(`Stato Premium caricato da Firestore per ${user.uid}: ${isPremium}`);

            } catch (error) {
                console.error("Errore nel caricare dati utente da Firestore:", error);
                playerMoney = DEFAULT_PLAYER_MONEY; // Fallback
                isPremium = false; // Fallback
            }
        } else {
            currentUID = null;
            authStatusDisplayElement.textContent = "Non collegato";
            console.log("User signed out or not logged in.");
            playerMoney = parseInt(localStorage.getItem('blackjackPlayerMoney_local') || DEFAULT_PLAYER_MONEY.toString());
            isPremium = localStorage.getItem('blackjackPremium_local') === 'true'; // Fallback to local premium
        }
        // Update UI based on auth state
        applyPremiumFeatures(); // This also handles UI for non-premium
        updatePlayerMoneyDisplay(); // Update all money displays
        updateBettingUI(); // Update chips based on possibly changed premium status/money
        checkDailyBonusAndStreak(); // Check bonus after knowing user status
        loadDailyChallenges();      // Load or generate challenges after knowing user status
    });


    // --- Game Logic Functions (Main Blackjack logic mostly unchanged, save for Firebase interactions) ---

    function createDeck() {
        let newDeck = [];
        for (let d = 0; d < decksInShoe; d++) {
            for (let suit of SUITS) {
                for (let value of VALUES) {
                    newDeck.push({ value, suit });
                }
            }
        }
        return newDeck;
    }

    function shuffleDeck(deckToShuffle) { // Renamed parameter to avoid conflict
        for (let i = deckToShuffle.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deckToShuffle[i], deckToShuffle[j]] = [deckToShuffle[j], deckToShuffle[i]];
        }
        runningCount = 0;
        cardsDealt = 0;
        console.log(`Deck shuffled (${deckToShuffle.length} cards)`);
        updateTrainerDisplay();
    }

    function getCardValue(card) {
        if (["T", "J", "Q", "K"].includes(card.value)) {
            return 10;
        } else if (card.value === "A") {
            return 11;
        } else {
            return parseInt(card.value);
        }
    }

    function calculateScore(hand) {
        let score = 0;
        let aceCount = 0;
        for (let card of hand) {
            score += getCardValue(card);
            if (card.value === "A") {
                aceCount++;
            }
        }
        while (score > 21 && aceCount > 0) {
            score -= 10;
            aceCount--;
        }
        return score;
    }

    function updateRunningCount(card) {
        if (!trainingModeActive) return;
        const value = getCardValue(card);
        if (value >= 2 && value <= 6) {
            runningCount++;
        } else if (value === 10 || value === 11) { // Ace counts as 11 here for value, but -1 for HiLo
            runningCount--;
        }
        cardsDealt++;
        updateTrainerDisplay();
    }

    function updateTrainerDisplay() {
        if (!trainerControls.open || !trainingModeActive) return;
        const cardsRemainingInShoe = deck.length;
        const decksRemaining = Math.max(0.25, cardsRemainingInShoe / 52).toFixed(1);
        const trueCount = (parseFloat(decksRemaining) > 0) ? (runningCount / parseFloat(decksRemaining)).toFixed(1) : "0.0"; // Ensure float division
        runningCountElement.textContent = runningCount;
        decksRemainingElement.textContent = decksRemaining;
        trueCountElement.textContent = trueCount;
    }

    function dealCard(targetHand, isHidden = false) {
        if (deck.length < (decksInShoe * 52 * 0.25)) { // Reshuffle if ~25% penetration
            console.log("Reshuffling deck (low penetration)...");
            deck = createDeck();
            shuffleDeck(deck);
        }
        if (deck.length === 0) {
             console.error("Deck is empty! Cannot deal card.");
             deck = createDeck();
             shuffleDeck(deck);
        }
        const card = deck.pop();
        card.hidden = isHidden;
        targetHand.push(card);
        if (!isHidden) {
            updateRunningCount(card);
        }
        return card;
    }

    function createCardElement(card) {
        const cardDiv = document.createElement('div');
        cardDiv.classList.add('card');
        const cardInner = document.createElement('div');
        cardInner.classList.add('card-inner');

        const cardBack = document.createElement('div');
        cardBack.classList.add('card-face', 'card-back');

        const cardFront = document.createElement('div');
        cardFront.classList.add('card-face', 'card-front');

        const displayValue = card.value === 'T' ? '10' : card.value;
        const valueSpan = document.createElement('span');
        valueSpan.classList.add('value');
        valueSpan.textContent = displayValue;

        const suitSpan = document.createElement('span');
        suitSpan.classList.add('suit');
        let suitSymbol = '';
        let colorClass = 'black';
        switch (card.suit) {
            case 'H': suitSymbol = '♥'; colorClass = 'red'; break;
            case 'D': suitSymbol = '♦'; colorClass = 'red'; break;
            case 'C': suitSymbol = '♣'; colorClass = 'black'; break;
            case 'S': suitSymbol = '♠'; colorClass = 'black'; break;
        }
        suitSpan.textContent = suitSymbol;
        cardFront.classList.add(colorClass);

        cardFront.appendChild(valueSpan);
        cardFront.appendChild(suitSpan);
        cardInner.appendChild(cardBack);
        cardInner.appendChild(cardFront);
        cardDiv.appendChild(cardInner);

        if (!card.hidden) {
             setTimeout(() => { cardDiv.classList.add('flipped'); }, 50); // Slight delay for entry
        }
        return cardDiv;
    }

    function renderHand(hand, element) {
        element.innerHTML = '';
        hand.forEach((card, index) => {
            const cardElement = createCardElement(card);
            cardElement.style.transitionDelay = `${index * 0.05}s`; // Reduced delay for faster dealing
            element.appendChild(cardElement);
        });
    }

     function createPlayerHandElement(index, handBet) { // Changed initialBet to handBet for clarity
        const handDiv = document.createElement('div');
        handDiv.classList.add('player-hand');
        handDiv.id = `player-hand-${index}`;

        const title = document.createElement('h3');
        title.textContent = `Mano ${index + 1} - Punta: €${handBet}`;
        handDiv.appendChild(title);
        const cardsDiv = document.createElement('div');
        cardsDiv.classList.add('cards');
        handDiv.appendChild(cardsDiv);

        const scoreDiv = document.createElement('div');
        scoreDiv.classList.add('player-score');
        scoreDiv.textContent = 'Punteggio: 0';
        handDiv.appendChild(scoreDiv);

        const statusDiv = document.createElement('div');
        statusDiv.classList.add('hand-status');
        handDiv.appendChild(statusDiv);

        playerHandsContainer.appendChild(handDiv);
        return handDiv;
    }

    function updateHandDisplay(handData) {
        if (!handData || !handData.element) return;
        const cardsElement = handData.element.querySelector('.cards');
        const scoreElement = handData.element.querySelector('.player-score');
        const statusElement = handData.element.querySelector('.hand-status');

        renderHand(handData.cards, cardsElement);
        scoreElement.textContent = `Punteggio: ${handData.score}`;
        statusElement.textContent = handData.status === 'active' ? '' : handData.status.toUpperCase();

        document.querySelectorAll('.player-hand.current-hand').forEach(el => el.classList.remove('current-hand'));
        if (playerHands.indexOf(handData) === currentHandIndex && !isGameOver && handData.status === 'active') {
             handData.element.classList.add('current-hand');
        }
    }

    function updateDealerDisplay(revealHidden = false) {
        let scoreToShow = '?';
        let finalScore = 0;

        if (revealHidden) {
            dealerHand.forEach(card => {
                if (card.hidden) {
                     card.hidden = false;
                     updateRunningCount(card);
                }
            });
            renderHand(dealerHand, dealerCardsElement); // Re-render to flip cards
            finalScore = calculateScore(dealerHand);
            scoreToShow = finalScore;
        } else {
             renderHand(dealerHand, dealerCardsElement);
             if (dealerHand.length > 1 && !dealerHand[1].hidden) {
                 scoreToShow = getCardValue(dealerHand[1]);
             } else if (dealerHand.length === 1 && !dealerHand[0].hidden) {
                 scoreToShow = getCardValue(dealerHand[0]);
             }
        }
        dealerScoreElement.textContent = scoreToShow;
    }


     function startNewRound() {
        console.log("Starting new round...");
        clearTimeout(cardClearTimeout);
        dealerCardsElement.style.opacity = '1';
        playerHandsContainer.style.opacity = '1';

        if (deck.length < (decksInShoe * 52 * 0.25)) { // Reshuffle if penetration < 25%
            console.log("Deck low, creating and shuffling new shoe.");
            deck = createDeck();
            shuffleDeck(deck);
        }

        playerHandsContainer.innerHTML = '';
        dealerCardsElement.innerHTML = '';
        dealerScoreElement.textContent = '?';
        resultElement.textContent = '';
        resultElement.className = '';
        currentHandIndex = 0;
        isSplitRound = false;

        const handElement = createPlayerHandElement(0, initialBet); // initialBet is set by deal()
        playerHands = [{
            cards: [], score: 0, bet: initialBet, element: handElement, status: 'active',
            canDouble: true, canSplit: false, doubled: false
        }];
        dealerHand = [];

        dealCard(playerHands[0].cards);
        dealCard(dealerHand, true);
        dealCard(playerHands[0].cards);
        dealCard(dealerHand);

        playerHands[0].score = calculateScore(playerHands[0].cards);
        updateHandDisplay(playerHands[0]);
        updateDealerDisplay();

        const dealerPotentialScore = calculateScore(dealerHand);
        const playerInitialScore = playerHands[0].score;
        const playerHasBlackjack = playerInitialScore === 21 && playerHands[0].cards.length === 2;
        const dealerHasBlackjack = dealerPotentialScore === 21 && dealerHand.length === 2;

        if (playerHasBlackjack) {
             playerHands[0].status = 'blackjack';
             updateHandDisplay(playerHands[0]);
             sessionStatsData.blackjacks++;
             // No auto-win here, wait for dealer BJ check
        }

         if (dealerHasBlackjack) {
             console.log("Dealer has Blackjack.");
             updateDealerDisplay(true);
             endRound();
        } else if (playerHasBlackjack) {
             console.log("Player has Blackjack!");
             endRound(); // Player BJ wins if dealer doesn't have BJ
        } else {
            isGameOver = false;
            playerHands[0].canSplit = checkSplitPossibility(playerHands[0]);
            updateActionButtons();
            highlightHint();
        }
        saveGameState();
    }


    function deal() {
        if (proposedBet === 0) {
            alert("Per favore, piazza una puntata prima di distribuire le carte.");
            return;
        }
        if (proposedBet < currentTableLimits.min || proposedBet > currentTableLimits.max) {
            alert(`La puntata deve essere tra €${currentTableLimits.min} e €${currentTableLimits.max}.`);
            return;
        }
        if (proposedBet > playerMoney) {
            alert("Non hai abbastanza soldi per questa puntata.");
            return;
        }

        playerMoney -= proposedBet;
        initialBet = proposedBet;
        lastBet = initialBet;
        updatePlayerMoneyDisplay();
        bettingArea.style.display = 'none';
        gameArea.style.display = 'block';
        rebetButton.style.display = 'none';

        startNewRound();
        saveGameState();
    }


    function addBet(amount) {
        const potentialBet = proposedBet + amount;
        if (potentialBet > currentTableLimits.max) {
            alert(`La puntata massima è €${currentTableLimits.max}.`);
            return;
        }
        if (potentialBet > playerMoney) {
            alert("Non hai abbastanza soldi per aumentare la puntata.");
            return;
        }
        proposedBet = potentialBet;
        updateProposedBetDisplay();
        updateBettingUI();
    }

    function clearProposedBet() {
        proposedBet = 0;
        updateProposedBetDisplay();
        updateBettingUI();
    }

     function updateProposedBetDisplay() {
        proposedBetDisplay.textContent = `Punta: €${proposedBet}`;
        dealButton.disabled = (proposedBet < currentTableLimits.min || proposedBet > playerMoney || proposedBet > currentTableLimits.max);
        clearBetButton.disabled = (proposedBet === 0);
    }

    function rebet() {
        if (lastBet <= 0) {
            alert("Nessuna puntata precedente da ripetere.");
            return;
        }
        if (lastBet < currentTableLimits.min || lastBet > currentTableLimits.max) {
            alert(`La puntata precedente (€${lastBet}) non è valida per i limiti attuali (€${currentTableLimits.min} - €${currentTableLimits.max}). Piazza una nuova puntata.`);
            rebetButton.style.display = 'none';
            return;
        }
        if (lastBet > playerMoney) {
            alert("Non hai abbastanza soldi per ripetere l'ultima puntata.");
            rebetButton.style.display = 'none';
            return;
        }
        proposedBet = lastBet;
        updateProposedBetDisplay();
        deal();
    }


    function hit() {
        if (isGameOver) return;
        const currentHand = playerHands[currentHandIndex];
        if (currentHand.status !== 'active') return;

        dealCard(currentHand.cards);
        currentHand.score = calculateScore(currentHand.cards);
        currentHand.canDouble = false;
        currentHand.canSplit = false;
        updateHandDisplay(currentHand);

        if (currentHand.score > 21) {
            currentHand.status = 'bust';
            updateHandDisplay(currentHand);
            console.log(`Hand ${currentHandIndex + 1} Busts!`);
            moveToNextHandOrEndRound();
        } else {
            updateActionButtons();
            highlightHint();
            saveGameState();
        }
    }

    function stand() {
        if (isGameOver) return;
        const currentHand = playerHands[currentHandIndex];
        if (currentHand.status !== 'active') return;

        currentHand.status = 'stand';
        updateHandDisplay(currentHand);
        console.log(`Hand ${currentHandIndex + 1} Stands.`);
        moveToNextHandOrEndRound();
    }

    function doubleDown() {
        if (isGameOver) return;
        const currentHand = playerHands[currentHandIndex];
        if (currentHand.status !== 'active' || !currentHand.canDouble || playerMoney < currentHand.bet) {
             if (playerMoney < currentHand.bet) alert("Non hai abbastanza soldi per raddoppiare.");
             else if (!currentHand.canDouble) alert("Puoi raddoppiare solo sulla mano iniziale (prima di Chiamare Carta).");
             else console.log("Raddoppio non permesso ora.");
            return;
        }

        playerMoney -= currentHand.bet;
        currentHand.bet *= 2;
        currentHand.doubled = true;
        updatePlayerMoneyDisplay();
        const titleElement = currentHand.element.querySelector('h3');
        if (titleElement) {
             titleElement.textContent = `Mano ${playerHands.indexOf(currentHand) + 1} - Punta: €${currentHand.bet}`;
        }

        console.log(`Hand ${currentHandIndex + 1} Doubles Down!`);
        dealCard(currentHand.cards);
        currentHand.score = calculateScore(currentHand.cards);
        updateHandDisplay(currentHand);
        currentHand.status = (currentHand.score > 21) ? 'bust' : 'stand'; // Auto-stand after double
        updateHandDisplay(currentHand);

        moveToNextHandOrEndRound();
    }

    function checkSplitPossibility(handData) {
         return handData.status === 'active' &&
               handData.cards.length === 2 &&
               playerMoney >= handData.bet &&
               getCardValue(handData.cards[0]) === getCardValue(handData.cards[1]);
    }

    function split() {
         if (isGameOver) return;
         const currentHand = playerHands[currentHandIndex];
         if (!currentHand.canSplit) {
             console.log("Cannot split this hand.");
             if (playerMoney < currentHand.bet) alert("Non hai abbastanza soldi per dividere.");
             else if (currentHand.cards.length !== 2) alert("Puoi dividere solo sulla mano iniziale.");
             else if (getCardValue(currentHand.cards[0]) !== getCardValue(currentHand.cards[1])) alert("Le carte devono avere lo stesso valore per dividerle.");
             return;
         }
         if (playerHands.length >= 4) {
            alert("Non puoi dividere più di 4 mani.");
            return;
         }

         console.log(`Splitting hand ${currentHandIndex + 1}`);
         isSplitRound = true;
         const originalBet = currentHand.bet;
         playerMoney -= originalBet;
         updatePlayerMoneyDisplay();

         const secondCard = currentHand.cards.pop();

         const newHandIndex = playerHands.length; // New hand added at the end for simplicity in management
         const newHandElement = createPlayerHandElement(newHandIndex, originalBet);
         const newHand = {
             cards: [secondCard], score: 0, bet: originalBet, element: newHandElement,
             status: 'active', canDouble: true, canSplit: false, doubled: false
         };
         playerHands.push(newHand); // Add new hand to the array

         // Update titles for all hands to reflect their new indices if needed (though new hand is added at end)
         playerHands.forEach((hand, idx) => {
             const title = hand.element.querySelector('h3');
             if (title) title.textContent = `Mano ${idx + 1} - Punta: €${hand.bet}`;
             hand.element.id = `player-hand-${idx}`;
         });


         dealCard(currentHand.cards);
         dealCard(newHand.cards);

         currentHand.score = calculateScore(currentHand.cards);
         newHand.score = calculateScore(newHand.cards);

         // Blackjack on split Aces is usually 21, not Blackjack
         if (getCardValue(currentHand.cards[0]) === 11 && currentHand.score === 21) currentHand.status = 'stand'; // Auto-stand on split Aces
         else if (currentHand.score === 21) currentHand.status = 'blackjack';

         if (getCardValue(newHand.cards[0]) === 11 && newHand.score === 21) newHand.status = 'stand';
         else if (newHand.score === 21) newHand.status = 'blackjack';

         currentHand.canSplit = (getCardValue(currentHand.cards[0]) === 11 && currentHand.cards.length === 2) ? checkSplitPossibility(currentHand) : false;
         newHand.canSplit = (getCardValue(newHand.cards[0]) === 11 && newHand.cards.length === 2) ? checkSplitPossibility(newHand) : false;

         currentHand.canDouble = (currentHand.status === 'active' && (getCardValue(currentHand.cards[0]) !== 11 || playerHands.length > 2)); // Double not allowed on split Aces in some rules unless it's a resplit
         newHand.canDouble = (newHand.status === 'active' && (getCardValue(newHand.cards[0]) !== 11 || playerHands.length > 2));


         updateHandDisplay(currentHand);
         updateHandDisplay(newHand);

         if(currentHand.status === 'stand' || currentHand.status === 'blackjack') { // If first split hand auto-stands (e.g. split Aces)
             moveToNextHandOrEndRound();
         } else {
             updateActionButtons(); // Stay on current hand if it's still active
             highlightHint();
         }
         saveGameState();
    }


    function moveToNextHandOrEndRound() {
        const currentHand = playerHands[currentHandIndex];
        if (currentHand.status === 'bust' || currentHand.status === 'stand' || currentHand.status === 'blackjack' || currentHand.status === 'surrender') {
            currentHand.element.classList.remove('current-hand');
            if (currentHandIndex < playerHands.length - 1) {
                 currentHandIndex++;
                 const nextHand = playerHands[currentHandIndex];
                 nextHand.element.classList.add('current-hand');
                 if (nextHand.status !== 'active') {
                     moveToNextHandOrEndRound();
                 } else {
                     console.log(`Moving to Hand ${currentHandIndex + 1}`);
                     nextHand.canSplit = checkSplitPossibility(nextHand);
                     updateActionButtons();
                     highlightHint();
                     saveGameState();
                 }
             } else {
                 console.log("All player hands played. Playing dealer hand...");
                 playDealerHand();
             }
        }
    }


    async function playDealerHand() {
        updateDealerDisplay(true);
        let dealerScore = calculateScore(dealerHand);
        const hitSoft17 = true;

        while (dealerScore < 17 || (hitSoft17 && dealerScore === 17 && dealerHand.some(c => c.value === 'A' && calculateScore(dealerHand) === 17))) {
             console.log(`Dealer Hits (Score: ${dealerScore})`);
             await new Promise(resolve => setTimeout(resolve, 600));
             dealCard(dealerHand);
             dealerScore = calculateScore(dealerHand);
             updateDealerDisplay(true);
        }
         console.log(`Dealer Stands with ${dealerScore}`);
         await new Promise(resolve => setTimeout(resolve, 300));
         endRound();
    }


    function endRound() {
        isGameOver = true;
        updateDealerDisplay(true);
        const dealerScore = calculateScore(dealerHand);
        const dealerBusted = dealerScore > 21;
        let roundOutcomeMessages = [];
        let totalWinningsFromBets = 0; // Money returned to player (original bet + profit) for bets
        let totalBetAmountThisRound = 0; // Sum of all bets placed by player this round
        let handsWon = 0;
        let handsLost = 0;
        let handsPushed = 0;
        let gotBlackjackWin = false;
        let wonDoubleDown = false;

        playerHands.forEach((hand, index) => {
            totalBetAmountThisRound += hand.bet; // Accumulate total amount wagered
            let handResult = '';
            let handPayMultiplier = 0; // -1 for loss, 0 for push, 1 for win, 1.5 for BJ
            let handStatusSuffix = playerHands.length > 1 ? ` (Mano ${index + 1})` : '';
            let currentHandWonThis = false;

            if (hand.status === 'bust') {
                handResult = `Mano ${index + 1} Sballa`;
                handPayMultiplier = -1;
                handsLost++;
            } else {
                 const playerFinalScore = hand.score;
                 const isPlayerBlackjack = (hand.status === 'blackjack');

                 if (dealerBusted) {
                     handPayMultiplier = isPlayerBlackjack ? 1.5 : 1;
                     handResult = isPlayerBlackjack ? `Blackjack!${handStatusSuffix}` : `Dealer Sballa!${handStatusSuffix} Vince`;
                     if(isPlayerBlackjack) gotBlackjackWin = true;
                     handsWon++;
                     currentHandWonThis = true;
                 } else {
                     if (isPlayerBlackjack) {
                          if (dealerHand.length === 2 && dealerScore === 21) { // Dealer also has BJ
                            handResult = `Pareggio Blackjack!${handStatusSuffix}`; handPayMultiplier = 0; handsPushed++;
                          } else {
                            handResult = `Blackjack!${handStatusSuffix}`; handPayMultiplier = 1.5; handsWon++; gotBlackjackWin = true; currentHandWonThis = true;
                          }
                     } else if (dealerHand.length === 2 && dealerScore === 21) { // Dealer BJ vs player non-BJ
                        handResult = `Dealer Blackjack!${handStatusSuffix} Perde`; handPayMultiplier = -1; handsLost++;
                     } else if (playerFinalScore > dealerScore) {
                          handResult = `Mano ${index + 1} Vince`; handPayMultiplier = 1; handsWon++; currentHandWonThis = true;
                     } else if (playerFinalScore === dealerScore) {
                          handResult = `Mano ${index + 1} Pareggia`; handPayMultiplier = 0; handsPushed++;
                     } else {
                          handResult = `Dealer Vince${handStatusSuffix}`; handPayMultiplier = -1; handsLost++;
                     }
                 }
            }
             let winningsThisHandSegment = hand.bet + (handPayMultiplier * hand.bet);
             totalWinningsFromBets += winningsThisHandSegment;

             if (currentHandWonThis && hand.doubled) {
                 wonDoubleDown = true;
             }

             if (handPayMultiplier > 0) handResult += ` (+€${(handPayMultiplier * hand.bet).toFixed(0)})`;
             else if (handPayMultiplier < 0) handResult += ` (-€${hand.bet})`;
             else handResult += ` (Push)`;

             roundOutcomeMessages.push(handResult);
             hand.element.classList.remove('current-hand');
        });

        // Old playerMoney was already reduced by initialBet(s). Now add back the bets + profit/loss.
        playerMoney += totalWinningsFromBets;
        updatePlayerMoneyDisplay();

        let netChange = totalWinningsFromBets - totalBetAmountThisRound; // Actual profit/loss for the round
        let finalResultClass = '';
        if (netChange > 0) finalResultClass = 'win';
        else if (netChange < 0) finalResultClass = 'lose';
        else finalResultClass = 'push';

        showResult(roundOutcomeMessages.join('\n'), finalResultClass);

        sessionStatsData.hands += playerHands.length;
        sessionStatsData.wins += handsWon;
        sessionStatsData.losses += handsLost;
        sessionStatsData.pushes += handsPushed;
        // Blackjack wins are counted if player gets BJ and it results in a win or push (not loss to dealer BJ)
        if(gotBlackjackWin) { /* sessionStatsData.blackjacks already incremented when BJ is achieved */ }
        updateDailyChallengeProgress(handsWon, gotBlackjackWin, wonDoubleDown, playerHands);

        updateStatsDisplay();
        prepareNextRoundWithDelay();
        saveGameState();
    }

    function prepareNextRoundWithDelay() {
        const cardPersistDelay = 2000;
        setTimeout(() => {
            dealerCardsElement.style.opacity = '0';
            playerHandsContainer.style.opacity = '0';
        }, 500);
        clearTimeout(cardClearTimeout);
        cardClearTimeout = setTimeout(() => {
            resetBettingPhase();
        }, cardPersistDelay);
    }


    function resetBettingPhase() {
        isGameOver = true;
        proposedBet = 0;
        initialBet = 0;
        dealerScoreElement.textContent = '?';

        updateProposedBetDisplay();
        updateActionButtons();

        bettingArea.style.display = 'flex';
        gameArea.style.display = 'none';

        if (lastBet > 0 && lastBet >= currentTableLimits.min && lastBet <= currentTableLimits.max && lastBet <= playerMoney) {
             rebetButton.style.display = 'inline-block';
        } else {
             rebetButton.style.display = 'none';
        }
        updateBettingUI();
        checkOutOfMoney();
    }

     function checkOutOfMoney() {
         if (playerMoney < currentTableLimits.min && currentTableLimits.min > 0) {
             console.log("Player out of money for this table!");
             showResult(`Non hai abbastanza soldi (€${playerMoney}) per la puntata minima di €${currentTableLimits.min}.\nResetta i soldi (se non loggato) o cambia tavolo.`, "lose");
             dealButton.disabled = true;
             rebetButton.style.display = 'none';
             clickableChipsContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
         }
     }


    function updateActionButtons() {
        const bettingPhase = isGameOver;

        hitButton.disabled = bettingPhase;
        standButton.disabled = bettingPhase;
        doubleButton.disabled = bettingPhase;
        splitButton.disabled = bettingPhase;

        dealButton.disabled = !bettingPhase || (proposedBet < currentTableLimits.min || proposedBet > playerMoney || proposedBet > currentTableLimits.max);
        clearBetButton.disabled = !bettingPhase || (proposedBet === 0);

        if (!bettingPhase && playerHands.length > 0 && playerHands[currentHandIndex]) {
            const currentHand = playerHands[currentHandIndex];
            if (currentHand.status === 'active') {
                hitButton.disabled = false;
                standButton.disabled = false;
                doubleButton.disabled = !(currentHand.canDouble && playerMoney >= currentHand.bet && !currentHand.doubled); // Check not already doubled
                splitButton.disabled = !(currentHand.canSplit && playerMoney >= currentHand.bet); // Also check money for split
            }
        }
         applyHintHighlight();
    }

    function showResult(message, resultClass = '') {
        resultElement.innerHTML = message.replace(/\n/g, '<br>');
        resultElement.className = `result-show ${resultClass}`;
        const resultDisplayDuration = 4000;
        setTimeout(() => {
            resultElement.className = '';
        }, resultDisplayDuration);
    }

     function updatePlayerMoneyDisplay() {
        const moneyString = `Saldo: €${playerMoney}`;
        playerMoneyElement.textContent = `€${playerMoney}`;
        balanceDisplayElement.textContent = moneyString;
        if(isGameOver) {
             updateBettingUI();
             if (lastBet > 0 && lastBet >= currentTableLimits.min && lastBet <= currentTableLimits.max && lastBet <= playerMoney) {
                rebetButton.style.display = 'inline-block';
             } else {
                 rebetButton.style.display = 'none';
             }
             dealButton.disabled = (proposedBet < currentTableLimits.min || proposedBet > playerMoney || proposedBet > currentTableLimits.max);
        }
     }

    // --- UI Functions ---

    function setupChipButtons() {
        clickableChipsContainer.innerHTML = '';
        currentTableLimits.chips.forEach(value => {
            const chipButton = document.createElement('button');
            chipButton.classList.add('chip-button');
            chipButton.dataset.value = value;

            const valueSpan = document.createElement('span');
            valueSpan.classList.add('chip-value');
            valueSpan.textContent = value >= 1000 ? (value / 1000) + 'K' : value;
            chipButton.appendChild(valueSpan);

            chipButton.onclick = () => addBet(value);

            const requiresPremiumForThisTable = currentTableLimits.premium && !isPremium;
            chipButton.disabled = (
                 proposedBet + value > currentTableLimits.max ||
                 proposedBet + value > playerMoney ||
                 (requiresPremiumForThisTable && currentTableLimits.chips.includes(value))
             );

             if (requiresPremiumForThisTable && currentTableLimits.chips.includes(value)) {
                 chipButton.classList.add('premium-locked');
                 chipButton.onclick = (event) => {
                     event.preventDefault();
                     checkPremiumAccess(`Tavolo ${tableSelect.options[tableSelect.selectedIndex].text}`);
                 };
             }
            clickableChipsContainer.appendChild(chipButton);
        });
    }

    function updateBettingUI() {
        setupChipButtons();
        updateProposedBetDisplay();
        checkOutOfMoney();
    }

    function loadTheme() {
        const savedTheme = localStorage.getItem('blackjackTheme') || 'light';
        document.body.setAttribute('data-theme', savedTheme);
        themeToggle.checked = (savedTheme === 'dark');
    }


    function changeGame() {
        console.log("Redirecting to index.html...");
        window.location.href = 'index.html';
    }

    // --- Premium Features Handling ---

    function showPremiumPopup(featureName = "questa funzionalità") {
        premiumPopup.classList.add('show');
        premiumPopupOverlay.classList.add('show');
    }

    function closePremiumPopup() {
        premiumPopup.classList.remove('show');
        premiumPopupOverlay.classList.remove('show');
    }

    async function activatePremiumAndSave() { // Renamed and made async
         if (!isPremium) {
             if (currentUID) { // Check if a user is logged in
                 try {
                     await setUserVIPStatus(currentUID); // Update Firestore
                     isPremium = true; // Update local state
                     localStorage.setItem('blackjackPremium', 'true'); // Update local storage
                     applyPremiumFeatures();
                     closePremiumPopup();
                     await saveGameState(); // Save updated premium state to Firestore/local
                     alert("Premium attivato! Le funzionalità Premium sono ora disponibili.");
                     updateBettingUI();
                     updateChallengeDisplay();
                 } catch (error) {
                     console.error("Errore durante l'attivazione del Premium su Firestore:", error);
                     alert("Errore durante l'attivazione del Premium. Riprova.");
                 }
             } else {
                 // Fallback for non-logged-in users or if direct Firestore update isn't desired here
                 isPremium = true;
                 localStorage.setItem('blackjackPremium_local', 'true'); // Use a different key for local-only premium
                 applyPremiumFeatures();
                 closePremiumPopup();
                 // saveGameState(); // No need to save to Firestore if not logged in, localStorage will be handled
                 alert("Premium attivato (simulazione locale). Le funzionalità Premium sono ora disponibili per questa sessione.");
                 updateBettingUI();
                 updateChallengeDisplay();
             }
         } else {
             closePremiumPopup();
         }
    }


     function checkPremiumAccess(elementOrFeatureName) {
        if (isPremium) return true;

        let featureName = "questa funzionalità Premium";
        if (typeof elementOrFeatureName === 'string') {
            featureName = elementOrFeatureName;
        } else if (elementOrFeatureName) {
             const detailsSummary = elementOrFeatureName.closest('details')?.querySelector('summary');
             const label = document.querySelector(`label[for="${elementOrFeatureName.id}"]`);
             const option = elementOrFeatureName.tagName === 'OPTION' ? elementOrFeatureName : null;
             const chip = elementOrFeatureName.classList.contains('chip-button') ? elementOrFeatureName : null;
             const challengeItem = elementOrFeatureName.classList.contains('challenge-item') ? elementOrFeatureName : null;

             if (detailsSummary) featureName = detailsSummary.textContent.replace(/ ?- Premium/i, '').trim();
             else if (label) featureName = label.textContent.replace(/\(Premium\)/i, '').trim();
             else if (option) featureName = `Limite tavolo "${option.textContent.replace(' (Premium)', '')}"`;
             else if (chip) featureName = `Fiche da €${chip.dataset.value}`;
             else if (challengeItem) featureName = 'Sfida Premium';
        }
        showPremiumPopup(featureName);
        return false;
    }


    function applyPremiumFeatures() {
         console.log("Applying premium features state. isPremium:", isPremium);
         premiumFeatureSections.forEach(el => {
            const summary = el.querySelector('summary');
            if (isPremium) {
                el.classList.remove('premium-locked');
                el.onclick = null;
                if (summary) summary.style.cursor = 'pointer';
                 if (summary && summary.dataset.originalText) summary.textContent = summary.dataset.originalText;
            } else {
                el.classList.add('premium-locked');
                el.open = false;
                 if (summary) {
                     summary.style.cursor = 'not-allowed';
                     if (!summary.dataset.originalText) summary.dataset.originalText = summary.textContent;
                 }
                 const clickHandler = (event) => {
                     event.preventDefault();
                     checkPremiumAccess(el);
                 };
                 if (summary) summary.onclick = clickHandler; else el.onclick = clickHandler;
            }
        });
         premiumFeatureInputs.forEach(input => {
             const parentDiv = input.closest('.premium-option') || input.closest('div');
             const label = parentDiv?.querySelector('label.toggle-switch') || input;
            if (isPremium) {
                 input.disabled = false;
                 if (parentDiv) parentDiv.classList.remove('premium-locked');
                 label.onclick = null;
            } else {
                 input.disabled = true;
                 input.checked = false;
                 if (parentDiv) parentDiv.classList.add('premium-locked');
                 label.onclick = (event) => {
                     event.preventDefault();
                     checkPremiumAccess(input);
                 };
            }
        });
         tableSelect.querySelectorAll('option.premium-feature').forEach(option => {
            if (isPremium) {
                 option.disabled = false;
                 option.textContent = option.textContent.replace(" (Premium)", "");
             } else {
                 option.disabled = true;
                 if (!option.textContent.includes("(Premium)")) option.textContent += " (Premium)";
            }
         });

         trainingModeActive = trainingModeToggle.checked;
         showHintsActive = showHintsToggle.checked && isPremium;

         if (!isPremium && trainerControls.open) trainerControls.open = false;
         if (!isPremium && sessionStats.open) sessionStats.open = false;

         updateTrainerDisplay();
         updateStatsDisplay();
         applyHintHighlight();
         updateBettingUI();
         updateChallengeDisplay();
    }

    function resetStats() {
        if (!checkPremiumAccess('Statistiche Sessione')) return;
        if (confirm("Sei sicuro di voler azzerare le statistiche della sessione?")) {
            sessionStatsData = { hands: 0, wins: 0, losses: 0, pushes: 0, blackjacks: 0 };
            updateStatsDisplay();
            saveGameState();
        }
    }

    function updateStatsDisplay() {
        if (!sessionStats.open && !(isPremium && sessionStats.open)) return; // Check if open OR if it should be open for premium
        statsHandsElement.textContent = sessionStatsData.hands;
        statsWinsElement.textContent = sessionStatsData.wins;
        statsLossesElement.textContent = sessionStatsData.losses;
        statsPushesElement.textContent = sessionStatsData.pushes;
        statsBjsElement.textContent = sessionStatsData.blackjacks;
        const totalDecided = sessionStatsData.wins + sessionStatsData.losses;
        const winRate = totalDecided > 0 ? ((sessionStatsData.wins / totalDecided) * 100).toFixed(1) + '%' : 'N/A';
        statsWinRateElement.textContent = winRate;
    }

     function getHint() {
        if (!showHintsActive || !isPremium || isGameOver || !playerHands[currentHandIndex] || playerHands[currentHandIndex].status !== 'active') {
            return null;
        }
        const currentHand = playerHands[currentHandIndex];
        const playerScore = currentHand.score;
        const dealerUpCardValue = (dealerHand.length > 1 && !dealerHand[1].hidden) ? getCardValue(dealerHand[1]) : 0;
        const isSoft = currentHand.cards.some(c => c.value === 'A') && playerScore !== calculateScore(currentHand.cards.map(c => ({...c, value: (c.value === 'A' ? '1' : c.value)})));
        const canSplit = currentHand.canSplit && playerMoney >= currentHand.bet; // Ensure affordable
        const canDouble = currentHand.canDouble && playerMoney >= currentHand.bet && !currentHand.doubled; // Ensure affordable and not already doubled


        if (canSplit) {
            const cardValue = getCardValue(currentHand.cards[0]);
            if (cardValue === 11 || cardValue === 8) return 'split';
            if (cardValue === 9 && ![7, 10, 11].includes(dealerUpCardValue)) return 'split';
            if (cardValue === 7 && dealerUpCardValue <= 7) return 'split';
            if (cardValue === 6 && dealerUpCardValue <= 6) return 'split';
            if (cardValue === 4 && [5, 6].includes(dealerUpCardValue) && canDouble) return 'split';
            if ((cardValue === 2 || cardValue === 3) && dealerUpCardValue <= 7) return 'split';
        }
        if (isSoft) {
            if (playerScore >= 19) return 'stand';
            if (playerScore === 18) {
                 if ([2, 7, 8].includes(dealerUpCardValue)) return 'stand';
                 if (dealerUpCardValue >= 3 && dealerUpCardValue <= 6 && canDouble) return 'double';
                 else return 'hit';
            }
            if (playerScore === 17) {
                 if (dealerUpCardValue >= 3 && dealerUpCardValue <= 6 && canDouble) return 'double';
                 else return 'hit';
            }
             if (playerScore === 15 || playerScore === 16) {
                 if (dealerUpCardValue >= 4 && dealerUpCardValue <= 6 && canDouble) return 'double';
                 else return 'hit';
             }
             if (playerScore === 13 || playerScore === 14) {
                 if (dealerUpCardValue >= 5 && dealerUpCardValue <= 6 && canDouble) return 'double';
                 else return 'hit';
             }
             return 'hit';
        }
        if (playerScore >= 17) return 'stand';
        if (playerScore >= 13 && playerScore <= 16) {
             if (dealerUpCardValue <= 6) return 'stand';
             else return 'hit';
        }
        if (playerScore === 12) {
             if (dealerUpCardValue >= 4 && dealerUpCardValue <= 6) return 'stand';
             else return 'hit';
        }
        if (playerScore === 11 && canDouble) return 'double';
        if (playerScore === 10) {
             if (dealerUpCardValue <= 9 && canDouble) return 'double';
             else return 'hit';
        }
        if (playerScore === 9) {
             if (dealerUpCardValue >= 3 && dealerUpCardValue <= 6 && canDouble) return 'double';
             else return 'hit';
        }
        return 'hit';
     }

     function applyHintHighlight() {
        [hitButton, standButton, doubleButton, splitButton].forEach(btn => btn.classList.remove('hint-highlight'));
        const hint = getHint();
        if (!hint) return;
        let targetButton = null;
        switch(hint) {
            case 'hit': targetButton = hitButton; break;
            case 'stand': targetButton = standButton; break;
            case 'double': targetButton = !doubleButton.disabled ? doubleButton : hitButton; break;
            case 'split': targetButton = !splitButton.disabled ? splitButton : null; break;
        }
        if (targetButton && !targetButton.disabled) {
            targetButton.classList.add('hint-highlight');
        } else if (hint === 'double' && targetButton === hitButton && !hitButton.disabled) {
             hitButton.classList.add('hint-highlight');
        } else if (hint === 'split' && targetButton === null) {
             if (!hitButton.disabled) hitButton.classList.add('hint-highlight');
        }
     }
     function highlightHint() { applyHintHighlight(); }
     function showHiLoInfo() { alert("Conteggio Hi-Lo:\n\n- Carte Basse (2-6): +1\n- Carte Neutre (7-9): +0\n- Carte Alte (10, J, Q, K, A): -1\n\nConteggio Reale = Conteggio Corrente / Mazzi Rimanenti."); }

    // --- Daily Challenge & Bonus Logic ---

     function getChallengesForDay(timestamp = Date.now()) {
         const date = new Date(timestamp);
         const dayOfYear = Math.floor((timestamp - new Date(date.getFullYear(), 0, 0).getTime()) / (1000 * 60 * 60 * 24));
         const year = date.getFullYear();
         const seedBase = `${year}-${dayOfYear}`;
         const simpleHash = (str) => { let hash = 0; for (let i = 0; i < str.length; i++) { hash = ((hash << 5) - hash) + str.charCodeAt(i); hash |= 0; } return Math.abs(hash); };
         const mulberry32 = (seed) => () => { var t = seed += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; };
         const generatedChallenges = []; const usedTypes = new Set();
         const availableChallengeTypes = [
             { type: 'win_hands', baseTarget: 5, description: (t) => `Vinci ${t} mani` },
             { type: 'get_blackjack', baseTarget: 1, description: (t) => `Ottieni ${t === 1 ? 'un' : t} Blackjack vincente/i` },
             { type: 'play_hands', baseTarget: 10, description: (t) => `Gioca ${t} mani` },
             { type: 'double_down_win', baseTarget: 2, description: (t) => `Vinci ${t} mano/i con Raddoppio`},
             { type: 'reach_score_exact', baseTarget: 20, description: (t) => `Ottieni un punteggio di esattamente ${t} (senza sballare)` }, // Modified for exact score
             { type: 'win_streak', baseTarget: 3, description: (t) => `Ottieni una serie di ${t} vittorie consecutive` },
         ];
         for(let i = 0; i < DAILY_CHALLENGE_COUNT; i++) {
             const challengeSeed = simpleHash(seedBase + `-${i}`); const rng = mulberry32(challengeSeed);
             let selectedType, attempts = 0;
             do { selectedType = availableChallengeTypes[Math.floor(rng() * availableChallengeTypes.length)]; attempts++; }
             while (usedTypes.has(selectedType.type) && attempts < availableChallengeTypes.length * 3)
             usedTypes.add(selectedType.type);
             const isPremiumChallenge = (i === PREMIUM_CHALLENGE_INDEX);
             const targetMultiplier = selectedType.type === 'get_blackjack' ? 1 : (1 + Math.floor(rng() * (isPremiumChallenge ? 3 : 2))); // BJ target usually 1, others vary
             const target = selectedType.baseTarget * targetMultiplier;
             const reward = isPremiumChallenge ? PREMIUM_CHALLENGE_REWARD : (NORMAL_CHALLENGE_REWARD_BASE + Math.floor(rng() * 51));
             generatedChallenges.push({ id: `${seedBase}-${i}`, type: selectedType.type, target: target, current: 0, reward: reward, description: selectedType.description(target), completed: false, isPremium: isPremiumChallenge, lastCheckTimestamp: timestamp });
         }
         return generatedChallenges;
     }

     function loadDailyChallenges() {
        const savedChallenges = JSON.parse(localStorage.getItem('blackjackDailyChallenges_v2') || 'null'); // Use new key for new structure
        const now = Date.now();
        const todayIdBase = getChallengesForDay(now)[0].id.split('-').slice(0,2).join('-'); // YYYY-DayOfYear

        if (savedChallenges && Array.isArray(savedChallenges) && savedChallenges.length === DAILY_CHALLENGE_COUNT && savedChallenges[0].id.startsWith(todayIdBase)) {
            dailyChallenges = savedChallenges;
        } else {
            dailyChallenges = getChallengesForDay(now);
        }
        updateChallengeDisplay();
        saveGameState(); // Save generated/loaded challenges
     }

     function updateDailyChallengeProgress(handsWonThisRound, gotBlackjackWinThisRound, wonDoubleDownThisRound, playedHandsData) {
         if (!dailyChallenges || dailyChallenges.length === 0) return;
         let challengeUpdated = false;

         dailyChallenges.forEach(challenge => {
             if (challenge.completed || (challenge.isPremium && !isPremium)) return;
             let progressMade = 0;
             switch (challenge.type) {
                 case 'win_hands': progressMade = handsWonThisRound; break;
                 case 'get_blackjack': if (gotBlackjackWinThisRound) progressMade = 1; break;
                 case 'play_hands': progressMade = playedHandsData.length; break;
                 case 'double_down_win': if (wonDoubleDownThisRound) progressMade = 1; break;
                 case 'reach_score_exact':
                     if (playedHandsData.some(h => h.status !== 'bust' && h.score === challenge.target)) progressMade = 1;
                     break;
             }
             if (progressMade > 0) {
                 challenge.current = Math.min(challenge.current + progressMade, challenge.target);
                 challengeUpdated = true;
                 if (challenge.current >= challenge.target) {
                     challenge.completed = true; playerMoney += challenge.reward;
                     showResult(`Sfida Completata!\n${challenge.description}\n+€${challenge.reward}`, 'win');
                 }
             }
         });
         if (challengeUpdated) { updateChallengeDisplay(); saveGameState(); }
     }

    function updateChallengeDisplay() {
         if (!dailyChallengesContainer) return;
         dailyChallengesContainer.innerHTML = ''; challengesLoading.style.display = 'none';
         if (!dailyChallenges || dailyChallenges.length === 0) { dailyChallengesContainer.innerHTML = '<p>Nessuna sfida attiva.</p>'; return; }
         dailyChallenges.forEach(challenge => {
             const div = document.createElement('div'); div.classList.add('challenge-item');
             div.dataset.id = challenge.id; div.dataset.completed = challenge.completed;
             const isLocked = challenge.isPremium && !isPremium;
             if (isLocked) { div.classList.add('locked'); div.onclick = () => checkPremiumAccess(div); }
             if (challenge.isPremium) div.classList.add('premium-challenge');
             const descP = document.createElement('p'); descP.classList.add('challenge-description');
             descP.textContent = challenge.description + (challenge.isPremium ? ' (Premium)' : '');
             const progP = document.createElement('p'); progP.classList.add('challenge-progress-text');
             progP.textContent = `Progresso: ${isLocked ? '🔒' : challenge.current} / ${challenge.target}`;
             const barDiv = document.createElement('div'); barDiv.classList.add('challenge-progress-bar');
             const innerDiv = document.createElement('div'); innerDiv.classList.add('challenge-progress');
             innerDiv.style.width = isLocked ? '0%' : `${challenge.target > 0 ? (challenge.current / challenge.target) * 100 : 0}%`;
             barDiv.appendChild(innerDiv);
             const rewardP = document.createElement('p'); rewardP.classList.add('challenge-reward');
             rewardP.innerHTML = `Ricompensa: <span style="color: var(--highlight-color); font-weight: bold;">€${challenge.reward}</span>`;
             div.append(descP, progP, barDiv, rewardP);
             if (challenge.completed && !isLocked) {
                 const compP = document.createElement('p'); compP.classList.add('challenge-completed-text');
                 compP.textContent = 'Completata!'; div.appendChild(compP);
             }
             dailyChallengesContainer.appendChild(div);
         });
     }

    // --- Daily Bonus & Streak Logic ---
    function isSameDay(timestamp1, timestamp2) {
        if (!timestamp1 || !timestamp2) return false;
        const date1 = new Date(timestamp1); const date2 = new Date(timestamp2);
        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    }
    function isConsecutiveDay(timestamp1, timestamp2) {
         if (!timestamp1 || !timestamp2) return false;
         const date1 = new Date(timestamp1); const date2 = new Date(timestamp2);
         const oneDay = 24 * 60 * 60 * 1000;
         const date1StartOfDay = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()).getTime();
         const date2StartOfDay = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()).getTime();
         return (date2StartOfDay - date1StartOfDay) === oneDay;
    }
    function checkDailyBonusAndStreak() {
        const savedInfo = JSON.parse(localStorage.getItem('blackjackDailyBonusInfo_v2') || 'null'); // New key
        const now = Date.now();
        if (savedInfo) dailyBonusInfo = savedInfo;
        else dailyBonusInfo = { collectedToday: false, lastLoginTimestamp: 0, consecutiveDays: 0 };

        if (!isSameDay(now, dailyBonusInfo.lastLoginTimestamp)) {
            dailyBonusInfo.collectedToday = false;
            if (dailyBonusInfo.lastLoginTimestamp !== 0 && isConsecutiveDay(dailyBonusInfo.lastLoginTimestamp, now)) {
                dailyBonusInfo.consecutiveDays++;
            } else if (dailyBonusInfo.lastLoginTimestamp !== 0) {
                dailyBonusInfo.consecutiveDays = 1;
            } else { dailyBonusInfo.consecutiveDays = 1; } // First login
            dailyBonusInfo.lastLoginTimestamp = now;
            collectDailyBonus();
        } else if (!dailyBonusInfo.collectedToday) {
             collectDailyBonus(); // Allow collection if missed on same day somehow
        }
        // Saving of dailyBonusInfo happens in collectDailyBonus or after loading if no collection happens
        saveGameState(); // Ensure it's saved even if no bonus was collected immediately
    }
     function collectDailyBonus() {
         if (dailyBonusInfo.collectedToday) return;
         const baseBonus = 500; // Reduced base for balance
         const streakBonus = (dailyBonusInfo.consecutiveDays > 1) ? (dailyBonusInfo.consecutiveDays - 1) * 25 : 0; // Smaller streak
         const totalBonus = baseBonus + streakBonus;
         playerMoney += totalBonus;
         dailyBonusInfo.collectedToday = true;
         let bonusMessage = `Bonus Giornaliero!\n+€${baseBonus}`;
         if (streakBonus > 0) bonusMessage += `\nSerie (${dailyBonusInfo.consecutiveDays}g): +€${streakBonus}`;
         updatePlayerMoneyDisplay(); showResult(bonusMessage, 'win');
         saveGameState(); // Save after collection
     }

    // --- Save/Load Game State ---
    async function saveGameState() { // Make async for Firestore
        const gameState = {
            playerMoney: playerMoney, lastBet: lastBet, isPremium: isPremium,
            sessionStats: sessionStatsData, theme: themeToggle.checked ? 'dark' : 'light',
            trainingMode: trainingModeToggle.checked, showHints: showHintsToggle.checked,
            utilityOpen: utilityControls.open, trainerOpen: trainerControls.open,
            statsOpen: sessionStats.open, challengeOpen: dailyChallengesDetails.open,
            selectedTable: tableSelect.value, dailyBonusInfo: dailyBonusInfo,
            dailyChallenges: dailyChallenges,
        };
        const localGameStateKey = currentUID ? `blackjackGameState_${currentUID}` : 'blackjackGameState_local';
        localStorage.setItem(localGameStateKey, JSON.stringify(gameState));

        if (currentUID) {
            try {
                await updateSaldoInFirestore(currentUID, playerMoney);
                // Potentially save other parts of gameState to Firestore user document if needed
                // For now, only saldo and isPremium (via setUserVIPStatus) are in Firestore.
                console.log("Stato del gioco (saldo) salvato su Firestore.");
            } catch (error) {
                console.error("Errore nel salvare il saldo su Firestore:", error);
            }
        }
        // console.log("Game state saved.");
    }

    async function loadGameState() { // Make async for Firestore
        loadTheme();
        let savedState = {};
        const localGameStateKey_local = 'blackjackGameState_local'; // Generic local key

        if (currentUID) { // User is logged in
            const firestoreSaldo = await getSaldoFromFirestore(currentUID);
            playerMoney = (firestoreSaldo !== undefined && firestoreSaldo !== null) ? firestoreSaldo : DEFAULT_PLAYER_MONEY;
            isPremium = await checkUserVIPStatus(currentUID);
            localStorage.setItem('blackjackPremium', isPremium ? 'true' : 'false'); // Sync local for immediate UI updates

            // Try loading other game state aspects from user-specific localStorage
            const userSpecificLocalKey = `blackjackGameState_${currentUID}`;
            savedState = JSON.parse(localStorage.getItem(userSpecificLocalKey) || '{}');
            authStatusDisplayElement.textContent = `Connesso`; // Simpler, real email later
        } else { // User not logged in
            savedState = JSON.parse(localStorage.getItem(localGameStateKey_local) || '{}');
            playerMoney = savedState.playerMoney !== undefined ? savedState.playerMoney : DEFAULT_PLAYER_MONEY;
            isPremium = savedState.isPremium === true; // Check local premium if not logged in
            authStatusDisplayElement.textContent = "Non collegato";
        }

        lastBet = savedState.lastBet !== undefined ? savedState.lastBet : 0;
        sessionStatsData = savedState.sessionStats || { hands: 0, wins: 0, losses: 0, pushes: 0, blackjacks: 0 };
        trainingModeToggle.checked = savedState.trainingMode === true;
        showHintsToggle.checked = (savedState.showHints === true) && isPremium;
        utilityControls.open = savedState.utilityOpen === true;
        trainerControls.open = (savedState.trainerOpen === true) && isPremium;
        sessionStats.open = (savedState.statsOpen === true) && isPremium;
        dailyChallengesDetails.open = savedState.challengeOpen === true;

        const savedTable = savedState.selectedTable || 'low';
        if (TABLE_LIMITS[savedTable]) {
             if (TABLE_LIMITS[savedTable].premium && !isPremium) {
                 tableSelect.value = 'low'; currentTableLimits = TABLE_LIMITS.low;
             } else {
                 tableSelect.value = savedTable; currentTableLimits = TABLE_LIMITS[savedTable];
             }
        } else { tableSelect.value = 'low'; currentTableLimits = TABLE_LIMITS.low; }

        applyPremiumFeatures(); // Apply based on loaded 'isPremium'

        dailyBonusInfo = savedState.dailyBonusInfo || { collectedToday: false, lastLoginTimestamp: 0, consecutiveDays: 0 };
        dailyChallenges = savedState.dailyChallenges || [];

        // After loading all state, then check/load daily items based on the user's status
        checkDailyBonusAndStreak();
        loadDailyChallenges(); // This will generate if outdated or missing for current user status

        updatePlayerMoneyDisplay();
        updateStatsDisplay();
        updateTrainerDisplay();
        updateBettingUI();
        console.log("Game state loaded.");
        resetBettingPhase();
    }


    // --- Initialization ---
    function initializeEventListeners() {
        themeToggle.addEventListener('change', async () => {
            const theme = themeToggle.checked ? 'dark' : 'light';
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('blackjackTheme', theme); // Also save to general local storage for theme persistence
            await saveGameState();
        });
        trainingModeToggle.addEventListener('change', async () => {
             trainingModeActive = trainingModeToggle.checked;
             if (trainingModeActive && trainerControls.open) updateTrainerDisplay();
             else if (!trainingModeActive) { runningCountElement.textContent = '0'; decksRemainingElement.textContent = '0.0'; trueCountElement.textContent = '0.0';}
             await saveGameState();
        });
        showHintsToggle.addEventListener('change', async (event) => {
             if (event.target.checked && !checkPremiumAccess(event.target)) { event.target.checked = false; return; }
             showHintsActive = event.target.checked; applyHintHighlight(); await saveGameState();
        });
        tableSelect.addEventListener('change', async (event) => {
             const selectedLimitKey = event.target.value; const newLimits = TABLE_LIMITS[selectedLimitKey];
             if (!newLimits) return;
             if (newLimits.premium && !checkPremiumAccess(event.target.options[event.target.selectedIndex])) {
                 tableSelect.value = Object.keys(TABLE_LIMITS).find(key => TABLE_LIMITS[key] === currentTableLimits) || 'low'; return;
             }
             currentTableLimits = newLimits; proposedBet = 0; lastBet = 0; rebetButton.style.display = 'none';
             await saveGameState(); updateBettingUI(); alert("Limiti del tavolo cambiati. Piazza una nuova puntata.");
        });

        // Buttons with onclick in HTML are fine, but for dynamically added or cleaner setup:
        dealButton.onclick = deal;
        rebetButton.onclick = rebet;
        clearBetButton.onclick = clearProposedBet;
        hitButton.onclick = hit;
        standButton.onclick = stand;
        doubleButton.onclick = doubleDown;
        splitButton.onclick = split;
        resetStatsButton.onclick = resetStats;
        changeGameButton.onclick = changeGame;
        hiloInfoButton.onclick = showHiLoInfo;
        closePremiumPopupButton.onclick = closePremiumPopup;
        activatePremiumButton.onclick = activatePremiumAndSave; // Changed to new async function
        premiumPopupOverlay.onclick = closePremiumPopup;


        utilityControls.addEventListener('toggle', saveGameState);
        dailyChallengesDetails.addEventListener('toggle', saveGameState);
        trainerControls.addEventListener('toggle', (event) => {
             if (event.target.open && !checkPremiumAccess(trainerControls)) { event.target.open = false; event.preventDefault(); }
             else { if (event.target.open) updateTrainerDisplay(); saveGameState(); }
        });
        sessionStats.addEventListener('toggle', (event) => {
             if (event.target.open && !checkPremiumAccess(sessionStats)) { event.target.open = false; event.preventDefault(); }
             else { if (event.target.open) updateStatsDisplay(); saveGameState(); }
        });
    }


    // --- Game Initialization on Load ---
    window.onload = async () => {
        console.log("Window loaded. Initializing Blackjack game with Firebase...");
        initializeEventListeners(); // Setup listeners first
        // The onAuthStateChanged listener will trigger loadGameState and other UI updates
        // loadGameState will be called once auth state is known.
        // For initial load before auth state is confirmed, can show a loading state or use local data.
        // For simplicity here, onAuthStateChanged will handle the main data load.
        // We can call loadTheme here as it doesn't depend on auth.
        loadTheme();
        updateBettingUI(); // Initial chip setup based on default limits
        // If no user is logged in after a brief moment, proceed with local/default state
        setTimeout(() => {
            if (currentUID === null) { // Check if auth listener has set a UID
                console.log("No user logged in after initial delay, loading default/local state.");
                loadGameState(); // This will use local storage or defaults if currentUID is still null
            }
        }, 1500); // Wait a bit for Firebase auth to initialize
    };

    // Initialize deck (will be shuffled by loadGameState or startNewRound)
    deck = createDeck();
    shuffleDeck(deck);

</script>
</body>
</html>
